<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on LittleDriver</title>
    <link>http://littledriver.net/tags/golang/</link>
    <description>Recent content in Golang on LittleDriver</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 14 Aug 2018 15:45:25 +0800</lastBuildDate>
    
	<atom:link href="http://littledriver.net/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Head First Scheduler of Golang</title>
      <link>http://littledriver.net/posts/head-first-scheduler-of-golang/</link>
      <pubDate>Tue, 14 Aug 2018 15:45:25 +0800</pubDate>
      
      <guid>http://littledriver.net/posts/head-first-scheduler-of-golang/</guid>
      <description>我们的程序是如何被运行的？ 学习过操作系统的人，应该对进程和线程的模型都是有所了解的。按照我的理解：「进程」是操作系统资源分配的基本单位，它给程序提供了一个良好的运行环境。「线程」则是一个轻量级的进程，一个「进程」中可以有很多线程，但是最终在一个 CPU 的核上只能有一个「进程」的其中一个「线程」被执行。所以，我们的一个程序的执行过程可以粗略的理解为：
 程序的可执行文件被 Load 到内存中 创建进程&amp;amp;创建主线程 主线程被 OS 调度到合适的 CPU 执行  goroutine 是什么？ 看了很多文章对于 goroutine 的描述，其中出现最多的一句话就是「The goroutine is a lightweight thread.」。在结合了对操作系统的线程模型的理解之后，我觉得 goroutine 就是一个在用户空间（usernamespace）下实现的「线程」，它由 golang 的 runtime 进行管理。goroutine 和 go runtime 的关系可以直接的类比于线程和操作系统内核的关系。至于它是不是轻量级，这需要和操作系统的线程进行对比之后才能够知道。在此我们先避免「人云亦云」。
goroutine 和 thread 有什么不同？ 目前看起来 goroutine 和 thread 在实现的思路上是比较相似的。但是为什么说 goroutine 比 thread 要轻量呢？从字面的意思上来理解，「轻量」肯定意味着消耗的系统资源变少了。
内存消耗 OS 从 OS 的层面来说，内存大致可以分为三个部分：一部分为栈（Stack）另外一部分为堆（Heap），最后一部分为程序代码的存储空间（Programe Text）。既然在逻辑上 OS 已经对内存的布局做了划分，如果栈和堆之前如果没有遵守「分界线」而发生了 overwrite，那么结果将是灾难性的。为了防止发生这种情况，OS 在 Stack 和 Heap 之间设置了一段不可被 overwrite 的区域：Guard Page
thread 通过对 OS 中线程模型的了解，我们可以知道：同一个进程的多个线程共享进程的地址空间。所以，每一个 thread 都会有自己的 Stack 空间以及一份 Guard Page用于线程间的隔离。在程序运行的过程中，线程越多，消耗的内存也就越多。当一个线程被创建的时候，通常会消耗大概1MB的空间（预分配的 Stack 空间+ Guard Page）。</description>
    </item>
    
    <item>
      <title>Golang Log Level Best Pratice-1</title>
      <link>http://littledriver.net/posts/golang-log-level-best-pratice/</link>
      <pubDate>Thu, 03 May 2018 13:39:17 +0800</pubDate>
      
      <guid>http://littledriver.net/posts/golang-log-level-best-pratice/</guid>
      <description>写在前面 在使用 Golang 语言开发的过程中，被广大开发者广泛使用的 Debug 方式应该就是观测服务输出的关键性日志信息了。这也就是我们俗称的「日志 Debug」 方式。虽然 Golang 也可以通过一些断点调试的方法去 Debug，这种方式在 Demo 阶段或者仅仅做一个 Experiment 的时候可能是比较好的，但是在真正的生产环境中或者说高并发的场景下，断点调试就会显得力不从心了。所以，主流的方式可能仍然是「日志 Debug」。
对于 Log 的使用，可能大多数人都倾向于使用一些第三方的日志工具。毕竟 Golang 官方的 Log 库提供的功能以及对 Log 输出的可定制性都是有限的。主流的日志工具库有以下两个：
 https://github.com/sirupsen/logrus https://github.com/golang/glog  这两个日志工具库都提供了丰富的功能，其中一个共性的功能就是「按照级别输出日志」。因为在输出日志的时候，可能会有以下输出级别给你选择，不同的级别可能代表着这条日志输出的优先级，重要性，作用都是不同的：
 Error Fatal Info Warn Debug  那么在接下来的两篇关于「Golang Log」的文章当中，将会根据笔者的实践经验，在日志级别的使用以及日志库工具的使用上给出一些我自己的「Best Practice」。
Warn Warn 这种日志级别一直让我感觉比较困惑，按照单词的字面意思来理解，它是用来输出警告信息的。那警告这种级别到底是用于什么场景呢？如果是错误的话那应该直接用 Error，如果是简单的输出一些信息的话，那么用 Debug 和 Info 都是可以的。这样看来，Warn 这种级别就很尴尬，和其他的级别没有明显的区别，导致开发者在选择日志输出级别的时候就多了一种令人困惑的选择。如果你一直在使用 Warn 这种日志级别在输出「错误」信息的话，建议还是改成 Error 较好。最主要的原因就是，滥用 Warn 级别可能会给我们的日志造成很大的噪音，因为大家潜意识里就认为 Warn 不重要，Error 才是需要注意的。这样一来，把错误信息放在 Warn 里面输出就是非常不合适的，很有可能让我们忽略一些关键的信息。
日志输出级别上的 Warn 和监控报警级别中的 Warn 显然不是一回事，前者是将输出的日志信息划分等级，以此来帮助我们追查问题和观察程序运行的情况。后者则是用来像我们报告服务的某些指标已经很接近 Error 报警的阈值，提醒我们要注意。并且监控报警中的 Warn 级别也是提倡要善用的，滥用同样会导致噪声。</description>
    </item>
    
    <item>
      <title>Reflection in golang (4)</title>
      <link>http://littledriver.net/posts/reflection-in-golang-4/</link>
      <pubDate>Sun, 12 Mar 2017 13:00:47 +0000</pubDate>
      
      <guid>http://littledriver.net/posts/reflection-in-golang-4/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reflection in golang (3)</title>
      <link>http://littledriver.net/posts/reflection-in-golang-3/</link>
      <pubDate>Sat, 11 Mar 2017 15:53:31 +0000</pubDate>
      
      <guid>http://littledriver.net/posts/reflection-in-golang-3/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reflection in golang (2)</title>
      <link>http://littledriver.net/posts/reflection-in-golang-2/</link>
      <pubDate>Thu, 09 Mar 2017 19:41:34 +0000</pubDate>
      
      <guid>http://littledriver.net/posts/reflection-in-golang-2/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reflection in golang (1)</title>
      <link>http://littledriver.net/posts/reflection-in-golang/</link>
      <pubDate>Sun, 05 Mar 2017 19:40:29 +0000</pubDate>
      
      <guid>http://littledriver.net/posts/reflection-in-golang/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>