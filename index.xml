<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on LittleDriver</title>
    <link>http://littledriver.net/</link>
    <description>Recent content in Home on LittleDriver</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Nov 2018 09:12:21 +0800</lastBuildDate>
    
        <atom:link href="http://littledriver.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Detect the Source Code of List Watch Between API Server and Controller</title>
      <link>http://littledriver.net/post/2018/11/22/detect-the-source-code-of-list-watch-between-api-server-and-controller/</link>
      <pubDate>Thu, 22 Nov 2018 09:12:21 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/22/detect-the-source-code-of-list-watch-between-api-server-and-controller/</guid>
      
        <description>

&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;在上一篇blog 中，我们从源码的角度来分析了 Kubernetes 中的&lt;code&gt;List-Watch&lt;/code&gt;机制的部分内容。它更注重于 API Server 和 etcd 之间的交互。通过下面的这幅 Kubernetes 的架构图和&lt;code&gt;List-Watch&lt;/code&gt;机制的时序图我们可以知道，API Server 通过&lt;code&gt;List-Watch&lt;/code&gt;机制获取到的资源对象的信息还将用于 Kubernetes 内置的 Controller 和我们自定义的 Controller，甚至是 Scheduler 和 Kubelet。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/list1&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/EAE14BFE-CD40-444E-A2E6-FBE8178F2F8E.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本文我们将通过对&lt;code&gt;ReplicaSetController&lt;/code&gt;源码的分析来了解，API Server 保存的和资源对象有关的数据到底是怎么流动到 Controller（目的组件）中的，以及最终这些数据是如何被处理的。&lt;/p&gt;

&lt;h2 id=&#34;controllermanager&#34;&gt;ControllerManager&lt;/h2&gt;

&lt;p&gt;Kubernetes 中一个非常重要的组件就是：ControllerManager。它负责管理集群内部各个资源控制器（Controller） 的启停。通过阅读 ControManager 的代码可以很容易的发现，它在运行起来的时候会启动 Kubernetes 内置的各个 Controller。（下面的实例我截取了部分关键的逻辑，完整版的链接：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/f48e18faa4dc035cc927c6a2b34c83c8475b55fa/cmd/kube-controller-manager/app/controllermanager.go#L207&#34;&gt;kubernetes/controllermanager.go at f48e18faa4dc035cc927c6a2b34c83c8475b55fa · kubernetes/kubernetes · GitHub&lt;/a&gt;
）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;run&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;controllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;CreateControllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rootClientBuilder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;clientBuilder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;klog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;error building controller context: %v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;StartControllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;saTokenControllerInitFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewControllerInitializers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LoopMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsecuredMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;klog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;error starting controllers: %v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;controllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;InformerFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;InformersStarted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上述逻辑有几个值得注意的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;StartControllers&lt;/li&gt;
&lt;li&gt;NewControllerInitializers&lt;/li&gt;
&lt;li&gt;controllerContext

&lt;ol&gt;
&lt;li&gt;controllerContext.InformerFactory.Start&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;startcontrollers&#34;&gt;StartControllers&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;StartControllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ControllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startSATokenController&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;InitFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;InitFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsecuredMux&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PathRecorderMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;controllerName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;initFn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsControllerEnabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controllerName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;glog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Warningf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%q is disabled&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;controllerName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Jitter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ComponentConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ControllerStartInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ControllerStartJitter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;glog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Infof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Starting %q&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;controllerName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;debugHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;started&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initFn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;StartControllers 的逻辑比较简单，它遍历了一个存有 Controller 的 Map，依次调用 Controller 的启动函数&lt;code&gt;initFn&lt;/code&gt;。这个 Map 是通过函数参数传递进来的，对这个参数进行赋值的位置也正是&lt;code&gt;NewControllerInitializers&lt;/code&gt;函数被调用的位置。&lt;/p&gt;

&lt;h3 id=&#34;newcontrollerinitializers&#34;&gt;NewControllerInitializers&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewControllerInitializers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loopMode&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ControllerLoopMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;InitFunc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;InitFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;endpoint&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startEndpointController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;replicationcontroller&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startReplicationController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;podgc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startPodGCController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;resourcequota&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startResourceQuotaController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startNamespaceController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;serviceaccount&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startServiceAccountController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;garbagecollector&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startGarbageCollectorController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;daemonset&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startDaemonSetController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;job&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startJobController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;deployment&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startDeploymentController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;replicaset&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startReplicaSetController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;horizontalpodautoscaling&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startHPAController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;disruption&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startDisruptionController&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;controllers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;statefulset&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startStatefulSetController&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;截取该函数的部分逻辑就可以看出，它构造了一个 key 为 Controller 名字，value 为 Controller 创建函数的 Map。&lt;/p&gt;

&lt;h3 id=&#34;controllercontext&#34;&gt;controllerContext&lt;/h3&gt;

&lt;p&gt;有了 &lt;code&gt;NewControllerInitializers&lt;/code&gt;和&lt;code&gt;StartControllers&lt;/code&gt;的出现，按理说 Controller 就可以启动了。但是我们发现在&lt;code&gt;StartControllers&lt;/code&gt;函数调用的位置，传递进去了一个比较特殊的参数：&lt;code&gt;controllerContext&lt;/code&gt;，它是通过&lt;code&gt;CreateControllerContext&lt;/code&gt;函数创建的。&lt;/p&gt;

&lt;p&gt;查看&lt;code&gt;CreateControllerContext&lt;/code&gt;函数逻辑后发现并没有什么特别的地方，唯一值得注意的就是一个名为&lt;code&gt;sharedInformers&lt;/code&gt;的变量。因为他在 ControllerManager 中的 Run 函数内调用了自己的 Start 方法。&lt;/p&gt;

&lt;h3 id=&#34;controllercontext-informerfactory&#34;&gt;controllerContext.InformerFactory&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;controllerContext.InformerFactory&lt;/code&gt;被我们在上面说到&lt;code&gt;sharedInformers&lt;/code&gt;赋值。根据创建&lt;code&gt;shardInformers&lt;/code&gt; 的流程跟进下去，我们发现它的核心逻辑在这里：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/7f23a743e8c23ac6489340bbb34fa6f1d392db9d/staging/src/k8s.io/apiextensions-apiserver/pkg/client/informers/externalversions/factory.go#L91&#34;&gt;kubernetes/factory.go at 7f23a743e8c23ac6489340bbb34fa6f1d392db9d · kubernetes/kubernetes · GitHub&lt;/a&gt;。并且同时发现，它所实现的 Start 函数，其实是通过遍历其内部一个名为&lt;code&gt;informers&lt;/code&gt;的Map，调用了每一个&lt;code&gt;informer&lt;/code&gt;实现的 Run 函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewSharedInformerFactoryWithOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;kubernetes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;defaultResync&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SharedInformerOption&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SharedInformerFactory&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;factory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sharedInformerFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;           &lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NamespaceAll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;defaultResync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;defaultResync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;informers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;        &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SharedIndexInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;startedInformers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;customResync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// Apply all options
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;opt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;factory&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;opt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;factory&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Start initializes all requested informers.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sharedInformerFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;informerType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;informer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;informers&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;startedInformers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;informerType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;informer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;startedInformers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;informerType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;那么现在看起来，这个&lt;code&gt;informer&lt;/code&gt;和其 Run 函数的实现就值得我们再去深入的了解一下了。&lt;/p&gt;

&lt;h4 id=&#34;informer&#34;&gt;informer&lt;/h4&gt;

&lt;p&gt;Informer 的数据类型是&lt;code&gt;cache.SharedIndexInformer&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// SharedInformer has a shared data cache and is capable of distributing notifications for changes
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// to the cache to multiple listeners who registered via AddEventHandler. If you use this, there is
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// one behavior change compared to a standard Informer.  When you receive a notification, the cache
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// will be AT LEAST as fresh as the notification, but it MAY be more fresh.  You should NOT depend
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// on the contents of the cache exactly matching the notification you&amp;#39;ve received in handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// functions.  If there was a create, followed by a delete, the cache may NOT have your item.  This
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// has advantages over the broadcaster since it allows us to share a common cache across many
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// controllers. Extending the broadcaster would have required us keep duplicate caches for each
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// watch.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SharedInformer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// AddEventHandler adds an event handler to the shared informer using the shared informer&amp;#39;s resync
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// period.  Events to a single handler are delivered sequentially, but there is no coordination
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// between different handlers.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;AddEventHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ResourceEventHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// AddEventHandlerWithResyncPeriod adds an event handler to the shared informer using the
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// specified resync period.  Events to a single handler are delivered sequentially, but there is
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// no coordination between different handlers.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;AddEventHandlerWithResyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ResourceEventHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// GetStore returns the Store.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;GetStore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Store&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// GetController gives back a synthetic interface that &amp;#34;votes&amp;#34; to start the informer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;GetController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Controller&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Run starts the shared informer, which will be stopped when stopCh is closed.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;Run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// HasSynced returns true if the shared informer&amp;#39;s store has synced.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;HasSynced&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// LastSyncResourceVersion is the resource version observed when last synced with the underlying
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// store. The value returned is not synchronized with access to the underlying store and is not
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// thread-safe.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;LastSyncResourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SharedIndexInformer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;SharedInformer&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// AddIndexers add indexers to the informer before it starts.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;AddIndexers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;indexers&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Indexers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;GetIndexer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Indexer&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过它的数据结构的定义以及注释我们兴奋的发现，&lt;code&gt;SharedIndexInformer&lt;/code&gt;类型的对象可能正是多个 Controller 从 API Server 接收资源对象信息的一个入口。总结下来，&lt;code&gt;SharedIndexInformer&lt;/code&gt;有如下几个特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;它和 API Server 一样，在内部会维护一个缓存。一旦缓存的内容有变化，它将通知给关心这些消息的对象。「关心」的方式很简单，就是自己实现这些消息的处理函数，并将它们注册到&lt;code&gt;SharedIndexInformer&lt;/code&gt;类型的实例中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ResourceEventHandlerFuncs is an adaptor to let you easily specify as many or
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// as few of the notification functions as you want while still implementing
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ResourceEventHandler.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ResourceEventHandlerFuncs&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;AddFunc&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;UpdateFunc&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;oldObj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newObj&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;DeleteFunc&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SharedIndexInformer&lt;/code&gt; 所维护的缓存将尽量保证其中的内容和实时的资源对象的信息一致。但是我们不能够依赖通过 event 形式发来的资源对象的信息和缓存内容之间的匹配关系。如过一个资源对象的创建和删除操作发生的间隔时间比较短，那么缓存中最终是没有这个资源对象的信息的。这非常符合 Kubernetes 的开发理念：保持数据的最终一致性。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;run&#34;&gt;Run&lt;/h4&gt;

&lt;p&gt;大概了解了&lt;code&gt;informer&lt;/code&gt; 的实现原理后，我们来看下它的 Run 函数的逻辑：
&lt;a href=&#34;https://github.com/kubernetes/client-go/blob/ee7a1ba5cdf1292b67a1fdf1fa28f90d2a7b0084/tools/cache/shared_informer.go#L189&#34;&gt;client-go/shared_informer.go at ee7a1ba5cdf1292b67a1fdf1fa28f90d2a7b0084 · kubernetes/client-go · GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在去掉了一些干扰性的信息之后，我们发现，Run 函数做的核心工作有两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过配置信息创建一个 controller 对象&lt;/li&gt;
&lt;li&gt;调用这个 controller 对象的 Run 函数&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;controller-run&#34;&gt;controller.Run&lt;/h5&gt;

&lt;p&gt;在 controller 对象的 Run 函数中我们发现，它创建了一个让我们非常熟悉的对象：Reflector。 这个类型为 Reflector 的对象之前在 API Server 中也被创建过:&lt;a href=&#34;http://littledriver.net/post/2018/11/21/detect-the-source-code-of-list-watch-between-api-server-and-etcd/#reflector-cache-reflector&#34;&gt;Detect the Source Code of List Watch Between API Server and Etcd - LittleDriver&lt;/a&gt;。它有两个比较重要的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;封装了 List/Watch 等方法在 listerWatcher 成员内部，用于后期调用获取资源对象的数据&lt;/li&gt;
&lt;li&gt;维护了一个缓存（以队列的形式实现），存储获取到的资源对象的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;controller.Run 函数在末尾调用了 Reflector 对象的 Run 函数， 其内部的核心逻辑就是调用listerWatcher 成员的 ListWatch 方法，开始等待接受资源对象的信息。这部分和 API Server 等待接收来自 ectd 的消息原理是一样的。&lt;/p&gt;

&lt;p&gt;除此之外，它还调用了一个名为&lt;code&gt;processLoop&lt;/code&gt;的函数。这个函数的工作也很简单：不断的从 Reflector对象维护的资源对象信息的缓存中取出消息进行处理。&lt;/p&gt;

&lt;h3 id=&#34;回到-controller-manager&#34;&gt;回到 Controller Manager&lt;/h3&gt;

&lt;p&gt;通过递归的观察 Controller Manager 的 Run 函数的逻辑，我们基本上可以确定下一阶段要关注的重点：informer 的创建者。因为这整段的逻辑看下来，最终通过&lt;code&gt;List-Watch&lt;/code&gt;机制获取资源对象信息的是 informer。而 informer 的创建逻辑并没有在&lt;code&gt;controllerContext.InformerFactory&lt;/code&gt;对象初始化的时候完成。那么也就是说，它是在之后的逻辑中对其内部的 informer 成员赋值的。&lt;/p&gt;

&lt;p&gt;再次查看&lt;code&gt;StartControllers&lt;/code&gt;的逻辑可知，持有&lt;code&gt;controllerContext.InformerFactory&lt;/code&gt;对象的&lt;code&gt;controllerContext&lt;/code&gt;，作为参数被传递到了每一个 Controller 的初始化函数。所以，看起来 informer 肯定是在各个 Controller 的逻辑中被赋值的。&lt;/p&gt;

&lt;h2 id=&#34;replicasetcontroller&#34;&gt;ReplicaSetController&lt;/h2&gt;

&lt;p&gt;ReplicaSetController 的初始化函数如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;startReplicaSetController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ControllerContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;AvailableResources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;schema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GroupVersionResource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;apps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;replicasets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;replicaset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewReplicaSetController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;InformerFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Apps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;V1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ReplicaSets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;InformerFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;V1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ClientBuilder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ClientOrDie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;replicaset-controller&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;replicaset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;BurstReplicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ComponentConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReplicaSetController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ConcurrentRSSyncs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看出在一开始调用 ReplicaSetController 的创建函数的时候，我们就传递进去了两个 Informer。选择&lt;code&gt;ReplicaSets&lt;/code&gt;函数跟进去发现，它返回是一个类型为&lt;code&gt;replicaSetInformer&lt;/code&gt;的对象。而&lt;code&gt;replicaSetInformer&lt;/code&gt;这个类实现了一个名为&lt;code&gt;Informer&lt;/code&gt;的方法，它返回的正式一个我们前面说到的&lt;code&gt;SharedIndexInformer&lt;/code&gt;类型的对象。我们之前要找的和各个 Controller 相关的 informer 对象也是&lt;code&gt;SharedIndexInformer&lt;/code&gt;类型。通过查看&lt;code&gt;Informer&lt;/code&gt;函数的逻辑，它一共涉及到以下三个函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// NewFilteredReplicaSetInformer constructs a new informer for ReplicaSet type.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Always prefer using an informer factory to get a shared informer instead of getting an independent
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// one. This reduces memory footprint and number of connections to the server.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewFilteredReplicaSetInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;kubernetes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;indexers&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Indexers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tweakListOptions&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;internalinterfaces&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TweakListOptionsFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SharedIndexInformer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewSharedIndexInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListWatch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;ListFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;metav1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tweakListOptions&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;nf&#34;&gt;tweakListOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AppsV1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ReplicaSets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;WatchFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;metav1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;watch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tweakListOptions&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;nf&#34;&gt;tweakListOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AppsV1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ReplicaSets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Watch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;appsv1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReplicaSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;indexers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;replicaSetInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;defaultInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;kubernetes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SharedIndexInformer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewFilteredReplicaSetInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Indexers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NamespaceIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MetaNamespaceIndexFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tweakListOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;replicaSetInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Informer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SharedIndexInformer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;InformerFor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;appsv1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReplicaSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;defaultInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;看起来，关键的部分大概有两个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;实际创建这个 Informer 对象的函数应该是&lt;code&gt;NewFilteredReplicaSetInformer&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;而&lt;code&gt;NewFilteredReplicaSetInformer&lt;/code&gt;方法作为参数传到了我们前面提到的&lt;code&gt;controllerContext.InformerFactory&lt;/code&gt;对象的&lt;code&gt;InformerFor&lt;/code&gt;方法中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最终，我们通过查看&lt;code&gt;InformerFor&lt;/code&gt;方法的逻辑可知，&lt;code&gt;NewFilteredReplicaSetInformer&lt;/code&gt; 最终在这里被调用，生成一个 informer 对象返回给外部。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// InternalInformerFor returns the SharedIndexInformer for obj using an internal
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// client.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sharedInformerFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;InformerFor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newFunc&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;internalinterfaces&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NewInformerFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SharedIndexInformer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;informerType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;TypeOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;informer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exists&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;informers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;informerType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exists&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;informer&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exists&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;customResync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;informerType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;exists&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;defaultResync&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;informer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;informers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;informerType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;informer&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;informer&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;而&lt;code&gt;Informer&lt;/code&gt;方法调用的位置是在ReplicaSetController 创建函数中：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/a3ccea9d8743f2ff82e41b6c2af6dc2c41dc7b10/pkg/controller/replicaset/replica_set.go#L141&#34;&gt;kubernetes/replica_set.go at a3ccea9d8743f2ff82e41b6c2af6dc2c41dc7b10 · kubernetes/kubernetes · GitHub&lt;/a&gt;。并且，同时还通过&lt;code&gt;informer&lt;/code&gt;对象向&lt;code&gt;controllerContext.InformerFactory&lt;/code&gt;注册了相应的 Handler 函数，以便之后处理接收到的资源对象的信息。&lt;/p&gt;

&lt;h2 id=&#34;链接-replicasetcontroller-和-controllercontext-informerfactory&#34;&gt;链接 ReplicaSetController 和 controllerContext.InformerFactory&lt;/h2&gt;

&lt;p&gt;之所以要看下 &lt;code&gt;ReplicaSetController&lt;/code&gt; 和&lt;code&gt;controllerContext.InformerFactory&lt;/code&gt;是如何建立链接开始交互的，是因为 ReplicaSetController 最终还是要靠之前提到的&lt;code&gt;Reflector&lt;/code&gt;对象调用 List/Watch方法从 API Server 接受资源对象的信息。而这个 &lt;code&gt;Reflector&lt;/code&gt;对象是被实现在&lt;code&gt;controllerContext.InformerFactory&lt;/code&gt;中的。&lt;/p&gt;

&lt;p&gt;返回上面提到&lt;code&gt;informer&lt;/code&gt; 对象调用&lt;code&gt;Run&lt;/code&gt;的地方，我们发现，&lt;code&gt;Reflector&lt;/code&gt;对象是借助了&lt;code&gt;informer&lt;/code&gt; 对象的&lt;code&gt;listWatcher&lt;/code&gt;成员创建的。而这个&lt;code&gt;listWatcher&lt;/code&gt;成员是在&lt;code&gt;informer&lt;/code&gt;对象被创建的时候就赋值进去了，赋值的位置就是&lt;code&gt;NewFilteredReplicaSetInformer&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;截止到目前为止，我们找到了资源对象信息的生产者:&lt;code&gt;Reflector&lt;/code&gt;，也找到了这些信息的消费者:&lt;code&gt;ReplicaSetController&lt;/code&gt;为其&lt;code&gt;informer&lt;/code&gt; 注册的处理函数。那么这个消息是如何从生产者送到消费者的呢？&lt;/p&gt;

&lt;p&gt;返回&lt;code&gt;Reflector&lt;/code&gt;对象被创建的位置：&lt;a href=&#34;https://github.com/kubernetes/client-go/blob/03bfb9bdcfe5482795b999f39ca3ed9ad42ce5bb/tools/cache/controller.go#L100&#34;&gt;client-go/controller.go at 03bfb9bdcfe5482795b999f39ca3ed9ad42ce5bb · kubernetes/client-go · GitHub&lt;/a&gt;。我们发现它除了执行生产消息塞入缓存的逻辑&lt;code&gt;wg.StartWithChannel(stopCh, r.Run)&lt;/code&gt;，还调用了一个名为&lt;code&gt;processLoop&lt;/code&gt;的函数。跟进去之后发现，该函数的功能是不断的从缓存中取出有效的内容（资源对象的信息）并通过一个函数&lt;code&gt;c.config.Process&lt;/code&gt;对其进行处理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;processLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;PopProcessFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;FIFOClosedError&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RetryOnError&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;c1&#34;&gt;// This is the safe way to re-enqueue.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddIfNotPresent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;函数&lt;code&gt;c.config.Process&lt;/code&gt;是在 informer 对象 Run 起来的时候被创建的，也就是上面提到的 controller 对象被创建的地方：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sharedIndexInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;utilruntime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HandleCrash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;fifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewDeltaFIFO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MetaNamespaceKeyFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;indexer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;cfg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;            &lt;span class=&#34;nx&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ListerWatcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listerWatcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ObjectType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;       &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;objectType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;FullResyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;resyncCheckPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;RetryOnError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ShouldResync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;processor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;shouldResync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HandleDeltas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;startedLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;startedLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controller&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cfg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;clock&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;clock&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;HandleDeltas&lt;/code&gt;便是函数&lt;code&gt;c.config.Process&lt;/code&gt;的实际值。接下来，我们可以跟进到&lt;code&gt;HandleDeltas&lt;/code&gt;函数的内部一探究竟：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sharedIndexInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HandleDeltas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;blockDeltas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;blockDeltas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// from oldest to newest
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Deltas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Added&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Updated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;isSync&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sync&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheMutationDetector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exists&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;indexer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exists&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;indexer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;processor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;distribute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;updateNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;oldObj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newObj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isSync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;indexer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;processor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;distribute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;addNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;newObj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isSync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Deleted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;indexer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;processor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;distribute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;deleteNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;oldObj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对于从缓存中取出的每一个 event（资源对象的信息），在&lt;code&gt;HandleDeltas&lt;/code&gt;中都会被判定eventType，然后交由&lt;code&gt;processor.distribute&lt;/code&gt;方法继续处理。而在&lt;code&gt;processor.distribute&lt;/code&gt;方法的内部，我们发现 event 最终给了 processor 的 listener 成员：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sharedProcessor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;distribute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listenersLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listenersLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RUnlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;syncingListeners&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listeners&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由于这个 Processor 对象是 informer 对象的一个内部成员，但是我在查找 ReplicaSet 的 informer 被创建的逻辑的时候并没有发现 Processor.Listeners 或 p.syncingListeners 被赋值。但是我找到了Processor 实现的一个名为 &lt;code&gt;addListener&lt;/code&gt;的方法。它看起来是专门为了添加 listener 成员给存在的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sharedProcessor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;processorListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listenersLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listenersLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;addListenerLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listenersStarted&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;查看该函数的调用位置可知，仅有一处，在&lt;code&gt;sharedIndexInformer&lt;/code&gt;类的&lt;code&gt;AddEventHandlerWithResyncPeriod&lt;/code&gt;方法中。看着这个函数名我觉得非常的熟悉，并且它又是属于&lt;code&gt;sharedIndexInformer&lt;/code&gt;类，很可能和 informer 对象有关。那也就是说，它可能和 ReplicaSetController 也有关系，毕竟 &lt;code&gt;informer&lt;/code&gt; 对象就是在 ReplicaSetController 的 New 函数中被创建的。&lt;/p&gt;

&lt;p&gt;此时，我返回ReplicaSetController的 New 函数。我发现它在创建了&lt;code&gt;informer&lt;/code&gt; 对象之后还执行了一个名为 AddHandler 的函数，将处理 event 的函数通过&lt;code&gt;informer&lt;/code&gt;对象向&lt;code&gt;controllerContext.InformerFactory&lt;/code&gt;注册了相应的 Handler 函数。跟进 AddHandler 这个函数之后我们发现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sharedIndexInformer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;AddEventHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ResourceEventHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddEventHandlerWithResyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;defaultEventHandlerResyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;果然，我们上面提到的处理 event 的 listener 就是 ReplicaSetController 注册的 Handler 函数。&lt;/p&gt;

&lt;h2 id=&#34;结束语&#34;&gt;结束语&lt;/h2&gt;

&lt;p&gt;至此，从 ControllerManager 到 API Server 之间通过 List-Watch 机制处理资源对象信息的过程也就梳理完成了。如果你此时返回到本文头部给出的 List-Watch 机制时序图，就可以发现，其实我们这整个一篇 blog，都在说 List-Watch-1这个虚线框内，标号为 0， 4的过程。而标号为2，3的两个过程，真是我们昨天讲的，API Server 和 ectd 交互的过程。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Detect the Source Code of List Watch Between API Server and Etcd</title>
      <link>http://littledriver.net/post/2018/11/21/detect-the-source-code-of-list-watch-between-api-server-and-etcd/</link>
      <pubDate>Wed, 21 Nov 2018 13:13:45 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/21/detect-the-source-code-of-list-watch-between-api-server-and-etcd/</guid>
      
        <description>

&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;在上一篇文章中，我们通过 Kubernetes 的架构图以及一个 Deployment 资源对象创建的过程大致了解了&lt;code&gt;List-Watch&lt;/code&gt;机制在一个 Kubernetes 集群中所起的作用以及它所面临的问题。本文我们将继续深入&lt;code&gt;List-Watch&lt;/code&gt;机制的实现原理，从源码的角度再次探索它其中的奥秘。&lt;/p&gt;

&lt;h2 id=&#34;list-watch-机制时序图&#34;&gt;List-Watch 机制时序图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/list1&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过上面的时序图我们可以看到，在 Controller 和 API Server 交互之前，API Server 和 Kubectl 以及 etcd 还有一段交互的过程。这个过程对于整个 List-Watch 机制是非常重要的，因为它是 List-Watch 机制对外提供的数据的生产过程。所以，本文将对这一过程做出详细的分析。&lt;/p&gt;

&lt;h2 id=&#34;api-server&#34;&gt;API Server&lt;/h2&gt;

&lt;p&gt;一个资源创建的起点是从 API Server 提供的 HTTP API 开始的。这里之所以没有提到时序图中的 kubelet 是因为，除了使用 kubelet，我们还可以通过 client-go 或者直接发送 HTTP 请求的方式给 API Server 来创建资源。既然&lt;code&gt;List-Watch&lt;/code&gt;机制中消息的发送端为 API Server，那么它肯定就提供了相应的 List 和 Watch 的 HTTP。API。通过观察 API Server 中注册 HTTP API 的代码逻辑：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/installer.go#L166&#34;&gt;apiserver/installer.go at master · kubernetes/apiserver · GitHub&lt;/a&gt;， 我们可以发现它通过「类型转换」构造了一个 Lister 对象还有一个 Watcher 对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// what verbs are supported by the storage, used to know what verbs we support per path
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;creater&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isCreater&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Creater&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;namedCreater&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isNamedCreater&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NamedCreater&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lister&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isLister&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Lister&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;getter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isGetter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Getter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;getterWithOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isGetterWithOptions&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GetterWithOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gracefulDeleter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isGracefulDeleter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GracefulDeleter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;collectionDeleter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isCollectionDeleter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;CollectionDeleter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;updater&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isUpdater&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Updater&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;patcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isPatcher&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Patcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;watcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isWatcher&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Watcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;connecter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isConnecter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Connecter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;storageMeta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isMetadata&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StorageMetadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;顺着 &lt;code&gt;registerResourceHandlers&lt;/code&gt;函数的逻辑往下看我们可以知道，无论是 Lister 还是 Watcher，都是通过一个叫做&lt;code&gt;restfulListResource&lt;/code&gt;的方法封装了一下暴露给外部使用的：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/installer.go#L610&#34;&gt;apiserver/installer.go at master · kubernetes/apiserver · GitHub&lt;/a&gt;。而通过进一步观察这个函数的&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/installer.go#L1022&#34;&gt;内部逻辑&lt;/a&gt;我们也可以看到，watcher 和 lister 最终在名为&lt;code&gt;ListResource&lt;/code&gt;的方法内执行其内部真正的逻辑。具体当一个 GET 请求过来调用的是 Watch 还是 List 接口，是通过请求当中的一个参数来确定的：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b8915a5609e4d7553d92f0d431ba04ecf9b52777/pkg/endpoints/handlers/get.go#L234&#34;&gt;apiserver/get.go at b8915a5609e4d7553d92f0d431ba04ecf9b52777 · kubernetes/apiserver · GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;假设目前的 HTTP 请求是 Watch。那么在&lt;code&gt;ListResource&lt;/code&gt; 的逻辑中就会走到&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b8915a5609e4d7553d92f0d431ba04ecf9b52777/pkg/endpoints/handlers/get.go#L249&#34;&gt;apiserver/get.go at b8915a5609e4d7553d92f0d431ba04ecf9b52777 · kubernetes/apiserver · GitHub&lt;/a&gt; 这一步。它调用 Watcher 的 Watch 方法，创建了一个&lt;code&gt;Watch-Interface&lt;/code&gt;类型的对象。然后将其传递至 &lt;code&gt;serveWatch&lt;/code&gt;方法：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/8a1312795085bced3bc5d4553b97c450a79fc420/pkg/endpoints/handlers/watch.go#L66&#34;&gt;apiserver/watch.go at 8a1312795085bced3bc5d4553b97c450a79fc420 · kubernetes/apiserver · GitHub&lt;/a&gt;。通过观察 &lt;code&gt;serveWatch&lt;/code&gt;方法的内部逻辑可知，之前创建的&lt;code&gt;Watch-Interface&lt;/code&gt;的对象被塞入了 ServeHTTP中，然后利用这个对象内部一个用于传递「资源对象信息的 channel」中的消息来对外部的「Watch」 请求提供服务：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/8a1312795085bced3bc5d4553b97c450a79fc420/pkg/endpoints/handlers/watch.go#L195&#34;&gt;apiserver/watch.go at 8a1312795085bced3bc5d4553b97c450a79fc420 · kubernetes/apiserver · GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;到目前为止，通过对 API Server 关于&lt;code&gt;List-Watch&lt;/code&gt; 机制的源码梳理，我们基本可以确定，API Server 获取资源对象信息的逻辑主要是实现于&lt;code&gt;Watch-Interface&lt;/code&gt;类型的对象以及向其内部的channel 传递消息的发送端。而在上面的描述中，我们还可以梳理出一条&lt;code&gt;Watch-Interface&lt;/code&gt;类型的对象的创建链路：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/s2&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;既然 Watcher 对象是通过 Storage 对象进行转换而来的，那么就说明&lt;code&gt;watch.Interface&lt;/code&gt;中的方法大概率也是在 Storage 类型的对象中实现的。在&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b8915a5609e4d7553d92f0d431ba04ecf9b52777/pkg/registry/generic/registry/store.go#L1159&#34;&gt;apiserver/store.go at b8915a5609e4d7553d92f0d431ba04ecf9b52777 · kubernetes/apiserver · GitHub&lt;/a&gt; 文件中，我们看到了 Storage类型实现了List 和 Watch 方法，继续递归的跟进下面的逻辑发现，最终，在名为&lt;code&gt;WatchPredicate&lt;/code&gt;的函数中，调用了名为 Storage 成员（与上面说的 Storage 类型的对象不是一个，它只是 struct 中其中一个 filed）的 Watch 方法，返回了类型为&lt;code&gt;watch.Interface&lt;/code&gt; 的对象：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b8915a5609e4d7553d92f0d431ba04ecf9b52777/pkg/registry/generic/registry/store.go#L1182&#34;&gt;apiserver/store.go at b8915a5609e4d7553d92f0d431ba04ecf9b52777 · kubernetes/apiserver · GitHub&lt;/a&gt;。而这个名为 Storage 成员的类型为&lt;code&gt;DryRunnableStorage&lt;/code&gt;。通过查看 &lt;code&gt;DryRunnableStorage&lt;/code&gt;这个类型的定义可知，其内部包含了一个类型为&lt;code&gt;storage.Interface&lt;/code&gt;的对象，该 Interface 内部涵盖了 Watch 和 List 方法，这两个方法应该会被具体的某个资源实现，如 Pod， Deployment 等。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;WARNING: 读者阅读到这里想必有点头晕，因为逻辑嵌套的层数太多，并且很多方法和成员的名字都是相同的。所以这里建议大家根据我贴出的源码的链接，按照 blog 中叙述的顺序画一个流程图，会看的更清楚。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;全局搜索一下创建&lt;code&gt;Store&lt;/code&gt;类型对象的地方可知，几乎存在于每一个资源的目录下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/s1&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们挑选 Deployment 资源对象的创建&lt;code&gt;Store&lt;/code&gt;类型对象的逻辑：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// NewREST returns a RESTStorage object that will work against deployments.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewREST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;optsGetter&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RESTOptionsGetter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;REST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusREST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RollbackREST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;genericregistry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;NewFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;                  &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extensions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;NewListFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;              &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extensions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;DeploymentList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;DefaultQualifiedResource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;extensions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;deployments&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;CreateStrategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;deployment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Strategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;UpdateStrategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;deployment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Strategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;DeleteStrategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;deployment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Strategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;TableConvertor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;printerstorage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TableConvertor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TablePrinter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;printers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewTablePrinter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;With&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;printersinternal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;AddHandlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)},&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StoreOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RESTOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;optsGetter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompleteWithOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// TODO: Propagate error up
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;statusStore&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;statusStore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UpdateStrategy&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;deployment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusStrategy&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;REST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;all&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}},&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusREST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statusStore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RollbackREST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看出在构造&lt;code&gt;genericregistry.Store&lt;/code&gt;对象的时候，没有有指定一个名为 Storage 的成员。在执行 return 语句之前仅仅只调用了一个&lt;code&gt;store.CompleteWithOptions&lt;/code&gt;方法。跟进去之后，豁然开朗：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b8915a5609e4d7553d92f0d431ba04ecf9b52777/pkg/registry/generic/registry/store.go#L1383&#34;&gt;apiserver/store.go at b8915a5609e4d7553d92f0d431ba04ecf9b52777 · kubernetes/apiserver · GitHub&lt;/a&gt;。名为 Storage 成员内部包含的类型为&lt;code&gt;storage.Interface&lt;/code&gt;的对象最终是被一个名为&lt;code&gt;Decorator&lt;/code&gt;的方法创建的。而这个方法和&lt;code&gt;opts&lt;/code&gt;这个变量有关。顺着这条线向上查找，我们最终发现，在 Deployment 代码逻辑中有一个名为 NewStorage 的函数：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/pkg/registry/apps/deployment/storage/storage.go#L56&#34;&gt;kubernetes/storage.go at master · kubernetes/kubernetes · GitHub&lt;/a&gt;。&lt;code&gt;opts&lt;/code&gt; 这个变量的值来自于这个函数的参数&lt;code&gt;optsGetter&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在向上寻找 opts 参数的过程中我们发现这条链路是比较长的，也是比较绕的，很难清晰的去定位到它第一次被创建的地方。所以，我们换一种思路：因为看到 opts 这个参数的类型为&lt;code&gt;generic.RESTOptionsGetter&lt;/code&gt;，所以我们在全局可以搜一下，哪里有对这个类型变量的赋值操作并且和 Storage 有关的。最后，我们定位到了这里：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/c53cd379d4b8e8acbe23a7a3b40c949687ba9926/pkg/server/options/etcd.go#L186&#34;&gt;apiserver/etcd.go at c53cd379d4b8e8acbe23a7a3b40c949687ba9926 · kubernetes/apiserver · GitHub&lt;/a&gt;。这是一段和 etcd 配置有关的逻辑。这段逻辑在 API Server 启动构造其使用的配置的逻辑中有调用过：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/b1a52a38e9e3651680655416cc7afbec5e119854/cmd/kube-apiserver/app/server.go#L424&#34;&gt;kubernetes/server.go at b1a52a38e9e3651680655416cc7afbec5e119854 · kubernetes/kubernetes · GitHub&lt;/a&gt;。&lt;code&gt;buildGenericConfig&lt;/code&gt;函数构造的通用配置，最终赋值给了启动 Master 节点所需要的配置集合：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/b1a52a38e9e3651680655416cc7afbec5e119854/cmd/kube-apiserver/app/server.go#L318&#34;&gt;kubernetes/server.go at b1a52a38e9e3651680655416cc7afbec5e119854 · kubernetes/kubernetes · GitHub&lt;/a&gt;。而这部分配置最终被用于创建 API Server： &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/b1a52a38e9e3651680655416cc7afbec5e119854/cmd/kube-apiserver/app/server.go#L175&#34;&gt;kubernetes/server.go at b1a52a38e9e3651680655416cc7afbec5e119854 · kubernetes/kubernetes · GitHub&lt;/a&gt;。在 &lt;code&gt;CreateKubeAPIServer&lt;/code&gt;函数内，我们可以看到，通过参数传递进来的 master.Config 最终调用了一个名为&lt;code&gt;Complete&lt;/code&gt;的函数处理了一下相关配置，并且通过它的返回值调用了一个 New 函数。而在 New 函数的内部，也通过调用一个名为&lt;code&gt;Install&lt;/code&gt;的函数，将&lt;code&gt;restOptionsGetter&lt;/code&gt;参数传了进去。&lt;/p&gt;

&lt;p&gt;此时，我们再次返回到Deployment 代码逻辑中的 NewStorage 函数被调用的地方：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/7f23a743e8c23ac6489340bbb34fa6f1d392db9d/pkg/registry/apps/rest/storage_apps.go#L60&#34;&gt;kubernetes/storage_apps.go at 7f23a743e8c23ac6489340bbb34fa6f1d392db9d · kubernetes/kubernetes · GitHub&lt;/a&gt;，随机选取一个版本的函数&lt;code&gt;v1beta1Storage&lt;/code&gt;，它在当前文件的一个名为&lt;code&gt;NewRestStorage&lt;/code&gt;函数中被调用：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/7f23a743e8c23ac6489340bbb34fa6f1d392db9d/pkg/registry/apps/rest/storage_apps.go#L38。随后，我们按照这条调用链路再继续向上寻找`restOptionsGetter`参数被赋值位置。随即定位到了[kubernetes/master.go&#34;&gt;https://github.com/kubernetes/kubernetes/blob/7f23a743e8c23ac6489340bbb34fa6f1d392db9d/pkg/registry/apps/rest/storage_apps.go#L38。随后，我们按照这条调用链路再继续向上寻找`restOptionsGetter`参数被赋值位置。随即定位到了[kubernetes/master.go&lt;/a&gt; at ec2e767e59395376fa191d7c56a74f53936b7653 · kubernetes/kubernetes · GitHub](&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/ec2e767e59395376fa191d7c56a74f53936b7653/pkg/master/master.go#L401)中的&#34;&gt;https://github.com/kubernetes/kubernetes/blob/ec2e767e59395376fa191d7c56a74f53936b7653/pkg/master/master.go#L401)中的&lt;/a&gt; &lt;code&gt;InstallAPIs&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;Bingo，此时我们可以将调用&lt;code&gt;InstallAPIs&lt;/code&gt;函数的逻辑作为桥梁，将我们上面整个的查找流程链接起来。所以，当前我们已经可以确认的是，我们之前说的&lt;code&gt;opts&lt;/code&gt;变量已经找到了出处。但实际上，在创建 Deployment storage 对象时，名为 Storage 成员内部包含的类型为&lt;code&gt;storage.Interface&lt;/code&gt;的对象最终是被一个名为&lt;code&gt;Decorator&lt;/code&gt;的方法创建的，这个&lt;code&gt;Decorator&lt;/code&gt;方法来自于&lt;code&gt;opts&lt;/code&gt;变量。再次查看&lt;code&gt;Decorator&lt;/code&gt;方法的定义可知，它被包含在一个 Interface 内部的函数的返回值中，而这个函数正是创建&lt;code&gt;opts&lt;/code&gt;这个变量所在的类必须要实现的：&lt;code&gt;GetRESTOptions&lt;/code&gt;。所以，我们需要再次回到和 etcd 配置有关的逻辑：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;EtcdOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ApplyWithStorageFactoryTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;factory&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serverstorage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StorageFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;addEtcdHealthEndpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RESTOptionsGetter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StorageFactoryRestOptionsFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StorageFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StorageFactoryRestOptionsFactory&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;EtcdOptions&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;StorageFactory&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serverstorage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StorageFactory&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StorageFactoryRestOptionsFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetRESTOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;resource&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;schema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GroupResource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RESTOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;storageConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StorageFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RESTOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Errorf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unable to find storage destination for %v, due to %v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RESTOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;StorageConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;           &lt;span class=&#34;nx&#34;&gt;storageConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Decorator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;               &lt;span class=&#34;nx&#34;&gt;generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UndecoratedStorage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;DeleteCollectionWorkers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;DeleteCollectionWorkers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;EnableGarbageCollection&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;EnableGarbageCollection&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ResourcePrefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StorageFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ResourcePrefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;CountMetricPollPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StorageConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;CountMetricPollPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;EnableWatchCache&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;sizes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ParseWatchCacheSizes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WatchCacheSizes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RESTOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;cacheSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sizes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;cacheSize&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;DefaultWatchCacheSize&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Decorator&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;genericregistry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;StorageWithCacher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到&lt;code&gt;GetRESTOptions&lt;/code&gt;最终被&lt;code&gt;StorageFactoryRestOptionsFactory&lt;/code&gt;类实现。查看&lt;code&gt;genericregistry.StorageWithCacher&lt;/code&gt;的定义，一路跟下去，就会发现，我们最终是创建了一个名为&lt;code&gt;cacher&lt;/code&gt;类型为&lt;code&gt;storage.Interface&lt;/code&gt;的变量，它将作为 Decorator 的值：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b8915a5609e4d7553d92f0d431ba04ecf9b52777/pkg/registry/generic/registry/storage_factory.go#L65&#34;&gt;apiserver/storage_factory.go at b8915a5609e4d7553d92f0d431ba04ecf9b52777 · kubernetes/apiserver · GitHub&lt;/a&gt;。如果再深入至&lt;code&gt;cacher&lt;/code&gt;创建的逻辑，可以看到，它是实现了&lt;code&gt;storage.Interface&lt;/code&gt;的全部接口的：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L160&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;还记得我们当时在阅读API Server中关于&lt;code&gt;ListResource&lt;/code&gt;方法的时候，发现最终通过 ServeHTTP 函数对外提供服务的是一个&lt;code&gt;storage.Interface&lt;/code&gt;类型对象调用了其 Watch 接口的返回值，即一个&lt;code&gt;Watch-Interface&lt;/code&gt;类型的对象。在&lt;code&gt;cacher&lt;/code&gt;的实现部分，我们同样可以找到一个这样的函数：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L292&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;，其内部将会为我们创建一个类型为&lt;code&gt;cacheWatcher&lt;/code&gt;的对象&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L794&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。这个对象内部有一个非常重要的成员：&lt;code&gt;result:    make(chan watch.Event, chanSize)&lt;/code&gt;，它是被一个名为&lt;code&gt;ResultChan&lt;/code&gt;的函数暴露给外部使用的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Implements watch.Interface.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheWatcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ResultChan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;watch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Event&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个函数相信你看到后会非常非常的熟悉，因为我们在ServeHTTP 函数中看到过它曾经被&lt;code&gt;watcher.Watch()&lt;/code&gt;的返回值调用：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/8a1312795085bced3bc5d4553b97c450a79fc420/pkg/endpoints/handlers/watch.go#L195&#34;&gt;apiserver/watch.go at 8a1312795085bced3bc5d4553b97c450a79fc420 · kubernetes/apiserver · GitHub&lt;/a&gt;。&lt;code&gt;newCacheWatcher&lt;/code&gt;除了返回一个&lt;code&gt;cacheWatcher&lt;/code&gt;类型的对象之外，还会启动一个goroutine, 执行一个名为&lt;code&gt;process&lt;/code&gt;的函数：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L923&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。当它从一个名为&lt;code&gt;input&lt;/code&gt;的 channel 中监听到有资源对象的信息发送过来的时候，就会通过&lt;code&gt;sendWatchCacheEvent&lt;/code&gt;函数，将最新的 event 通过刚才提到的 Result Channel 发送给客户端。并且由于客户端和 API Server 之间是一个长连接，所以这个循环会一直执行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果读者阅读过前一篇过于 List-Watch 机制原理性的文章就可以知道，List-Watch 机制会通过 ResourceVersion 来保证发送报文的顺序性。而这部分逻辑就是在 &lt;code&gt;process&lt;/code&gt;内实现的。如果当前客户端对 API Server 的 Watch 请求带来的 ResourceVersion 为1，那么 process 函数内的逻辑保证会返回给客户端一个序号大于1的报文。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是，截止到目前为止，我们只是看到了&lt;code&gt;cacheWatcher&lt;/code&gt;为每一个请求启动一个 goroutine 不断的监听资源对象信息的变化，如果有新的消息过来就返回给客户端。那么这个变化的消息是谁向&lt;code&gt;input&lt;/code&gt;channel 传递过来的呢？回头看下 cacher 的数据结构：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L141&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;，我们发现有如下几个成员是值得注意的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// Underlying storage.Interface.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Interface&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// &amp;#34;sliding window&amp;#34; of recent changes of objects and the current state.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;watchCache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;watchCache&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;reflector&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Reflector&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;storage-storage-interface-资源对象数据真正的来源&#34;&gt;storage storage.Interface（资源对象数据真正的来源）&lt;/h3&gt;

&lt;p&gt;storage 成员是在创建 Cacher 的时候就被传递进来了。根据这个顺序向回查找，查看&lt;code&gt;genericregistry.StorageWithCacher&lt;/code&gt;的定义&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b8915a5609e4d7553d92f0d431ba04ecf9b52777/pkg/registry/generic/registry/storage_factory.go#L44&#34;&gt;apiserver/storage_factory.go at b8915a5609e4d7553d92f0d431ba04ecf9b52777 · kubernetes/apiserver · GitHub&lt;/a&gt;，可知 storage 是通过 &lt;code&gt;NewRawStorage&lt;/code&gt;创建的。一路跟下去后。我们最后到了创建 etcdStorage 的函数里：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.12/staging/src/k8s.io/apiserver/pkg/storage/etcd/etcd_helper.go#L65&#34;&gt;kubernetes/etcd_helper.go at release-1.12 · kubernetes/kubernetes · GitHub&lt;/a&gt;。此时，你可以看下 &lt;code&gt;NewEtcdStorage&lt;/code&gt;的返回值还有&lt;code&gt;etcdHelper&lt;/code&gt;类实现的的 List 和 Watch 方法，就可以明白，整个 ListWatch 机制中，API Server 从 etcd 获取资源对象信息所使用的 Watch 和 List 方法就是在这里真正的被实现。而这也符合我们之前看的 Kubernetes 的架构图中的一个细节：API Server 对外提供的一切信息都是从 etcd 而来的。如果你进入 etcd 实现的 Watch 方法中，稍微扫一眼就可以看到，它核心的逻辑就是启动一个死循环，不断的等待从 etcd 而来的有关资源对象的信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;resp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;watcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;etcdError&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;etcdIncoming&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resp&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;除此之外，&lt;code&gt;etcdHelper&lt;/code&gt;类还实现了很多和 etcd 相关的方法。那么我们姑且可以认为，storage 成员是操作 etcd 的一个封装。&lt;/p&gt;

&lt;h3 id=&#34;watchcache-watchcache-资源对象信息的缓存&#34;&gt;watchCache *watchCache（资源对象信息的缓存）&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b080aefffce393d0aa75a2d3c62442b5515c8963/pkg/storage/cacher/watch_cache.go#L147&#34;&gt;apiserver/watch_cache.go at b080aefffce393d0aa75a2d3c62442b5515c8963 · kubernetes/apiserver · GitHub&lt;/a&gt; 通过观察 watchCache 和数据结构以及它实现的方法，我猜测它应该是实现了一个资源对象信息的缓存。将通过和 etcd 通信而获取到的资源对象的信息缓存在内存中。当资源对象长时间未发生变化的时候，如果再有 List 或者 Watch 请求该资源对象的信息，可以直接返回给它缓存中的内容，而不再去和 etcd 通信。&lt;/p&gt;

&lt;h3 id=&#34;reflector-cache-reflector&#34;&gt;reflector  *cache.Reflector&lt;/h3&gt;

&lt;p&gt;reflector 的创建一共需要两个重要的对象作为参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;listerWatcher&lt;/li&gt;
&lt;li&gt;watchCache&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中 watchCache 我们上面已经提到过，那 listerWatcher 是什么呢？在 cacher.go 文件中可以找到创建这个对象的方法的定义：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L719&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。浏览一下它实现的方法集合可知，它其实就是对上面我们说到的 storage 对象的一个封装。实际上调用的还是 storage 内实现的一些方法。&lt;/p&gt;

&lt;p&gt;通过观察 Cacher 数据结构中几个比较重要的成员的逻辑，我们现在确定了资源对象真正的数据来源，也了解了catchWatcher 启动了一个goroutine 运行死循环等待着从&lt;code&gt;input&lt;/code&gt;channel 发来的资源对象的信息。目前唯一缺少的就是数据生产者是如何将数据传递到&lt;code&gt;input&lt;/code&gt;这个 channel 中的。&lt;/p&gt;

&lt;p&gt;在创建了 Cacher 对象时候，我们紧接着运行了一个名为&lt;code&gt;StartCaching&lt;/code&gt; 的方法：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L248&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。在它的逻辑内部，我们调用了 reflector 的 ListWatch 方法&lt;a href=&#34;https://github.com/kubernetes/client-go/blob/ee7a1ba5cdf1292b67a1fdf1fa28f90d2a7b0084/tools/cache/reflector.go#L168&#34;&gt;client-go/reflector.go at ee7a1ba5cdf1292b67a1fdf1fa28f90d2a7b0084 · kubernetes/client-go · GitHub&lt;/a&gt;。在这个方法中，它先通过 listerWatcher 封装的 List 方法全量的获取了一下 Kubernetes 集群中的资源，然后起了一个死循环，调用了 ListerWatcher 封装的 Watch 方法，然后在 watchHandler 方法中，通过访问一个阻塞的 channel，等待资源对象信息从 etcd 发过来。如果此时确实接收到了一个资源对象的信息，它会调用 watchCache.Add 方法，将其塞入缓存中：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b080aefffce393d0aa75a2d3c62442b5515c8963/pkg/storage/cacher/watch_cache.go#L170&#34;&gt;apiserver/watch_cache.go at b080aefffce393d0aa75a2d3c62442b5515c8963 · kubernetes/apiserver · GitHub&lt;/a&gt;。在 Add 的函数的逻辑中，会继续调用 &lt;code&gt;processEvent&lt;/code&gt;函数，在其内部我们发现，除了正常的更新 watchCache 的缓存之外，还执行了行逻辑：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/b080aefffce393d0aa75a2d3c62442b5515c8963/pkg/storage/cacher/watch_cache.go#L257&#34;&gt;apiserver/watch_cache.go at b080aefffce393d0aa75a2d3c62442b5515c8963 · kubernetes/apiserver · GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;那么这个 onEvent 函数究竟是什么呢？返回 watchCache 被创建的逻辑的位置会发现，watchCache.onEvent 是被cacher.processEvent 赋值的。cacher.processEvent 函数的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Cacher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;processEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;watchCacheEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;curLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;incoming&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;incomingHWM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;curLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// Monitor if this gets backed up, and how much.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;glog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Infof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;cacher (%v): %v objects queued in incoming channel.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;objectType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;curLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;incoming&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;event&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;再结合对比一下 watchCache.Add 函数的逻辑可知，从 etcd 发来的 event 将会通过 processEvent 函数传递至&lt;code&gt;incoming&lt;/code&gt; 这个 channel。而 &lt;code&gt;incoming&lt;/code&gt; 这个 channel 是在 cacher 对象的dispatchEvents 函数内被读取的：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L603&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。跟着这个数据流动的逻辑继续向下，我们发现这个 event 最终作为参数传递到了之前我们创建的&lt;code&gt;watcher&lt;/code&gt;的 Add 方法内：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L624&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。进入这个 Add 函数的内部，你会发现一下子豁然开朗，因为这个 event 事件经过漫长的流程终于传递到了&lt;code&gt;input&lt;/code&gt;channel: &lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L854&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。而上面这些 watcher 是怎么被收集进来的呢？通过 cacher 中 Watch 方法的逻辑可以发现，它来自于对 Watch 方法的调用：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/cf5eff4f5e8f6019796cb18c69918b9f2f09e6db/pkg/storage/cacher/cacher.go#L343&#34;&gt;apiserver/cacher.go at cf5eff4f5e8f6019796cb18c69918b9f2f09e6db · kubernetes/apiserver · GitHub&lt;/a&gt;。而这个方法，正是在我们前面说到的，API Server 在响应 Watch/List 相关的 HTTP 请求的时候，生成类型为&lt;code&gt;watch.Interface&lt;/code&gt;且名为&lt;code&gt;catcherWatcher&lt;/code&gt;对象时调用的。&lt;/p&gt;

&lt;p&gt;至此，整个&lt;code&gt;List-Watch&lt;/code&gt;机制中，资源对象的数据从 etcd 到 API Server HTTP API 之间的数据流动过程就都走通了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Say Love to Pouch</title>
      <link>http://littledriver.net/post/2018/11/21/say-love-to-pouch/</link>
      <pubDate>Wed, 21 Nov 2018 01:57:23 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/21/say-love-to-pouch/</guid>
      
        <description>

&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;在当今的计算机行业中，对于一个想要精进技术的程序员来说，可供他选择提升自己技术实力的方式有很多种：看一本技术书籍，写一篇技术博客，甚至是做一场有价值的技术分享。但是，在程序员的圈子里时常流行着这样一句话：Talk is cheap， Show me code。的确，对于计算机这种工程性较强的学科，实践是非常重要的。衡量一个好的工程师的标准并不是看他背熟了多少个知识点，而是看他能否运用自己所学的知识真正的解决一些问题。所以，在众多的「提升方式」中，参与开源项目是一个较好的选择。从我的角度来看，通过参与开源项目来提升自己，有以下几个好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;开拓你的视野：你的编码内容将不再局限于你的工作。在 Github 或 Gitlab 等网站上，你可以跟随自己的兴趣找到一些有趣的项目进行参与。这将拓宽你的技术视野。&lt;/li&gt;
&lt;li&gt;增强你的沟通：参与同一个开源项目的开发者，可能来自于不同的公司，也可能来源于不同的国家。复杂的工作环境会让你逐渐的意识到「合作」和「沟通」对一个项目健康成长的重要性。&lt;/li&gt;
&lt;li&gt;扩大自己的影响力：通过对开源项目持续的贡献会快速的在技术社区扩大你的影响力，尤其是对于一些平时不善表达的程序员来说，这是一种更加有效的展示自己的方式。随着时间的推移，在你不断的向开源项目贡献的同时，它同时也会反哺与你。小到一个「点赞的表情」，大到一份令人羡慕的工作机会。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;我与-pouch-邂逅&#34;&gt;我与 Pouch 邂逅&lt;/h2&gt;

&lt;p&gt;作为一名在 2017 年年底才开始接触 Kubernetes 和 Docker 生态的开发者来说，眼前的很多东西都是令我感觉比较陌生的。从2018年1月份到10月份，我专注于在 Kubernetes 平台上开发高可靠的 Redis 数据库应用。在这期间，我积累了大量在 Kubernetes 平台上做二次开发的经验。尤其是对服务「自运维」能力的开发上，我有了很多自己的心得。于是，我不再满足于只在工作上贡献我的力量，转而把眼光投向了开源社区。我希望能用我积累到的工程经验和一些优秀的开源项目共同成长。&lt;/p&gt;

&lt;p&gt;偶然的一次机会，我参与了阿里组织的一场和容器相关的技术分享。那场分享中有两个主题令我印象深刻，一个是关于「阿里改造 Kubernetes 的 Ingress 组件实现服务灰度发布」，另外一个就是阿里推出的一个新的容器运行时项目叫 Pouch。当时的我非常的兴奋，因为我觉得我做的 Redis APP 和他们做的东西很贴近，他们讲的东西我不仅能够听懂还可以提出一些问题进行深入的交流。尤其是 Pouch 项目当时提出的「富容器」的概念，我觉得很多地方和我开发当中所用的 BaseImage 的原理是非常相似的。至今，我还保留着当时提问题的记录：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/277A1DB2-0BFC-42F8-98C0-910A24094F2D.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;我与-pouch-的初恋&#34;&gt;我与 Pouch 的初恋&lt;/h2&gt;

&lt;p&gt;那次分享之后，说实话我并没有太在意 Pouch 这个项目。总觉得既然是做 Kubernetes 相关的开发，还是要尽力去参与到 Kubernetes 的主项目中。所以，我花费了大量的时间来学习 Kubernetes 中各种核心组件的实现原理。慢慢的我发现，虽然我掌握了很多 Kubernetes 核心组件的原理知识，但是由于 Kubernetes 项目的愈发成熟，留给初入容器和服务编排生态的开发者的机会实在是太少了。我的参与感和热情也变得越来越少。&lt;/p&gt;

&lt;p&gt;由于关注了一些和技术相关的公众号，Pouch 频繁的出现在我的眼前。加之之前的一些事情，我便开始关注这个项目。当时对它的了解有以下几个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;阿里目前主推的一个和容器有关的基础设施项目，并且在公司内部有大范围的应用&lt;/li&gt;
&lt;li&gt;开源的版本和内部使用的版本几乎没有太大的差别&lt;/li&gt;
&lt;li&gt;这个项目的 Sponsor 是 Docker Top 5 的代码贡献者&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过一段时间的了解之后，我觉得它是一个很靠谱并且值得花时间去贡献的项目。最主要的原因就是贡献进去的代码是真正可以在阿里这种量级的业务下得到验证的。你的代码能够为数以千计和万计的业务提供基础服务，我想这足以是一个让很多程序员都为之兴奋的事情。所以，在今年的10月26日，我向 Pouch 提交了我的第一个 Pull Request&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/8A09C30E-504A-4C90-BD18-94BD5F57E3CC.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;我与-pouch-的热恋&#34;&gt;我与 Pouch 的热恋&lt;/h2&gt;

&lt;p&gt;Pouch 是一个不断在给我惊喜的开源项目。在我的第一个 Pull Request 被 Merge 之后。Pouch 项目的 Member 居然主动通过邮件联系了我，并把我拉到了这个开源项目的讨论组中。在向大家自我介绍的过程中，我觉得我就是 Pouch 这个项目的一员了。良好的社区氛围让我非常的有归属感。&lt;/p&gt;

&lt;p&gt;在接下来的一个月当中，我和朋友一起开始向 Pouch 这个项目投入一定的精力。因为之前参与过 Kubernetes 项目的缘故，所以我觉得很多开源项目的社区维护的都是不如 Kubernetes 的。但是 Pouch 给我的感觉不一样，它虽然规模比较小，但是流程比较正规。项目中的 Member 和 Maintainer 对 Issue 和 Pull Request 的响应也非常的及时，经常会为了一个小问题在 Pull Request 的 Comment 中和开发者耐心的交流。尤其是大家对于 Code Review 的态度，是让我非常开心的。因为我感觉我在和一帮真正想把代码写好的人一起做一些有趣的事情。&lt;/p&gt;

&lt;p&gt;所以，在之后的一段时间内，我开始在 Pouch 中尝试更多的工作：Review 其他开发者的代码，利用 Issue 提出一些项目中存在的问题和大家一起交流，积极参与到社区内一些需要开发者帮助解决的问题中。这期间令我最有成就感的事就是，我把之前在工作当中总结的关于「如何以更标准的姿势使用 go-grpc-prometheus 项目为服务添加监控」的工程经验通过代码的形式成功的贡献给了 Pouch，并得到大家的认可。&lt;/p&gt;

&lt;h2 id=&#34;我对-pouch-的期许&#34;&gt;我对 Pouch 的期许&lt;/h2&gt;

&lt;p&gt;从我的角度来讲，Pouch 开源社区的维护和运营是非常好的，这一点必须要再次肯定一下。项目中的核心开发人员通过各种方式拉近了与社区开发者的距离并且消除了人与人之间的陌生感。社区开发者一直是一个开源项目最宝贵的资源之一，我之所以决定在 Pouch 投入大量的精力，一部分是因为文章开头提到的几个参与开源项目的好处。另外一个就是受益于 Pouch 社区良好的氛围。&lt;/p&gt;

&lt;p&gt;Pouch 是一个很年轻的开源项目，这意味着它对广大的开发者来说是一块值得开垦的「荒地」，有太多重要且有趣的事情可以去做。但是我想 Pouch 社区的成员必须要考虑到的一点就是：当 Pouch 这个项目发展了一段时间之后，很可能外围（主要指和核心逻辑无关的）的一些功能会被开发者逐渐的实现完备。此时，无论是对于新进的开发者还是想继续做进一步贡献的开发者，了解 Pouch 项目需要的核心的技术知识就变得愈发重要了。不然，能够参与到核心逻辑开发的人仍旧是少数，这对一个开源项目的健康发展是没有好处的。借鉴 Kubernetes 的项目的经验，再结合我自己的一些感受，希望 Pouch 开源社区在以后的日子里可以多加强一下几方面的工作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对 Pouch 项目核心组件的实现能够给出技术设计文档或架构文档，帮助开发者更有效的了解 Pouch。这对于想从源码级别来了解 Pouch 项目的开发者来说是一个非常好的事情。&lt;/li&gt;
&lt;li&gt;给出一些 Pouch 中核心组件用到的技术的一些相关资料。让初学者参与进来的之前可以通过对这些知识的了解为后面的贡献做一个好的铺垫，缩短他们向 Pouch 贡献的距离。&lt;/li&gt;
&lt;li&gt;定期为核心的开发者开一些线上或者线下的会议，同步一下整个 Pouch 项目接下来的发展方向和发展重心。让大家的贡献做到有的放矢。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;

&lt;p&gt;能被 Pouch 项目的发起者邀请来写这篇文章我是感觉到非常荣幸的。Pouch 这个项目也是目前我除了 go-grpc-prometheus 之外参与度最高的一个开源项目。希望能够在以后日子里和其他的开发者一起为 Pouch 多做贡献，同时也希望有越来越多的人参与到 Pouch 中，和我们一起做有趣的事情。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Detect the mechanism of list-watch in Kubernetes</title>
      <link>http://littledriver.net/post/2018/11/19/detect-the-mechanism-of-list-watch-in-kubernetes/</link>
      <pubDate>Mon, 19 Nov 2018 23:51:51 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/19/detect-the-mechanism-of-list-watch-in-kubernetes/</guid>
      
        <description>

&lt;h2 id=&#34;先来看一个小例子&#34;&gt;先来看一个小例子&lt;/h2&gt;

&lt;p&gt;一个 Kubernetes 的集群的架构通常如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/EAE14BFE-CD40-444E-A2E6-FBE8178F2F8E.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当一个用户通过&lt;code&gt;kubectl&lt;/code&gt;命令行想要创建一个 Pod 数量为3的 Deployment 的资源对象的时候。此请求会先通过 HTTP 协议发送到 API Server。随后，API Server 会将此资源对象的相关信息持久化至 etcd 中。紧接着，ControllerManager 中负责管理  Deployment 的 Controller 将会通过&lt;code&gt;List-Watch&lt;/code&gt; 机制感知到目前有一个 Deployment 的资源需要被创建，它会通过一段逻辑来处理这个「新增」的资源：创建一个 ReplicaSet。ReplicaSet 资源的创建请求在 Kubernetes 中被处理的方式和 Deployment 是一样的。最终，在 ReplicaSet Controller 中将会创建符合用户预期数量的 Pod。而 Pod 被创建的行为将会被 Scheduler 通过&lt;code&gt;List-Watch&lt;/code&gt; 感知到。在通过一定的调度策略选取好 Pod 要调度的 Node 之后，Kubelet 也将通过 &lt;code&gt;ListWatch&lt;/code&gt;机制感知到这一结果。最终，Kubelet 将会在相应的 Node 上为 Pod 创建符合预期数量的容器，并且把 Pod 最新的状态通过 API Server 写回至 etcd。&lt;/p&gt;

&lt;p&gt;在了解了一个 Deployment 资源被创建的过程之后，再对比上面 k8s 的架构图。我们可以知道，粉色线标识的，基本就是&lt;code&gt;List-Watch&lt;/code&gt; 机制传递消息的过程。&lt;/p&gt;

&lt;h2 id=&#34;对上述例子的思考&#34;&gt;对上述例子的思考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;细心观察一下就会发现，整个 Kubernetes 集群中各个组件执行一些逻辑的依据都来源于&lt;code&gt;List-Watch&lt;/code&gt;机制传递过来的资源对象的信息。而这些信息基本上都存放在 etcd 中，依靠 API Server 所暴露的 HTTP 接口对外提供。&lt;/li&gt;
&lt;li&gt;整个 Kubernetes 集群中的组件除了 etcd 之外均为无状态服务。这就预示着除了 etcd 之外，其他服务如果因为故障或者升级等出现短暂断开是完全不影响整个集群的正常工作的。&lt;/li&gt;
&lt;li&gt;Kubernetes 的设计理念决定了它的各种行为依赖的是具体资源对象的状态信息，而不是某个用户传递至 API Server 的命令。&lt;/li&gt;
&lt;li&gt;Kubernetes 作为一个由多个组件联合构成的一个分布式系统，对一致性的要求是「最终一致」。因为和资源对象相关的信息在不断被获取的同时也在不断被修改。整个过程中可能要有一些非预期的行为，但是只要某个操作的结果最终是正确的，对于 Kubernetes 来说就是可以接受的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;kubernetes-的架构以及核心组件的职责&#34;&gt;Kubernetes 的架构以及核心组件的职责&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/E1D0F39B-0909-4E43-B78D-4604269036E3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;etcd：集群中唯一有状态的服务，负责存储资源对象的信息&lt;/li&gt;
&lt;li&gt;API Server：集群资源的访问入口。任何对资源对象的操作（内置，自定义）都需要通过它暴露出来的HTTP 接口&lt;/li&gt;
&lt;li&gt;Scheduler：集群的调度器。通过一定的调度策略，为 Pod 选取符合条件的调度机器并将其调度到相应的机器上&lt;/li&gt;
&lt;li&gt;Controller Manager： 集群资源控制器的集合。其内部包含了多个处理不同类型资源的 Controller。它们负责通过一定的逻辑将各个资源对象维护至用户期望的状态（desire state）。&lt;/li&gt;
&lt;li&gt;Kubelet：集群中各节点的守护进程。负责管理其 Node 上对应的 Container 的生命周期&lt;/li&gt;
&lt;li&gt;Container Runtime：集群底层依赖的容器运行时。负责管理容器镜像以及容器的运行&lt;/li&gt;
&lt;li&gt;Kube-proxy：  负责管理集群内部的服务发现和负载均衡，给各个服务提供网络通信层面的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;什么是-list-watch&#34;&gt;什么是 List-Watch？&lt;/h2&gt;

&lt;p&gt;List-Watch 准确的说是 Kubernetes 集群内部的一种「异步消息传递机制」。任何集群内部资源对象的状态变化，都将通过这种机制传递给关心它的组件。如上面描述的关于创建 Deployment 资源对象的过程，scheduler，kubelet，controller 等组件都会通过 List-Watch 机制来监听整个创建过程中的变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/listwatch.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;一个好的-list-watch-机制需要解决哪些问题&#34;&gt;一个好的 List-Watch 机制需要解决哪些问题？&lt;/h2&gt;

&lt;p&gt;一个好的「异步消息传递机制」，应该保证如下几个关键的性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;实时性：尤其是对于 Kubernetes 来说，集群中的各项操作都依赖于「资源对象的消息」。所以消息传递的实时性就显得尤为重要&lt;/li&gt;
&lt;li&gt;顺序性：同一个资源对象的操作，很多时候都是互斥的且要遵守一定的顺序执行的。如 Pod 的删除和创建操作，明显不能先响应删除，再响应创建&lt;/li&gt;
&lt;li&gt;可靠性：一旦某个组件在接收到「消息 」之后发生故障进行重启，那么这个消息需要按照一定的机制重传&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;如何保证高实时性&#34;&gt;如何保证高实时性？&lt;/h3&gt;

&lt;p&gt;既然信息是通过 API Server 向外输出的，那么想更加实时的获取这部分信息就得减少除了真正通讯之外的操作的消耗。对于网络通信而言，我们很容易就想到一个办法：尽量减少链接的创建和销毁操作，保持一个长连接，一直等待着服务端数据。所以，在 Kubernetes 1.7 版本之后，使用 HTTP Streaming 协议与 API Server 建立链接，不断等待从 API Server 到来的数据。&lt;/p&gt;

&lt;h3 id=&#34;如何保证顺序性&#34;&gt;如何保证顺序性？&lt;/h3&gt;

&lt;p&gt;在分布式系统中，若想保证某一个操作或者资源的顺序性，最常见的办法就是加入「版本号」机制。即给那些需要保证顺序的资源添加一个 Version 字段。Version 从小到大依次递增，每当这个资源的信息被更新时，它的 Version 也就相应的+1。通常，一个系统中对于同一个资源可能有多个不同的版本。当目的组件想要 Watch 一个资源对象的信息的时候，可以带上之前本地缓存的资源对象的版本号。API Server 会按照递增的顺序进行传递。默认这个版本号从0开始递增。&lt;/p&gt;

&lt;p&gt;在 Kubernetes 中，这个 Version 字段加在了资源对象的 meta 信息部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// An opaque value that represents the internal version of this object that can
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// be used by clients to determine when objects have changed. May be used for optimistic
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// concurrency, change detection, and the watch operation on a resource or set of resources.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Clients must treat these values as opaque and passed unmodified back to the server.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// They may only be valid for a particular resource or set of resources.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Populated by the system.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Read-only.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Value must be treated as opaque by clients and .
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// +optional
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;ResourceVersion&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;resourceVersion,omitempty&amp;#34; protobuf:&amp;#34;bytes,6,opt,name=resourceVersion&amp;#34;`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种「版本号机制」的正常运行，依赖于更新版本号的操作必须是原子的。而这部分操作应该由 etcd 来保证。&lt;/p&gt;

&lt;h4 id=&#34;关于顺序性的一点小思考&#34;&gt;关于顺序性的一点小思考&lt;/h4&gt;

&lt;p&gt;通过对「实时性」的了解，我们知道，在目的组件和 api server 之间是有一条长链接用于传输资源对象信息的。虽然我们通过 ResourceVersion 可以保证  API Server 向目的组件发送的消息是按照递增顺序的。但其实对于目的组件而言，我们貌似是无法保证消息的到达顺序的。并且，在我观察了 client-go 中关于&lt;code&gt;List-Watch&lt;/code&gt; 机制的代码逻辑之后，我发现 client-go 对于向缓存中更新这个最新的 ResourceVersion 之前并没有将新旧 Version 进行对比。那么，这里就有一个隐含的风险：长链接中有 1，2两个资源按照递增的顺序发出。但是当到达目的组件的时候，2先到达，1后到达。当这种情况发生的时候，ResourceVersion 是不是就有可能被错误的更新呢？&lt;/p&gt;

&lt;p&gt;逆向的想一下这个问题， k8s 的实现者肯定是考虑到了并且解决了这个问题。那我们也来思考一下：&lt;/p&gt;

&lt;p&gt;目前看来，API Server 只能保证发送消息的顺序，而目的组件在处理消息的时候又没有对新旧 ResourceVersion 做对比。那么处理上述所说风险的唯一可行的位置就是中间的通信链路。由于 HTTP Streaming 在传输层依赖的是 TCP 协议。而 TCP 协议本身就保证的报文传递的顺序性：发送方会按照报文的顺序等待相应的 ACK 报文，否则会启动超时重传机制。而接收方也会将接收到的报文先存于缓冲区中，按顺序进行消费。如果发现接下来要消费的报文没有按顺序到达，可能会启用快重传机制，不断的给发送方发送上一个顺序到达报文的 ACK 报文。所以，我们之前假想的问题是不存在的。&lt;/p&gt;

&lt;h3 id=&#34;如何保证可靠性&#34;&gt;如何保证可靠性？&lt;/h3&gt;

&lt;p&gt;Kubernetes 不但提供了持续 Watch 资源对象信息这种增量获取的机制，还提供了一种 List 操作，即一次性获取集群中所有的符合条件的资源对象信息。这样一来，当目的组件第一次启动或者重启，甚至是 Watch 操作出错的时候，可以通过 List 操作统一的获取集群中相关的资源对象，刷新掉可能已经被污染的数据。&lt;/p&gt;

&lt;h2 id=&#34;现有的-list-watch-机制有哪些弊端&#34;&gt;现有的 List-Watch 机制有哪些弊端？&lt;/h2&gt;

&lt;p&gt;通过对 List-Watch 机制实现「消息传递的可靠性」的思路可知，当发生异常情况或客户端重启的时候，会调用 List 接口对 Kubernetes 集群内部所有的资源对象都扫描一次。这个操作是比较昂贵的，尤其是当集群内资源对象的数量达到一定量级的时候。所以，我们应当在日常的开发中尽量减少触发 List 接口。&lt;/p&gt;

&lt;h2 id=&#34;关于-list-watch-机制中长连接的一点思考&#34;&gt;关于 List-Watch 机制中长连接的一点思考&lt;/h2&gt;

&lt;p&gt;在 HTTP 1.1 版本中，每一个长连接都会占用一个单独的 TCP 链接。所以，当这个长连接断掉的时候，客户端和服务端是感知不到的。仅仅只是发现长时间没有数据。如果此时 TCP 打开了 keep-alive 功能，那么客户端或者服务端会间隔一定的时间向对方发送 keep-alive 报文来检测链接是否正常。如果对方多次都没有返回一个 ACK 报文的话，发送端会主动断开这个链接，并且重新建立一个新的链接。&lt;/p&gt;

&lt;p&gt;在 HTTP2.0版本中，多个 HTTP 链接会共用一个 TCP 链接。这个链接上可能无时不刻都有数据在传递。此时，keep-alive 功能就不起作用了。但是，在连接异常的情况下，发送端（可能是客户端也可能是服务端）发送的报文可能一直得不到接收端的 ACK 报文。这就会持续引发发送端的「超时重传」机制。由于链接断开，即使发生重传也依然会失败。最终，发送端会因为达到最大的超时重传次数而重置掉当前的 TCP 链接。&lt;/p&gt;

&lt;p&gt;List-Watch 机制为了减少链接创建和销毁的开销，使用了 HTTP Streaming 协议。客户端是不能确定一个准确的关闭连接的时间点的，因为它也不知道什么时候服务端会有数据过来。所以，关闭连接的任务一般都由服务端来发起。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Head First CGroup</title>
      <link>http://littledriver.net/post/2018/11/17/head-first-cgroup/</link>
      <pubDate>Sat, 17 Nov 2018 17:17:44 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/17/head-first-cgroup/</guid>
      
        <description>

&lt;h1 id=&#34;docker-的资源隔离机制-cgroup&#34;&gt;Docker 的资源隔离机制——CGroup&lt;/h1&gt;

&lt;h2 id=&#34;为什么需要-cgroup&#34;&gt;为什么需要 CGroup&lt;/h2&gt;

&lt;p&gt;Linux Namespace 为容器（进程）提供了环境上的隔离，它的行为类似 chroot 这个命令，将某个用户jail 到一个特定的环境下，与外界隔离。但是在之前介绍 Namespace 的文章中我们也提到过，虽然 Namespace 提供的隔离机制有很多，但实际上我们操作的一些资源仍然是全局的，并且基本上是没有什么限制的，如：内存，CPU，硬盘等。一些在已经「隔离」了的进程中做的操作还是会影响到其他进程的。&lt;/p&gt;

&lt;p&gt;所以，Linux 在内核中以文件系统的形式为我们实现了一种资源隔离的机制：Linux CGroup，位于 /sys/fs/cgroup 目录 。它用来限制，控制一个进程群组的资源。工作方式类似于：先对计算机的某个资源设置了一些限制规则，如只能使用 CPU 的20%。然后，如果我们想一些进程去遵守这个使用 CPU 资源的限制的话，就将它加入到这个规则所绑定的进程组中，之后，相应的限制就会对其生效。&lt;/p&gt;

&lt;p&gt;总的来说，使用 CGroup，可以以进程组为单位，对其使用的操作系统的资源做更精细的控制。&lt;/p&gt;

&lt;h2 id=&#34;使用-cgroup&#34;&gt;使用 CGroup&lt;/h2&gt;

&lt;p&gt;其实 CGroup 说到底就是内核实现的一个资源隔离的功能，既然是一个功能，那直接去使用它将会有一个更加直观的了解：&lt;/p&gt;

&lt;p&gt;先来看下 cgroup 的文件系统下都提供了对那些资源的隔离：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;xr@xr-lab:/sys/fs/cgroup$ ll
total 0
drwxr-xr-x 15 root root 380 10月 24 14:35 ./
drwxr-xr-x 11 root root   0 10月 24 19:33 ../
dr-xr-xr-x  4 root root   0 10月 24 19:33 blkio/
lrwxrwxrwx  1 root root  11 10月 24 14:35 cpu -&amp;gt; cpu,cpuacct/
lrwxrwxrwx  1 root root  11 10月 24 14:35 cpuacct -&amp;gt; cpu,cpuacct/
dr-xr-xr-x  5 root root   0 10月 24 19:39 cpu,cpuacct/
dr-xr-xr-x  2 root root   0 10月 24 19:33 cpuset/
dr-xr-xr-x  4 root root   0 10月 24 19:33 devices/
dr-xr-xr-x  2 root root   0 10月 24 19:33 freezer/
dr-xr-xr-x  2 root root   0 10月 24 19:33 hugetlb/
dr-xr-xr-x  4 root root   0 10月 24 19:33 memory/
lrwxrwxrwx  1 root root  16 10月 24 14:35 net/cls -&amp;gt; net/cls,net/prio/
dr-xr-xr-x  2 root root   0 10月 24 19:33 net/cls,net/prio/
lrwxrwxrwx  1 root root  16 10月 24 14:35 net/prio -&amp;gt; net/cls,net/prio/
dr-xr-xr-x  2 root root   0 10月 24 19:33 perf/event/
dr-xr-xr-x  4 root root   0 10月 24 19:33 pids/
dr-xr-xr-x  2 root root   0 10月 24 19:33 rdma/
dr-xr-xr-x  5 root root   0 10月 24 19:33 systemd/
dr-xr-xr-x  5 root root   0 10月 24 19:33 unified/&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中 cpu 和 memory 我们都是比较熟悉的，而 blkio 代表了用于 I/O 的块设备，姑且可以将它当做是硬盘资源吧。假设我们现在有一个核心逻辑为「死循环」的程序:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 该例子参考了陈皓老师的博客：https://coolshell.cn/articles/17049.html，欢迎大家去原文观看
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(;;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;启动了该程序后，可以通过 &lt;code&gt;top&lt;/code&gt;命令看到其 CPU 占用率已经到达了100%&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/ED3B0D38-7934-45EF-8C3E-56906E330B0F.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们准备继续改造一下这个小程序：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;父进程启动后且创建子进程之前在 /sys/fs/cgroup/cpu 目录下再新建一个目录，作为一个我们自定义的进程组。并且对这个进程组使用的 CPU 资源写入一个限制规则：只能使用 CPU 的50%&lt;/li&gt;
&lt;li&gt;创建一个子进程并将其加入到我们已经创建好的进程组中，然后执行「死循环」逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sched.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define STACK_SIZE (1024 * 1024)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pipefd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;container_stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;STACK_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;container_main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pipefd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pipefd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;start&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(;;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent - start a container!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;cm&#34;&gt;/* 设置CPU利用率为50% */&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;mkdir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/sys/fs/cgroup/cpu/deadloop&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;755&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;echo 50000 &amp;gt; /sys/fs/cgroup/cpu/deadloop/cpu.cfs_quota_us&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;pipe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pipefd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
             &lt;span class=&#34;cm&#34;&gt;/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;container_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;container_main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;container_stack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;STACK_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SIGCHLD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;echo %d &amp;gt;&amp;gt; /sys/fs/cgroup/cpu/deadloop/tasks&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;container_pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pipefd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;container_pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent - container stopped!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在上面的例子中，我使用了一个 pipe 做父子进程间的同步，确保父进程把子进程 id 写入到名为 deadloop 的进程组之后再唤醒子进程执行死循环的逻辑。编译执行后，可以通过 top 命令看到，子进程的 CPU 利用率已经被限制到了50%。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/5C9AFD1C-DD3D-4A39-AF3A-2E41DBBFFF3B.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;除了对 CPU 限制之外，对 MEM，硬盘容量都可以做限制，甚至对某个块设备的读写速率也是可以限制的。&lt;/p&gt;

&lt;h2 id=&#34;一些重要的概念&#34;&gt;一些重要的概念&lt;/h2&gt;

&lt;h3 id=&#34;子系统&#34;&gt;子系统&lt;/h3&gt;

&lt;p&gt;在 CGroup 中，有很多子系统。一个子系统就代表一个资源控制器。/sys/fs/cgroup/ 目录下的项目就是目前操作系统提供的全部子系统。&lt;/p&gt;

&lt;h3 id=&#34;控制组-control-group&#34;&gt;控制组 (Control Group)&lt;/h3&gt;

&lt;p&gt;一个控制组包含多个进程，而资源的限制也是定义在控制组上的。若一个进程加入到某一个控制组，则自动会受到定义在这个控制组上面的限制规则的影响。&lt;/p&gt;

&lt;h3 id=&#34;层级&#34;&gt;层级&lt;/h3&gt;

&lt;p&gt;一个子系统下面的控制组，可以进行嵌套，最终形成一个树形的结构。子节点控制组会继承父节点控制组上对于资源的限制规则。若在子节点的控制组重定义了和父节点中相同资源的规则，则会发生覆盖（子覆盖父）&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;在 Docker 中，其实也是通过 CGroup 来实现对容器使用资源的限制的。如果你在 k8s 的环境下工作过，可能会对资源的「 Request」 和「Limit」 的概念比较熟悉。这是 k8s 给用户提供的一个可以指定容器使用资源限制的一个入口。最终到了操作系统这里，还是通过 CGroup 实现的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Detect Redis Config File</title>
      <link>http://littledriver.net/post/2018/11/16/detect-redis-config-file/</link>
      <pubDate>Fri, 16 Nov 2018 15:41:12 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/16/detect-redis-config-file/</guid>
      
        <description>

&lt;h3 id=&#34;include-part&#34;&gt;Include Part&lt;/h3&gt;

&lt;h4 id=&#34;include&#34;&gt;Include&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;include&lt;/code&gt; 可以允许用户在 Redis 的 Conf 文件中引用一份「已经准备好」的配置。一般来说，我们都会把一些通用的且很少变化的配置放在一个「配置模板」中，然后在真正的 Redis-Server 启动的配置文件中使用&lt;code&gt;include&lt;/code&gt; 命令包含它。这样一来，Redis-Server 在启动的时候就会使用配置模板内的配置项。&lt;/p&gt;

&lt;p&gt;你也可以在&lt;code&gt;include&lt;/code&gt; 命令后按照正常的方法写入其他配置。若新添加的配置项不在「配置模板」内容之中，那么这就相当于做了一个「追加」操作，否则，那将是一个「覆盖」操作。更为重要的是，&lt;code&gt;include&lt;/code&gt; 的内容不会被&lt;code&gt;CONFIG REWRITE&lt;/code&gt;命令的执行结果覆盖。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# include /path/to/local.conf&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# include /path/to/other.conf&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;load-part&#34;&gt;Load Part&lt;/h3&gt;

&lt;h4 id=&#34;loadmodule&#34;&gt;loadmodule&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;loadmodule&lt;/code&gt; 可以允许用户在 Redis 的 Conf 文件中指定在 Redis-Server 启动时要加载的「外部模块」。因为 Redis 本身也是通过 C 语言进行实现的，所以它在&lt;code&gt;redismodule.h&lt;/code&gt;文件中提供了一些 C API， 可供用户在使用 C 语言实现「外部模块」的时候使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# loadmodule /path/to/my_module.so&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# loadmodule /path/to/other_module.so&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;network-part&#34;&gt;Network Part&lt;/h3&gt;

&lt;h4 id=&#34;bind&#34;&gt;bind&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;bind&lt;/code&gt;配置项，允许用户指定一个或多个特定网卡的地址，并且将 Redis-Server 绑定在这个地址上。设置好了之后，若想通过 Redis-Cli 等工具访问 Redis-Server 的时候，&lt;code&gt;host&lt;/code&gt; 参数必须指定&lt;code&gt;bind&lt;/code&gt; 所绑定的地址。否则无法访问 Redis-Server。&lt;/p&gt;

&lt;p&gt;默认情况下，Redis 将此配置项的缺省值指定为：&lt;code&gt;127.0.0.1&lt;/code&gt;。这代表仅有和 Redis-Server 处于同一机器上的客户端可以访问。如果不指定&lt;code&gt;bind&lt;/code&gt;配置项，那么 Redis-Server 将接受来自机器上所有网卡的链接。&lt;/p&gt;

&lt;p&gt;这里一定需要注意的是，&lt;code&gt;bind&lt;/code&gt; 参数是给 Redis-Server 绑定一个本地机器网卡的地址，而不是一个外部访问的 IP 地址。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# bind 192.168.1.100 10.0.0.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# bind 127.0.0.1 ::1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;protected-mode&#34;&gt;protected-mode&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;protected-mode&lt;/code&gt;是 Redis 除了访问密码之外为增加其安全性所给出的一个配置参数。该配置项默认开启，仅接受和 Redis-Server 处于同一机器上的客户端的链接。并且可以支持无密码访问。否则，会禁用掉这项保护措施。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;protected-mode&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;port&#34;&gt;port&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;port&lt;/code&gt; 配置允许用户指定 Redis-Server 运行所监听的端口，默认情况下为 6379。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;port&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;6379&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;tcp-backlog&#34;&gt;tcp-backlog&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;tcp-backlog&lt;/code&gt;配置项是和 TCP 建立链接的过程有关的。对于使用者来说，可以简单的理解为，在完成了 TCP 的三次握手之后，客户端和 Redis—Server 建立链接的请求被放入了一个 Accept Queue 中，相当于进程的就绪队列，等待被 Redis-Server 处理。这个队列容量的大小就是受&lt;code&gt;tcp-backlog&lt;/code&gt;配置项控制的。&lt;/p&gt;

&lt;p&gt;理论上来说，如果使用 Redis 的服务有「高吞吐量」的特性，那么就需要在配置项中调大这个值。但是，这个值同时受到操作系统的相关参数的限制。最终 backlog 的值将取 &lt;code&gt;tcp-backlog&lt;/code&gt; 和  /proc/sys/net/core/somaxconn 两个值中较小的那一个。默认情况下，这个值的参数为 511。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;tcp-backlog&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;511&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;tcp-keepalive&#34;&gt;tcp-keepalive&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;tcp-keepalive&lt;/code&gt; 是和 TCP 链接保活机制有关的一个参数。若该配置项的值大于0，则 Redis-Server 将每隔 &lt;code&gt;tcp-keepalive&lt;/code&gt;秒向客户端发送一个保活探测报文，根据回应判断客户端当前是否正常。如果超过一定次数，发现对方仍然没有回应，则 Redis-Server 会主动断开他们之间的链接。若该配置项被设置为0，则 Redis—Server 不会再进行这个检测。否则将每隔 &lt;code&gt;tcp-keepalive&lt;/code&gt;秒发送一次保活探测报文。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;tcp-keepalive&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;500&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;unixsocket-unixsocketperm&#34;&gt;unixsocket &amp;amp;&amp;amp; unixsocketperm&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;unixsocket&lt;/code&gt; 和 &lt;code&gt;unixsocketperm&lt;/code&gt; 是 Unix socket 的配置项。如果用户想通过 Unix socket 的方式来链接 Redis-Server 的话，需要开启这两个配置，使得 Redis-Server 可以监听从 Unix socket 进来的链接。默认情况下这两个配置是不开启的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# unixsocket /tmp/redis.sock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# unixsocketperm 700&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;timeout&#34;&gt;timeout&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;timeout&lt;/code&gt; 配置项可以让用户自由指定一个客户端到 Redis-Server 的链接在空闲多久之后断开，单位是秒。当配置为 0 的时候，意味着链接永远不会断开，直到通信双方有一方进程停掉。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;timeout&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;general-part&#34;&gt;General Part&lt;/h3&gt;

&lt;h4 id=&#34;daemonize&#34;&gt;daemonize&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;daemonize&lt;/code&gt;配置项可以由用户来决定，是否以「守护进程」的方式来运行 Redis-Server。默认情况下这个配置项是禁用的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;daemonize&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;no&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;pidfile&#34;&gt;pidfile&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;pidfile&lt;/code&gt; 配置项允许用户指定一个文件的绝对路径。该文件的内容为 Redis-Server 进程的 PID。若已经开启了 &lt;code&gt;daemonize&lt;/code&gt;配置且&lt;code&gt;pidfile&lt;/code&gt;指定了一个路径，那么默认情况下会将  Redis-Server 的 PID 写入到&lt;code&gt;pidfile&lt;/code&gt;指定的文件中。否则，写入到&lt;code&gt;/var/run/redis.pid&lt;/code&gt;中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;pidfile&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;/var/run/redis_6379.pid&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;loglevel-logfile&#34;&gt;loglevel &amp;amp;&amp;amp; logfile&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;loglevel&lt;/code&gt; 配置项允许用户指定 Redis-Server 日志输出的等级。等级越高，输出的信息也就越丰富。该配置项的候选值有如下几个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;warning： 仅一些必要的错误信息和重要的信息&lt;/li&gt;
&lt;li&gt;notice: 除一些必要的错误信息和重要的信息之外，有一部分的冗余信息。推荐在生产环境中开启&lt;/li&gt;
&lt;li&gt;verbose：信息更加丰富，揭示 Redis-Server 的运行过程&lt;/li&gt;
&lt;li&gt;debug：Redis-Server 能够输出的所有的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;logfile&lt;/code&gt;允许用户指定 Redis-Server 服务日志的存放路径。默认情况下如果不指定这个参数，Redis—Server 会将日志输出到标准输入。而且，如果是以守护进程的模式运行的话，日志会被打入「黑洞」：&lt;code&gt;/dev/null&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;loglevel&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;notice&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;logfile&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/redis/log&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;syslog-enabled-syslog-ident&#34;&gt;syslog-enabled &amp;amp;&amp;amp; syslog-ident&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;syslog-enabled&lt;/code&gt; 配置项开启之后，会将 Redis-Server 的服务日志输出到操作系统日志所在的文件中。也就是&lt;code&gt;/var/log/syslog&lt;/code&gt;。默认情况下这个配置是关闭的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;syslog-ident&lt;/code&gt; 配置项主要是用来给输出到系统日志的 Redis-Server 的服务日志内容添加一些特殊的标记，方便通过一些工具进行筛选。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;syslog-enabled&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;syslog-ident&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;native-redis&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;databases&#34;&gt;databases&lt;/h4&gt;

&lt;p&gt;在一个 Redis 的实例中，通常会将它申请的内存按照 &lt;code&gt;databases&lt;/code&gt;配置项的值切分成不同的部分 (即「分组」操作)。每一个子 database 通过整数进行索引，编号从 0~ databases。在对 Redis 操作之前，可以先通过 select 命令选取其中一个子数据库进行读取和写入。若你在两个不同的子数据库中写入相同的 key 但是不同的值之后就会发现，两者是不发生冲突的。默认情况下 &lt;code&gt;databases&lt;/code&gt;配置项为16。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;databases&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;16&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Redis 之所以提供了这样的功能，最主要的原因是，很多重要的功能无法在多个 Redis 实例上一起配合来实现。如涉及到多个实例上的 Key 的事务功能是不可以用的。Redis 提供的分区功能，是在同一个进程的内存空间中实现了内存使用的隔离。至于每一个 db 被分配多少内存，一个 db 写满了之后会发生什么，是和 Redis 的内存分配策略有关的，这里暂时不详细介绍了。&lt;/p&gt;

&lt;h3 id=&#34;rdb-backup&#34;&gt;RDB Backup&lt;/h3&gt;

&lt;h4 id=&#34;save&#34;&gt;save&lt;/h4&gt;

&lt;p&gt;RDB 是 Redis 提供的一种「快照」形式的备份策略。它不能够保证高实时性，但是可以对 Redis 数据的「容灾性」提供一个比较好的帮助。&lt;/p&gt;

&lt;p&gt;用户可以通过 &lt;code&gt;save&lt;/code&gt;配置来设定 RDB 备份的策略，如 &lt;code&gt;save 900 1&lt;/code&gt;，意味着当900秒的时间内，如果有1个 key 的内容发生了改变，那么在900秒的时间结束后，就会进行一次 RDB 的备份操作。当然，如果你想禁用掉这个 RDB 的备份功能，可以在配置文件中不指定 &lt;code&gt;save&lt;/code&gt;配置项。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;save&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;900&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 900s 内至少有一个 Key 的内容发生修改就备份&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;save&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 1000s 内至少有两个 Key 的内容发生修改就备份&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;stop-writes-on-bgsave-error&#34;&gt;stop-writes-on-bgsave-error&lt;/h4&gt;

&lt;p&gt;默认开启 RDB 备份功能的情况下，备份操作可能会出现失败的情况。此时，如果用户和运维都没有察觉的话，最终的结果可能是灾难性的。&lt;code&gt;stop-writes-on-bgsave-error&lt;/code&gt;配置项允许用户借助 Redis 自身提供的一个功能：RDB 备份失败后，写入操作会报错。直到下一次 RDB 备份开始，才允许客户端进行写入。&lt;/p&gt;

&lt;p&gt;不过，Redis 自身提供的这个「防范机制」有点太暴力的。如果想自己去感知这个问题并且做出一些处理，可以对 Redis 的一些指标进行监控，然后将这个配置关掉。因为它默认是开启的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;stop-writes-on-bgsave-error&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;rdbcompression&#34;&gt;rdbcompression&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;rdbcompression&lt;/code&gt; 配置项开启之后，Redis 在进行 RDB 备份的时候，会对 String 类型的内容按照一定的压缩算法进行压缩，以节省空间。此配置项默认开启。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Exapmle &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;rdbcompression&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;rdbchecksum&#34;&gt;rdbchecksum&lt;/h4&gt;

&lt;p&gt;默认情况下，RDB 备份操作之后，会在备份文件的末尾插入一些校验位，以保证数据的完整性。若&lt;code&gt;rdbchecksum&lt;/code&gt; 配置项开启，则在 Redis 导入备份数据的时候，会消耗一定的性能对备份数据进行校验，防止导入脏数据甚至是导入数据失败。此配置项默认开启。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Exapmle &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;rdbchecksum&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;dbfilename&#34;&gt;dbfilename&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;dbfilename&lt;/code&gt;可以指定 Redis 创建的 RDB 备份文件的名称。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;dbfilename&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;dump.rdb&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;dir&#34;&gt;Dir&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dir&lt;/code&gt; 配置项可以由用户指定 RDB 备份文件的存放路径。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;dir&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;./&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;aof-backup&#34;&gt;AOF Backup&lt;/h3&gt;

&lt;h4 id=&#34;appendonly&#34;&gt;appendonly&lt;/h4&gt;

&lt;p&gt;AOF 是 Redis 为了保证数据可靠性提供的第二种数据持久化方案。它记录的是 Redis 的写入操作而非数据。AOF 的实时性更强，因为 RDB 快照的属性，总是有相当大的风险丢失两次 RDB 备份之间的数据的。&lt;code&gt;appendonly&lt;/code&gt;配置项可以开启和关闭 AOF 的功能。该配置项默认开启。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;appendonly&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;appendfilename&#34;&gt;appendfilename&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;appendfilename&lt;/code&gt;可以指定 Redis 创建的 aof 备份文件的名称。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;appendfilename&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;a.aof&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;appendfsync&#34;&gt;appendfsync&lt;/h4&gt;

&lt;p&gt;Redis 在开启了 AOF 之后会将操作记录写在内存当中。但是这仍然是不安全的，因为进程 down 掉或者机器掉电，这些数据都没了。而操作系统自动将内存数据 flush 到硬盘的频率是比较长的，不一定能够满足用户对于 AOF 实时性的需求。所以提供了一个名为 &lt;code&gt;appendfsync&lt;/code&gt; 的配置来调整 flush 写入记录到硬盘的频率。默认情况下是每秒保存一次。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;appendfsync always： 每一个操作都会 flush 到硬盘&lt;/li&gt;
&lt;li&gt;appendfsync everysec：每秒做一次 flush 操作&lt;/li&gt;
&lt;li&gt;appendfsync no：不主动做 flush，依靠操作系统的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;appendfsync&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;everysec&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;no-appendfsync-on-rewrite&#34;&gt;no-appendfsync-on-rewrite&lt;/h4&gt;

&lt;p&gt;AOF 文件重写，RDB 快照备份，都是需要进行磁盘I/O 的操作。如果再加上 AOF 以每秒或者每个操作的写入，势必会发生一些 I/O 阻塞的问题。Redis 在这个问题上，采取了「规避」的方式来处理。当 &lt;code&gt;no-appendfsync-on-rewrite&lt;/code&gt;配置项开启之后，如果统一时间段里有其他的磁盘操作在进行，AOF 的 flush 操作可能会延迟一会执行。当然，提升性能的同时带来的问题就是用户需要忍受 AOF 的实时性会有降低。该配置默认关闭。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;no-appendfsync-on-rewrite&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;no&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;auto-aof-rewrite-percentage-auto-aof-rewrite-min-size&#34;&gt;auto-aof-rewrite-percentage &amp;amp;&amp;amp; auto-aof-rewrite-min-size&lt;/h4&gt;

&lt;p&gt;AOF 文件随着对 Redis 操作的增多，其文件大小也会上升。但是 Redis 中有很多写操作是可以进行合并的，比如你对一个 Key，先 set 一个 A，又 set 了一个 B。最终 B 是有效的，此时就可以把两个 Set 操作合二为一。Redis 使用 &lt;code&gt;auto-aof-rewrite-percentage&lt;/code&gt; 和 &lt;code&gt;auto-aof-rewrite-min-size&lt;/code&gt; 两个配置为重写操作提供了一些定制化的功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;auto-aof-rewrite-percentage： 在第一次  AOF 文件重写之后，会记录一个 base size，Redis 会定义将目前 AOF 文件的大小和这个 base size 比较。如果current size 已经达到了base size 的某个比例的大小，就会进行重写操作。base size 在每一次 Rewrite 操作之后都会更新。该配置项取值 0~100.&lt;/li&gt;
&lt;li&gt;auto-aof-rewrite-min-size：为了防止 AOF 文件在重写的过程中变的越来越小，可以指定一个该文件最小的大小。如果 current size 还没有达到它所设置的阈值，则不会发生AOF 文件重写。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;auto-aof-rewrite-percentage&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;auto-aof-rewrite-min-size&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;64mb&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;aof-load-truncated&#34;&gt;aof-load-truncated&lt;/h4&gt;

&lt;p&gt;Redis 在重新启动的时候，会通过加载 AOF 和 RDB 文件两种方式来恢复内存中的数据。其中 AOF 文件会优先使用。如果在 Load AOF 文件中所写入的数据时候，发现在 AOF 文件的尾部有内容上的损坏，则用户可以通过指定 &lt;code&gt;aof-load-truncated&lt;/code&gt;配置项来指示 Redis 到底是应该继续恢复并且尽可能多的恢复数据，还是立刻报错。默认情况下，Redis 会尽可能多的读入数据，&lt;code&gt;aof-load-truncated&lt;/code&gt;的值为 Yes。&lt;/p&gt;

&lt;p&gt;但是，这里要注意的是，被损坏的部分仅限于 AOF 文件的尾端。若中间部分有损坏，Redis 会无视这个配置项，直接报错。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;aof-load-truncated&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;replica&#34;&gt;Replica&lt;/h3&gt;

&lt;h4 id=&#34;masterauth&#34;&gt;masterauth&lt;/h4&gt;

&lt;p&gt;如果 Master 已经配置了访问密码，那么需要在从节点的配置中加入&lt;code&gt;masterauth&lt;/code&gt;配置项，并将访问密码作为该配置项的值。因为在从节点要和主节点建立数据同步链接的时候，需要通过访问密码来鉴权。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;masterauth&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;rootroot&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;replica-serve-stale-data&#34;&gt;replica-serve-stale-data&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;replica-serve-stale-data&lt;/code&gt;配置项允许用户设定，当主从链接断开的时候，从节点如何响应客户端的请求。默认情况下，该配置项的值为 yes， 即允许从节点正常响应用户的请求，但是可能会发生数据是过期的，甚至是根本没有数据的情况。若将其赋值为 no，则从节点将会对客户端的请求返回一个错误，拒绝提供服务。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;replica-serve-stale-data&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;replica-read-only&#34;&gt;replica-read-only&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;replica-read-only&lt;/code&gt; 配置项允许用户将从节点设置为只读模式。这是一种保护措施。因为当主从关系建立之后，主节点会一直向从节点同步数据。如果用户向从节点写数据的话，最终会被覆盖。该配置项默认为yes。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;replica-read-only&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;repl-ping-replica-period&#34;&gt;repl-ping-replica-period&lt;/h4&gt;

&lt;p&gt;该配置项默认值为10，表示从节点每隔 10s 将向主节点执行 PING 命令，以确认两者之间的关系正常。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;repl-ping-replica-period&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;repl-timeout&#34;&gt;repl-timeout&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;repl-timeout&lt;/code&gt;配置项为主从节点之间设置了一个通信的超时时间。若该配置项指定的时间内发现两者没有通信，则认为主从节点间的链接异常。这个配置项的值在设置的时候需要大于 &lt;code&gt;replica-read-only&lt;/code&gt;配置项的值，否则在主从节点之间数据量较低的情况下，可能会一直检测到「超时」。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;repl-timeout&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;repl-disable-tcp-nodelay&#34;&gt;repl-disable-tcp-nodelay&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;repl-disable-tcp-nodelay&lt;/code&gt;配置项主要用于控制主从节点同步数据的速率。若该配置项的值为 yes，则 Redis 将使用更小尺寸的 TCP 报文和更小的带宽来进行数据同步操作。好处比较明显，能够控制 Redis 数据同步的流量，坏处就是增加了数据同步的时延。反之，如果设置为 no，则会去掉这个限制。提升数据同步的效率。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;repl-disable-tcp-nodelay&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;yes&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;repl-backlog-size-repl-backlog-ttl&#34;&gt;repl-backlog-size &amp;amp;&amp;amp; repl-backlog-ttl&lt;/h4&gt;

&lt;p&gt;Master 节点会为 Slave 节点配置一个复制缓冲区，用来保存最新的需要同步的数据。当 Slave 节点和 Master 节点断开连接之后又重新建立链接的时候，很可能只需要一次「局部」的同步操作即可实现主从数据的一致性。这就是复制缓冲区的作用。而 &lt;code&gt;repl-backlog-size&lt;/code&gt; 配置项，指定了这个缓冲区的大小。缓冲区越大，那么保存的数据也就越多，对 Slave 节点离线时间的长度容忍度也就越高。&lt;/p&gt;

&lt;p&gt;但是，如果主从链接是我们有意断开的，这个复制缓冲区总不能一直保存在那里。所以 Redis 提供了&lt;code&gt;repl-backlog-ttl&lt;/code&gt;配置项，当主从链接断开的时间超过该配置项的值的时候，Master 节点将会清空这个复制缓冲区的内容。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;repl-backlog-size&lt;/code&gt; 默认值为 16mb，&lt;code&gt;repl-backlog-ttl&lt;/code&gt; 为3600。&lt;/p&gt;

&lt;h4 id=&#34;replica-priority&#34;&gt;replica-priority&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;replica-priority&lt;/code&gt; 配置项主要用于 Redis Slave 节点，标识了这个节点的优先级，取值范围从0~100。数字越低，优先级越高。在进行主从切换的时候越有可能被 Sentinel 节点提升为 Master 节点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;replica-priority&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;min-replicas-to-write-min-replicas-max-lag&#34;&gt;min-replicas-to-write &amp;amp;&amp;amp; min-replicas-max-lag&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;min-replicas-to-write&lt;/code&gt; 和 &lt;code&gt;min-replicas-max-lag&lt;/code&gt; 两个配置项分别指定了最小链接到主节点的活跃的从节点的个数以及最大主从节点通信的延迟。如果在主从节点通信的过程中，这个两个选项的条件有哪一个没有满足，主节点将拒绝客户端的写入操作。前者默认值为3，或者为10，都是秒为单位。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# min-replicas-to-write 3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# min-replicas-max-lag 10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;slave-announce-ip-slave-announce-port&#34;&gt;slave-announce-ip &amp;amp;&amp;amp; slave-announce-port&lt;/h4&gt;

&lt;p&gt;一般来说，通过对 Master 节点执行 Info Replication 命令，即可通过 Master 节点列出所有的 Slave 节点的相关信息（IP，port 等）。Master 节点本来是可以通过两者之间的链接来发现 Slave 节点的 IP 和端口的。但是，如果在环境中启动了 NAT 或者端口转发机制（尤其是在 Docker 和 k8s 中），或者说，两者通信链路之间还通过了一些「代理」，在 Master 上显示的 Slave 节点的信息可能就不准确。所以，用户可以通过 &lt;code&gt;slave-announce-ip&lt;/code&gt;和 &lt;code&gt;slave-announce-port&lt;/code&gt; 配置项，强制指定 Slave 节点的 IP 和 Port，并将此信息通知给 Master 节点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# replica-announce-ip 5.5.5.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# replica-announce-port 1234&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;security&#34;&gt;Security&lt;/h3&gt;

&lt;h4 id=&#34;requirepass&#34;&gt;requirepass&lt;/h4&gt;

&lt;p&gt;用户可以通过&lt;code&gt;requirepass&lt;/code&gt;配置项为 Redis Server 设置密码。客户端在连接了服务端之后，需要使用密码鉴权才能够执行命令。&lt;/p&gt;

&lt;h4 id=&#34;rename-command&#34;&gt;rename-command&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;rename-command&lt;/code&gt; 是 Redis 为提升其安全性加入的配置项。它允许用户将一些高危命令进行重命名，以防止用户不小心或者恶意对数据库做出一些危险的操作。&lt;/p&gt;

&lt;p&gt;这个配置项虽然有用，可以提升安全性。但是最好用在 Redis 实例只有一个用户使用的场景下。因为不同的用户需求不同，强行禁用掉一些命令也并不是一个好事。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# rename-command CONFIG &amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# rename-command flushall &amp;#34;&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;memory&#34;&gt;Memory&lt;/h3&gt;

&lt;p&gt;内存对于 Redis 是一个非常重要的资源，它是 Redis 高性能的支撑点，同时也是最容易出问题的地方。所以，Redis 也开放了一些配置项，使得用户可以根据自己不同的使用姿势来对 Redis 使用内存的行为作出一些限制，以此来提高效率和防止一些问题的发生。&lt;/p&gt;

&lt;h4 id=&#34;maxmemory-maxmemory-policy&#34;&gt;maxmemory &amp;amp;&amp;amp; maxmemory-policy&lt;/h4&gt;

&lt;p&gt;该配置项允许用户为 Redis 配置一个「最大内存使用值」。如果用户在设置了&lt;code&gt;maxmemory&lt;/code&gt;的同时还通过 &lt;code&gt;maxmemory-policy&lt;/code&gt;设置了一定的缓存淘汰策略。那么当Redis 实例的内存使用量达到阈值之后，会通过「淘汰规则」清理掉一部分的数据，以留出足够的空间来正常响应后续的写入操作。否则，若没有设置淘汰策略(默认为noeviction)，当 Redis 实例的内存达到阈值之后，会拒绝写入操作，但是正常响应读取操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# maxmemory &amp;lt;bytes&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# maxmemory-policy noeviction&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;maxmemory-samples&#34;&gt;maxmemory-samples&lt;/h4&gt;

&lt;p&gt;Redis 在执行内存淘汰策略的时候，会按照一定的规则选取「候选样本」。比如，当用户将&lt;code&gt;maxmemory-policy&lt;/code&gt;设置为&lt;code&gt;volatile-lru&lt;/code&gt;的时候，如果 Redis 实例的内存用量达到了&lt;code&gt;maxmemory&lt;/code&gt;指定的阈值，Redis 就会每次取&lt;code&gt;maxmemory-samples&lt;/code&gt;个 key 为样本，删掉一个最近未使用时间最长的 key。&lt;code&gt;maxmemory-samples&lt;/code&gt;设置的值越大，淘汰策略越接近真实的 LRU 算法，但是同时给 CPU 造成的压力也会增加。否则，虽然会运行的比较快，但是淘汰的效果不会很好。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# Example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# maxmemory-samples 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>K8s GC Design Principle</title>
      <link>http://littledriver.net/post/2018/11/15/k8s-gc-design-principle/</link>
      <pubDate>Thu, 15 Nov 2018 22:40:55 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/15/k8s-gc-design-principle/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;Ref: &lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/garbage-collection.md#orphaning-the-descendants-with-orphan-finalizer&#34;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/garbage-collection.md#orphaning-the-descendants-with-orphan-finalizer&lt;/a&gt;
Warning：设计文档的对应的 k8s 版本为1.7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;q-what-is-gc-of-kuernetes&#34;&gt;Q: What is GC of Kuernetes ?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;GC 是 Garbage Collector 的简称。从功能层面上来说，它和编程语言当中的「GC」 基本上是一样的。它清理 Kubernetes 中「符合特定条件」的 Resource Object。（在 k8s 中，你可以认为万物皆资源，很多逻辑的操作对象都是 Resource Object。）&lt;/p&gt;

&lt;h3 id=&#34;q-what-are-dependent-mechanisms-to-clear-needless-resource-objects&#34;&gt;Q: What are dependent mechanisms to clear needless resource objects ?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes 在不同的 Resource Objects 中维护一定的「从属关系」。内置的 Resource Objects 一般会默认在一个 Resource Object 和它的创建者之间建立一个「从属关系」。当然，你也可以利用&lt;code&gt;ObjectMeta.OwnerReferences&lt;/code&gt;自由的去给两个 Resource Object 建立关系，前提是被建立关系的两个对象必须在一个 Namespace 下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// OwnerReference contains enough information to let you identify an owning
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// object. Currently, an owning object must be in the same namespace, so there
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// is no namespace field.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OwnerReference&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// API version of the referent.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;APIVersion&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;apiVersion&amp;#34; protobuf:&amp;#34;bytes,5,opt,name=apiVersion&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Kind of the referent.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;Kind&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;kind&amp;#34; protobuf:&amp;#34;bytes,1,opt,name=kind&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Name of the referent.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// More info: http://kubernetes.io/docs/user-guide/identifiers#names
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;name&amp;#34; protobuf:&amp;#34;bytes,3,opt,name=name&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// UID of the referent.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;UID&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;types&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UID&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;uid&amp;#34; protobuf:&amp;#34;bytes,4,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// If true, this reference points to the managing controller.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// +optional
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;Controller&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;controller,omitempty&amp;#34; protobuf:&amp;#34;varint,6,opt,name=controller&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// If true, AND if the owner has the &amp;#34;foregroundDeletion&amp;#34; finalizer, then
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// the owner cannot be deleted from the key-value store until this
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// reference is removed.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Defaults to false.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// To set this field, a user needs &amp;#34;delete&amp;#34; permission of the owner,
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// otherwise 422 (Unprocessable Entity) will be returned.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// +optional
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;BlockOwnerDeletion&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;blockOwnerDeletion,omitempty&amp;#34; protobuf:&amp;#34;varint,7,opt,name=blockOwnerDeletion&amp;#34;`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;OwnerReference&lt;/code&gt;一般存在于某一个 Resource Object  信息中的 metadata 部分。&lt;code&gt;OwnerReference&lt;/code&gt;中的字段可以唯一的确定 k8s 中的一个 Resource Object。两个 Object 可以通过这种方式建立一个 &lt;code&gt;owner-dependent&lt;/code&gt;的关系。&lt;/p&gt;

&lt;p&gt;K8s 实现了一种「Cascading deletion」（级联删除）的机制，它利用已经建立的「从属关系」进行资源对象的清理工作。例如，当一个 dependent 资源的 owner 已经被删除或者不存在的时候，从某种角度就可以判定，这个 dependent 的对象已经是异常（无人管辖）的了，需要进行清理。而 「cascading deletion」则是被 k8s 中的一个 controller 组件实现的：&lt;code&gt;Garbage Collector&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以，k8s 是通过 &lt;code&gt;Garbage Collector&lt;/code&gt; 和 &lt;code&gt;ownerReference&lt;/code&gt; 一起配合实现了「垃圾回收」的功能。&lt;/p&gt;

&lt;h3 id=&#34;q-what-is-the-relationship-like-owner-dependent&#34;&gt;Q: What is the relationship like ?(owner-dependent)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们可以通过一个实际的例子来了解这个「从属关系」：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;apiVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;extensions/v1beta1&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;kind&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;ReplicaSet&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;metadata&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;annotations&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;deployment.kubernetes.io/desired-replicas&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;deployment.kubernetes.io/max-replicas&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;deployment.kubernetes.io/revision&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;creationTimestamp&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;ld&#34;&gt;2018-09-07T07:11:52Z&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;generation&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;labels&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;app&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;pod-template-hash&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;3866135192&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee-7dbb5795f6&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;namespace&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;default&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;ownerReferences&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;apiVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;apps/v1&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;blockOwnerDeletion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;controller&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;kind&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;Deployment&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;uid&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;4b807ee6-b26d-&lt;span class=&#34;m&#34;&gt;11e8&lt;/span&gt;-b891-fa163eebca40&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;resourceVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;476159&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;selfLink&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;/apis/extensions/v1beta1/namespaces/default/replicasets/coffee-7dbb5795f6&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;uid&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;4b81e76c-b26d-&lt;span class=&#34;m&#34;&gt;11e8&lt;/span&gt;-b891-fa163eebca40&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;spec&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;replicas&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;....&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面截取了一个 ReplicaSet Object 中的 metadata 的部分信息。我们可以注意到，它的 &lt;code&gt;ownerReferences&lt;/code&gt;字段标识了一个 Deployment Object。我们都清楚的是，ReplicaSet 会创建一系列的 Pod。通过&lt;code&gt;spec.replicas:2&lt;/code&gt;可以知道，他会创建两个pod。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@xr-service-mesh-lab:~/istio-1.0.2# kubectl get pods  | grep coffee
coffee-7dbb5795f6-6crxz          1/1       Running   0          9d
coffee-7dbb5795f6-hv7tr          1/1       Running   0          5d
root@xr-service-mesh-lab:~/istio-1.0.2#&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;让我们来观察其中一个 Pod：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;apiVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;v1&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;kind&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;Pod&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;metadata&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;annotations&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;cni.projectcalico.org/podIP&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;192.168&lt;/span&gt;.&lt;span class=&#34;m&#34;&gt;0.14&lt;/span&gt;/&lt;span class=&#34;m&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;creationTimestamp&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;ld&#34;&gt;2018-09-07T07:11:52Z&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;generateName&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee-7dbb5795f6-&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;labels&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;app&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;pod-template-hash&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;3866135192&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee-7dbb5795f6-6crxz&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;namespace&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;default&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;ownerReferences&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;apiVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;apps/v1&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;blockOwnerDeletion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;controller&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;kind&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;ReplicaSet&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee-7dbb5795f6&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;uid&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;4b81e76c-b26d-&lt;span class=&#34;m&#34;&gt;11e8&lt;/span&gt;-b891-fa163eebca40&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;resourceVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;76727&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;selfLink&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;/api/v1/namespaces/default/pods/coffee-7dbb5795f6-6crxz&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;uid&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;4b863e4d-b26d-&lt;span class=&#34;m&#34;&gt;11e8&lt;/span&gt;-b891-fa163eebca40&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看出，pod 中的&lt;code&gt;ownerReferences&lt;/code&gt;所标识的 Object 正式我们上面看到过的 ReplicaSet。最后让我们来检查一下 ReplicaSet 所对应的 Deployment 的情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;apiVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;extensions/v1beta1&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;kind&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;Deployment&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;metadata&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;annotations&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;deployment.kubernetes.io/revision&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;creationTimestamp&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;ld&#34;&gt;2018-09-07T07:11:52Z&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;generation&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;labels&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;app&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;coffee&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;namespace&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;default&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;resourceVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;476161&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;selfLink&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;/apis/extensions/v1beta1/namespaces/default/deployments/coffee&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;uid&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;4b807ee6-b26d-&lt;span class=&#34;m&#34;&gt;11e8&lt;/span&gt;-b891-fa163eebca40&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对比一下 ReplicaSet Object 中 ownerReference 标识的 Object 可知，这个 Deployment 是 ReplicaSet 的 owner。至此，我们通过观察三个 Object 中的 ownerReference 的信息，可以建立起如下的「从属关系」：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deployment（owner）—&amp;gt; ReplicaSet (dependent)&lt;/li&gt;
&lt;li&gt;ReplicaSet (owner) —&amp;gt; Pod (dependent)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/relationship&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;q-what-is-the-working-mechanism-of-garbage-collector&#34;&gt;Q: What is the working mechanism of Garbage Collector?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;一个 Garbage Collector 通常由三部分实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scanner： 它负责收集目前系统中已存在的 Resource，并且周期性的将这些资源对象放入一个队列中，等待处理（检测是否要对某一个Resource Object 进行 GC 操作）&lt;/li&gt;
&lt;li&gt;Garbage Processor: Garbage Processor 由两部分组成

&lt;ul&gt;
&lt;li&gt;Dirty Queue： Scanner 会将周期性扫描到的 Resource Object 放入这个队列中等待处理&lt;/li&gt;
&lt;li&gt;Worker：worker 负责从这个队列中取出元素进行处理

&lt;ul&gt;
&lt;li&gt;检查 Object 的 metaData 部分，查看&lt;code&gt;ownerReference&lt;/code&gt;字段是否为空

&lt;ul&gt;
&lt;li&gt;如果为空，则本次处理结束&lt;/li&gt;
&lt;li&gt;如果不为空，检测&lt;code&gt;ownerReference&lt;/code&gt;字段内标识的 Owner Resource Object是否存在

&lt;ul&gt;
&lt;li&gt;存在：则本次处理结束&lt;/li&gt;
&lt;li&gt;不存在：删除这个 Object&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实，在有了 Scanner 和 Garbage Processor 之后，Garbage Collector 就已经能够实现「垃圾回收」的功能了。但是有一个明显的问题：Scanner 的扫描频率设置多少好呢？太长了，k8s 内部就会积累过多的「废弃资源」；太短了，尤其是在集群内部资源对象较多的时候，频繁的拉取信息对 API-Server 也是一个不小的压力。&lt;/p&gt;

&lt;p&gt;k8s 作为一个分布式的服务编排系统，其内部执行任何一项逻辑或者行为，都依赖一种机制：「事件驱动」。说的简单点，k8s 中一些看起来「自动」的行为，其实都是由一些神秘的「力量」在驱动着。而这个「力量」就是我们所说的「Event」。任意一个 Resource Object 发生变动的时候（新建，更新，删除），都会触发一个 k8s 的事件（Event），这个事件在 k8s 的内部是公开的，也就是说，我们可以在任意一个地方监听这些事件。&lt;/p&gt;

&lt;p&gt;总的来说，无论是「事件的监听机制」还是「周期性访问 API-Server 批量获取 Resource Object 信息」，其目的都是为了能够掌握 Resource Object 的最新信息。两者是各有优势的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;批量拉取：一次性拉取所有的 Resource Object，全面&lt;/li&gt;
&lt;li&gt;监听 Resource 的 Event：实时性强， 且对 API—SERVER 不会造成太大的压力&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;综上所述，在实现 Garbage Collector 的过程中，k8s 向其添加了一个「增强型」的组件：Propagator&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Propagator： Propagator 由三个部分构成

&lt;ul&gt;
&lt;li&gt;EventQueue：负责存储 k8s 中资源对象的事件（Eg：ADD，UPDATE，DELETE）&lt;/li&gt;
&lt;li&gt;DAG(有向无环图)：负责存储 k8s 中所有资源对象的「owner-dependent」 关系&lt;/li&gt;
&lt;li&gt;Worker：从 EventQueue 中，取出资源对象的事件，根据事件的类型会采取以下两种操作

&lt;ul&gt;
&lt;li&gt;ADD/UPDATE: 将该事件对应的资源对象加入 DAG，且如果该对象有 owner 且 owner 不在 DAG 中，将它同时加入 Garbage Processor 的 Dirty Queue 中&lt;/li&gt;
&lt;li&gt;DELETE：将该事件对应的资源对象从 DAG 中删除，并且将其「管辖」的对象（只向下寻找一级，如删除 Deployment，那么只操作 ReplicaSet ）加入 Garbage Processor 的 Dirty Queue 中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在有了 Propagator 的加入之后，我们完全可以仅在 GC 开始运行的时候，让 Scanner 扫描一下系统中所有的 Object，然后将这些信息传递给 Propagator 和 Dirty Queue。只要 DAG 一建立起来之后，那么 Scanner 其实就没有再工作的必要了。「事件驱动」的机制提供了一种增量的方式让 GC 来监控 k8s 集群内部的资源对象变化情况。&lt;/p&gt;

&lt;h3 id=&#34;q-how-can-i-delete-the-owner-and-reserve-dependents&#34;&gt;Q: How can I delete the owner and reserve dependents ?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;╮(╯▽╰)╭没错，需求就是这么奇怪，k8s 还兼容一种情况：删除 owner，留下 dependents。剩余的 dependents 被称为是「orphan」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;你想怎么实现&#34;&gt;你想怎么实现?&lt;/h4&gt;

&lt;p&gt;如果暂时先不看设计文档中关于这部分的内容，根据之前对 k8s GC 的了解，让你来实现这个功能，你会怎么做呢？这里给出一下笔者的想法：&lt;/p&gt;

&lt;p&gt;首先，我们先来根据上面对于 GC 的了解，给出一幅大致架构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/444&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，我用三种颜色分别标记了三条较为重要的处理过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;红色：worker 从 dirtyQueue 中取出资源对象，检查其是否带有 owner ，如果没带，则不处理。否则检测其 owner是否存在，存在，则处理下一个资源对象，不存在，删除这个 object。&lt;/li&gt;
&lt;li&gt;绿色： scanner 从 api-server 中扫描存在于 k8s 集群中的资源对象并加入至 dirtyQueue&lt;/li&gt;
&lt;li&gt;粉色：propagator.worker 从 eventQueue 中取出相应的事件并且获得对应的资源对象，根据事件的类型以及相应资源对象所属 owner 对象的情况来进行判定，是否要进行两个操作：

&lt;ul&gt;
&lt;li&gt;从 DAG 中删除相应节点（多为响应 DELETE 事件的逻辑）&lt;/li&gt;
&lt;li&gt;将有级联关系但是 owner 不存在的对象送入 diryQueue 中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中红色是「数据处理」过程，而绿色和粉色是「数据收集」的过程。在「数据处理」的过程中（即我们上面分析过的 GC 的 Worker 的工作过程），worker 做的较为重要的工作有两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查资源对象信息的「ownerReference」字段，判断其是否处在一个级联关系中&lt;/li&gt;
&lt;li&gt;若资源对象有所属 owner 且不存在，则删除这个对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此时，回头看下我们的需求:「owner 删除，dependents 留下」。如果想在「数据处理」这条链路上做些修改达到我们目的的话，唯一可行的办法就是：在删除了 dependents 对应的 owner 对象之后，同时删除 dependents 信息中 「ownerReference」字段和对应的值。这样一来，在检测资源对象是否应该被删除的过程就会因为其没有「ownerReference」字段而放过它，最终实现了 dependents 对象的“孤立”。&lt;/p&gt;

&lt;h4 id=&#34;k8s-是怎么实现的&#34;&gt;k8s 是怎么实现的?&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你了解 gRPC-intercepter 的工作机制，那么会加快你理解下面的内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;k8s 在系统内部实现了一种类似「删除拦截器链」的机制：即在删除某个资源对象的「删除链路」上，执行一个或多个「拦截逻辑」。并且这种「拦截逻辑」可以自主实现，然后像插件一样注入到这个删除链路上。这种机制在 k8s 当中统称为： &lt;code&gt;Finalizers&lt;/code&gt;。&lt;code&gt;Finalizers&lt;/code&gt;的声明非常简单，就是一个&lt;code&gt;[]string&lt;/code&gt;。这个 Slice 的内部填充的是要执行拦截器的名称。它存在于任何一个资源对象的 Meta 信息中: &lt;a href=&#34;https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L246&#34;&gt;apimachinery/types.go at master · kubernetes/apimachinery · GitHub&lt;/a&gt;。&lt;code&gt;Finalizers&lt;/code&gt;中的拦截器在其宿主资源对象触发删除操作之后顺序执行（资源对象的deletionTimestamp不为 nil），每执行完一个，就会从&lt;code&gt;Finalizers&lt;/code&gt;中移除一个，直到&lt;code&gt;Finalizers&lt;/code&gt;为空的 Slice，其宿主资源对象才可以被真正的删除。&lt;/p&gt;

&lt;p&gt;对于「删除 owner 但是不删除 dependents」 的需求，k8s 则是实现了一个：orphan finalizer。一般情况下，正常利用 GC 级连删除一个资源对象是不会涉及到 orphan finalizer 的。它执行的是我们之前提到的 GC 的工作逻辑。如果你想启用这个特性，就需要在删除资源对象的时候，根据 K8s 版本的不同，将名为&lt;code&gt;DeleteOption.OrphanDependents&lt;/code&gt;的参数赋值为 True（1.7版本以前）, 或者将&lt;code&gt;DeleteOption.PropagationPolicy&lt;/code&gt;参数赋值为 &lt;code&gt;metav1.DeletePropagationOrphan&lt;/code&gt;：&lt;a href=&#34;https://github.com/kubernetes/apimachinery/blob/9dc1de72c0f3996657ffc88895f89f3844d8cf01/pkg/apis/meta/v1/types.go#L457&#34;&gt;apimachinery/types.go at 9dc1de72c0f3996657ffc88895f89f3844d8cf01 · kubernetes/apimachinery · GitHub&lt;/a&gt;。通过这个参数的注释也可以看出：如果设置好之后，将会在它的 Finalizers 中加入 orphan finalizer。而加入 orphan finalizer 这部分的逻辑是在 api-server 的 package 中：&lt;a href=&#34;https://github.com/kubernetes/apiserver/blob/master/pkg/registry/generic/registry/store.go#L719&#34;&gt;apiserver/store.go at master · kubernetes/apiserver · GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;加入了 orphan finalizer 之后，在 GC 的 worker 从 dirtyQueue 中取出 owner 资源对象进行处理的时候，就会执行它的逻辑：删除 dependents 的 OwnerReference 部分： &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/0972ce1accf859b73abb5a68c0adf4174245d4bf/pkg/controller/garbagecollector/garbagecollector.go#L543&#34;&gt;kubernetes/garbagecollector.go at 0972ce1accf859b73abb5a68c0adf4174245d4bf · kubernetes/kubernetes · GitHub&lt;/a&gt;。最终，在「保留 dependents」 的逻辑完成之后，orphan finalizer 也会从相应资源对象的&lt;code&gt;Finalizers&lt;/code&gt;中删除。&lt;/p&gt;

&lt;h4 id=&#34;一个隐含的-race-问题&#34;&gt;一个隐含的 Race 问题&lt;/h4&gt;

&lt;p&gt;对于 Controller 来说，它会周期性的通过 Selector 来寻找它所创建的资源。如果在筛选到了符合自己 label 的 资源，但是发现它的 Meta.OwnerReference 字段中没有自己相关的信息的时候，就会执行一个 &lt;code&gt;Adoption&lt;/code&gt;的操作，也就是将和自己有关的 OwnerReference 信息注入到这个 Pod 的 Meta 部分。这种逻辑虽然看起来是比较「保险」，但是实际上它和 orphan finalizer 的逻辑是有冲突的。前者是对 dependents 增加 OwnerReference 信息， 后者则是删除它。两个逻辑在执行的时候，如果不保证「互斥」的话，很可能就会出现一个很严重的竞争问题：指定了 orphan finalizer 的 对象，其 dependents 最终也会被删除。&lt;/p&gt;

&lt;p&gt;借鉴操作系统对于「竞争」问题的处理方式，对 OwnerReference操作的的逻辑（即临界区），应该被「互斥」机制保护起来。而在 k8s 中，实现这种互斥保护机制的方式也很简单：Controller 在想执行 Adoption 操作之前，会检查一下当前资源对象的meta.DeletionTimestamp。如果这个字段的值为非 nil，那么就证明这个资源对象已经在被删除中了。所以就不会再继续执行 Adoption 操作。&lt;/p&gt;

&lt;p&gt;但是仔细想一下，这种「互斥」保护机制的实现方式，看起来是借助了一个「锁变量」(meta.DeletionTimestamp)的帮助。不过，我们并不需要担心这个字段的「竞争」问题，因为能修改它的操作，只有「删除」操作，而删除操作是肯定会发生在 orphan finalizer 执行之前的。也就是说，当 orphan finalizer 执行的时候，这个值早就被设置进去了。 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/7f23a743e8c23ac6489340bbb34fa6f1d392db9d/pkg/controller/replicaset/replica_set.go#L644&#34;&gt;kubernetes/replica_set.go at 7f23a743e8c23ac6489340bbb34fa6f1d392db9d · kubernetes/kubernetes · GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;q-how-kubernetes-defines-delete-operation-of-resource-object&#34;&gt;Q: How Kubernetes defines delete operation of resource object?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;K8s 在对资源对象「删除」操作的定义上，思考了一个较为重要的问题：「删除」操作真正完成的标志是什么？（达到什么样的条件才可以通知用户「删除」操作成功）。这个问题出现的源头是在用户侧，当用户在使用 k8s 提供的资源对象的「删除」操作时，有个问题会影响到他们：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;「删除」操作成功多久后才可以在同一个 ns 下创建同名资源对象？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你了解过构建一个 k8s 集群所需要的服务组件，就可以很清楚的知道：k8s 中的资源对象的信息都是存于一个key-value 的数据库当中的（etcd），且是以名字来做索引的。通过命令行&lt;code&gt;kubectl get xxx&lt;/code&gt;查询的资源对象的信息都来自于那。而且，当&lt;code&gt;kubelet&lt;/code&gt;组件删除掉其所在节点上的一些资源的时候，会调用 API-Server 提供的接口删除掉key-value 数据库中相应的记录。所以，在 k8s 中，给「删除」操作下了这样一个定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在没有 orphanFinalizer 参与的前提下，直到被删除对象及其「管辖」对象的信息在 key-value 数据库中都被清除，才认为该对象真正的被 GC 回收。即达到了返回给用户「删除成功」的标准。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本质上来说，上述所表示的删除操作是「同步」的。因为有「级联关系」（owner-dependent） 关系的存在，删除一个资源对象往往影响的不是他自己，还有他的 dependents。只有将因它出现的所有资源都删除，才可以认为这个对象被删除了。&lt;/p&gt;

&lt;p&gt;若想指定这种同步的删除模式，需要在两个不同的位置设置两个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dependents 对象 meta 信息中 OwnerReference.BlockOwnerDeletion&lt;/li&gt;
&lt;li&gt;在发送删除对象请求时，设置 DeleteOptions.PropagationPolicy&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;OwnerReference.BlockOwnerDeletion&lt;/code&gt;参数大多数情况下在相应的 dependents 对象创建的时候就设置进去了。如果想在 dependents 对象创建之后更新这个参数的值，可能需要使用&lt;code&gt;admission controller&lt;/code&gt; (1.7及以上版本)提供的一些权限相关的功能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DeleteOptions.PropagationPolicy&lt;/code&gt;一共有3个候选值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// DeletionPropagation decides if a deletion will propagate to the dependents of
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// the object, and how the garbage collector will handle the propagation.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DeletionPropagation&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Orphans the dependents.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;DeletePropagationOrphan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DeletionPropagation&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Orphan&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Deletes the object from the key-value store, the garbage collector will
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// delete the dependents in the background.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;DeletePropagationBackground&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DeletionPropagation&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Background&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// The object exists in the key-value store until the garbage collector
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// deletes all the dependents whose ownerReference.blockOwnerDeletion=true
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// from the key-value store.  API sever will put the &amp;#34;foregroundDeletion&amp;#34;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// finalizer on the object, and sets its deletionTimestamp.  This policy is
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// cascading, i.e., the dependents will be deleted with Foreground.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;DeletePropagationForeground&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DeletionPropagation&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Foreground&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;再结合&lt;code&gt;OwnerReference.BlockOwnerDeletion&lt;/code&gt; 参数的注释&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// If true, AND if the owner has the &amp;#34;foregroundDeletion&amp;#34; finalizer, then
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// the owner cannot be deleted from the key-value store until this
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// reference is removed.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Defaults to false.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// To set this field, a user needs &amp;#34;delete&amp;#34; permission of the owner,
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// otherwise 422 (Unprocessable Entity) will be returned.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// +optional
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;BlockOwnerDeletion&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;blockOwnerDeletion,omitempty&amp;#34; protobuf:&amp;#34;varint,7,opt,name=blockOwnerDeletion&amp;#34;`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们可以了解到。同步删除的开启方式如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DeleteOptions.PropagationPolicy  =  DeletePropagationForeground&lt;/li&gt;
&lt;li&gt;OwnerReference. BlockOwnerDeletion = True&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开启之后，在删除身份为 owner 的资源对象的时候，就会先将 denpendents 对象中 &lt;code&gt;OwnerReference.BlockOwnerDeletion&lt;/code&gt;为 true 的资源对象先删除，然后再删除 owner 身份的对象。这里的「删除」就指的是我们前面说过的「真正的删除」：从 k8s 存储资源对象信息的 key-value 数据库中删除所有与其相关的信息。需要注意的是，&lt;code&gt;OwnerReference.BlockOwnerDeletion&lt;/code&gt;为 false 的dependent 对象不会阻碍 owner 对象的删除操作。&lt;/p&gt;

&lt;p&gt;Foreground 是 k8s 提供的两种级联删除方式其中之一，另外一种为 Background。通过上面相关的注释可以看到 Foreground 级联删除也是通过 Finalizer 来实现的，查看 Finalizer 相关的定义可知，标准的 Finalizer，一个是 orphan 的，另一个就是Foreground的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// These are internal finalizer values for Kubernetes-like APIs, must be qualified name unless defined here
const (
	FinalizerOrphanDependents string = &amp;#34;orphan&amp;#34;
	FinalizerDeleteDependents string = &amp;#34;foregroundDeletion&amp;#34;
)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;API-Server 的&lt;code&gt;Delete&lt;/code&gt;函数，在接受到删除请求的时候，会检查 &lt;code&gt;DeleteOptions.PropagationPolicy&lt;/code&gt;参数，若其值为&lt;code&gt;DeletePropagationForeground&lt;/code&gt;, API-Server 随即会对该资源对象进行 Update 操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;插入&lt;code&gt;FinalizerDeleteDependents&lt;/code&gt; Finalizer&lt;/li&gt;
&lt;li&gt;设置&lt;code&gt;ObjectMeta.DeletionTimestamp&lt;/code&gt;为当前值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后，在 GC 处理 owner 对象的 Update 事件的逻辑中，还会给 owner 对象打上一个「正在删除 dependents」 对象的标签。之后，我们会将 owner 对象管辖的 dependent 对象和他自己都加入到 dirtyQueue。dirtyQueue 的 worker 在处理 owner 对象的时候，会检查 owner 对象 「正在删除 dependents」的标签是否存在，如果仍有 dependent 对象没有被删掉，owner 会被轮询处理。而 dependent 对象将会被正常删除。当 dependent 对象相应的删除事件被 Propagator 感知到后，会将其从 DAG 和其 owner 的 dependents 信息中删除。几个循环之后，dependents 机会被删光，而 owner 对象中的 finalizer 和自身也会随之被删掉。&lt;/p&gt;

&lt;p&gt;Background 模式的级联删除不会因 dependent 对象而影响 owner 对象的删除操作。当我们发送给 API-Server 删除一个 owner 身份的对象的请求之后，这个资源对象会立即被删除。它「管辖」的 dependent 对象会以「静默」的方式删除。&lt;/p&gt;

&lt;h3 id=&#34;q-what-problems-gc-handles-in-k8s&#34;&gt;Q: What problems GC handles in k8s?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;通过对 k8s GC 设计文档的阅读，可以大致的概括一下：GC 主要是按照用户的需求来清理系统中「异常」的资源，用户可以自定义「清理方式」和「清理策略」。不难发现，在 GC 中，到底是保留一个资源还是删除一个资源都参照了资源之间的「从属关系」。资源的「从属关系」可以大致分为几个形态：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;无从属关系：这部分资源基本不会被 GC 做处理&lt;/li&gt;
&lt;li&gt;有从属关系

&lt;ol&gt;
&lt;li&gt;不符合用户预期：删除异常资源&lt;/li&gt;
&lt;li&gt;符合用户预期：解绑异常资源之间的级联关系&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在有从属关系的资源之间，即使被探测到关系异常，也并不代表一定要将他们都清除。如果有 Orphan Finalizer 的存在，可能某种「异常」正是用户想要的。所以，这就回到了我们一开始所说到的「清理策略」问题。GC 有一定的默认的清理策略，但是用户可以通过加入 Finalizer 的形式来修改「清理策略」，从而保持一个「符合用户期望」的资源之间的从属关系。&lt;/p&gt;

&lt;p&gt;同时，用户可以还可以通过参数来制定特定的「清理方式」，如 Foreground 或者 Background。总体上来说，GC 的行为会受到如下几个因素的影响：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;默认：

&lt;ul&gt;
&lt;li&gt;依据：资源之间默认的从属关系&lt;/li&gt;
&lt;li&gt;行为：删除级联关系异常的资源&lt;/li&gt;
&lt;li&gt;方式：Foreground 或者 Background&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可定制

&lt;ul&gt;
&lt;li&gt;依据：用户定义的从属关系（通过 Finalizer）&lt;/li&gt;
&lt;li&gt;行为：删除级联关系异常的资源&lt;/li&gt;
&lt;li&gt;方式：Foreground 或者 Background&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前看来，GC 主要是解决了「资源清理」 的问题。那么再抽象一点来看的话，GC 解决的是「资源管理」这个大问题中的一个关于「清理」的小问题。既然说到「资源管理」，那么肯定就不止「清理」一个问题需要处理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/34&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中，对于资源的创建部分，除了正常的新建操作之外，controller 还有定期执行一个「Adoption」 的操作，用来维护其创建的资源之间那些「本应该建立但是却断开的从属关系」。而对于更新操作来说，controller_manager 需要处理用户对于资源的扩缩容请求，如将 deployment.replicaset.replicacount 减少或者增大，相应资源对应的 controller 需要对可见资源的数量进行调整。至于「资源超卖」的问题，一定会涉及到 scheduler。因为物理资源是固定的，「超卖」本质上来说就是按照实时的需求，动态的调整服务所在的 Node，以便恰好满足服务对于资源的需求。&lt;/p&gt;

&lt;p&gt;如果不把资源管理问题讨论的范围局限在 k8s 中的话，那么「审计」和「复用」同样也是「资源管理」问题中不得不考虑的两个点。前者可以增加整个系统资源的「可控性」，后者则可以最大限度的提升资源的利用率，从而降低成本。其实「复用」和「超卖」的目的是一样的，都是想最大限度的利用物理资源。不过这两个功能笔者暂时还没有去查看它们是否在 k8s 已经实现。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;之所以去了解 k8s 的 GC，是因为在将 k8s 集群从1.7版本升级至1.9版本的过程中，因为我错误的设置了资源之间的从属关系，导致该资源被 GC 给回收掉了。问题在1.7版本没有出现的原因是那时 k8s 还没有支持对自定义资源（CRD）的级联删除。通过对 GC 设计理念的了解，我们可以初步的感受到 k8s 对于「资源管理」这个问题域中「资源清理」这个小问题的解决思路。以此为起点，我们可以顺藤摸瓜，去观察 k8s 对于「资源管理」问题域中的其他难题是如何处理的。后续，我也将会根据设计文档中的思路，在代码级别上去了解 GC 的实现细节，从而贡献出更加详细的 blog。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Head First AUFS and Docker Image</title>
      <link>http://littledriver.net/post/2018/10/26/head-first-aufs-and-docker-image/</link>
      <pubDate>Fri, 26 Oct 2018 10:13:21 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/10/26/head-first-aufs-and-docker-image/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;WARNING：文中的一些Demo， 均是模仿了陈皓老师在 &lt;a href=&#34;https://coolshell.cn/articles/17061.html&#34;&gt;https://coolshell.cn/articles/17061.html&lt;/a&gt; 文章中给出的实例。在这里只做学习和记录使用，欢迎大家去原文观看，若有版权问题，可联系我删除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;docker-image-和-aufs-是什么关系&#34;&gt;Docker Image 和 AUFS 是什么关系？&lt;/h2&gt;

&lt;p&gt;Image 是 Docker 部署的基本单位，一个 Image 运行在一个 Docker Container 上面。这个 Image 包含了我们的程序文件，以及这个程序依赖的资源的环境。Docker Image 对外是以一个文件的形式展示的（更准确的说是一个 mount 点）。既然说到文件，那么它肯定是受到文件系统来管理的。&lt;/p&gt;

&lt;p&gt;在 Linux 内核 4.0以及之前的版本上（主要是 Ubuntu 和 Debian），Docker 使用 AUFS 来管理 Docker Image 的存储。虽然，在一些新的 Docker 版本中，已经使用了其他不同的方案来管理镜像，如 DeviceMapper，overlay2。但是 AUFS 是一个比较标准且简单的实现方式，通过 AUFS 来了解 Docker Image 的原理是一个不错的选择。&lt;/p&gt;

&lt;h2 id=&#34;什么是-aufs&#34;&gt;什么是 AUFS？&lt;/h2&gt;

&lt;p&gt;AUFS 是 Union File System 众多实现方式的一种。Union File System 从字面意思上来理解就是「联合文件系统」。它将多个物理位置不同的文件目录「联合」起来，挂载到某一个目录下，形成一个抽象的文件系统。&lt;/p&gt;

&lt;p&gt;概念理解起来比较枯燥，最好是有一个真实的例子来帮助我们理解：&lt;/p&gt;

&lt;p&gt;首先，我们建立 company 和 home 两个目录，并且分别为他们创造两个文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# tree .
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;company&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;|--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;   &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;meeting&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;home&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;|--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后我们将通过 mount 命令把 company 和 home 两个目录「联合」起来，建立一个 AUFS 的文件系统，并挂载到当前目录下的 mnt 目录下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;oot&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# mkdir mnt
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# ll
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;total&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;06&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;06&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;company&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;05&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;home&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# mount -t aufs -o dirs=./home:./company none ./mnt
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# ll
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;total&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;06&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;06&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;company&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;home&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drwxr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Oct&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# tree ./mnt/
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;meeting&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;

&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;directories&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;files&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过上述例子最后对 ./mnt 目录结构的输出，可以看到原来两个目录下的内容都被合并到了一个 mnt 这个挂载点下。&lt;/p&gt;

&lt;p&gt;默认情况下，如果我们不对「联合」的目录指定权限，内核将根据从左至右的顺序将第一个目录指定为可读可写的，其余的都为只读。那么，当我们向只读的目录做一些写入操作的话，会发生什么呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# echo apple &amp;gt; ./mnt/code
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# cat company/code
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# cat home/code
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;apple&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过对上面代码段的观察，我们可以看出，当写入操作发生在 company/code 文件时， 对应的修改并没有反映到原始的目录中。而是在 home 目录下又创建了一个名为 code 的文件，并将 apple 写入了进去。&lt;/p&gt;

&lt;p&gt;看起来很奇怪的现象，其实这正是 Union File System 的厉害之处：Union File System 联合了多个不同的目录，并且把他们挂载到一个统一的目录上。在这些「联合」的子目录中， 有一部分是可写的，但是有一部分只是可读的。当你对可读的目录内容做出修改的时候，其结果只会保存到可写的目录下，不会影响只读的目录。比如，我们可以把我们的服务的源代码目录和一个存放代码修改记录的目录「联合」起来构成一个 AUFS。前者设置只读权限，后者设置读写权限。那么，一切对源代码目录下文件的修改都只会影响那个存放修改的目录，不会污染原始的代码。&lt;/p&gt;

&lt;p&gt;上述现象其实是和 AUFS 读写文件的规则有关的。在介绍该规则之前，我们可以先了解一下 AUFS 的目录权限。对于被 AUFS 「联合」的目录来说，在「联合」之后，它们在挂载点下面的目录权限可能有以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rw：可读可写，用户能直接修改这个 branch 的文件内容&lt;/li&gt;
&lt;li&gt;ro：只读，用户不能通过 aufs 的接口对文件进行写操作，只能读取里面的内容&lt;/li&gt;
&lt;li&gt;rr：real read only，底层的文件本来就是只读的（这种情况比较少见），这种情况下，aufs 就不用担心文件不通过它的接口被修改的情况&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下，在被联合的目录中，最左侧的目录为「可读写」。所以在对 AUFS 内的文件进行操作的时候，会遵循如下规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读文件：从最左侧的目录开始寻找，找到第一个符合条件的文件即可&lt;/li&gt;
&lt;li&gt;写文件：从最左侧的目录开始寻找，找到符合条件的文件，若此文件没有可写权限，则将其文件内容复制到最左侧的文件中（更恰当的表示为第一个带有可写权限的文件中），再进行修改&lt;/li&gt;
&lt;li&gt;删除文件：在最左侧的目录下创建一个 whiteout 文件，.wh.&lt;origin_file_name&gt;，就是在原来的文件名字前面加上 .wh.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;这里要注意 AUFS 写文件的规则。在对大小较大的文件进行写入的时候，可能会引发一些性能问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面提到的权限都仅仅是对于「联合」的目录来说的。实际上，我们仍然可以绕过这些目录而去直接更改「源目录」。当这种情况发生的时候，AUFS 所管理的联合目录会对一些修改有相应的反馈么？&lt;/p&gt;

&lt;p&gt;对于这个问题，AUFS 是通过在「联合」目录的时候传递一个特殊的参数来控制的：udba。 udba 一共有三种可能的取值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;none：aufs 不会进行任何数据同步的检查，所以性能会比其他两种方式要高，但是可能会出现数据不一致的情况。&lt;/li&gt;
&lt;li&gt;reval：aufs 会检查底层的文件有没有改动，如果有的话，把改动的内容更新到挂载点。这个性能会导致 aufs 产生额外的性能损耗&lt;/li&gt;
&lt;li&gt;notify：通过 inotify 监听底层的文件变化，基于事件驱动，能够减少第二种方式的性能损耗&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了上面说到的这些，在 AUFS 中还有一个特殊的概念需要提及一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;branch – 各个要被union起来的目录。它会根据 Union 的顺序形成一个 Stack 的结构，从下至上，最上面的目录是可读写的，其余都是可读的&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;什么是-docker-镜像分层机制&#34;&gt;什么是 Docker 镜像分层机制？&lt;/h2&gt;

&lt;p&gt;首先，让我们来看下 Docker Image 中的 Layer 的概念：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Definition of: layer
In an image, a layer is modification to the image, represented by an instruction in the Dockerfile. Layers are applied in sequence to the base image to create the final image. When an image is updated or rebuilt, only layers that change need to be updated, and unchanged layers are cached locally. This is part of why Docker images are so fast and lightweight. The sizes of each layer add up to equal the size of the final image.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说，一个 Image 是通过一个 DockerFile 定义的，然后使用 docker build 命令构建它。DockerFile 中的每一条命令的执行结果都会成为 Image 中的一个 Layer。Docker Image 是有一个层级结构的，最底层的 Layer 为 BaseImage（一般为一个操作系统的 ISO 镜像），然后顺序执行每一条指令，生成的 Layer 按照入栈的顺序逐渐累加，最终形成一个 Image。如果 DockerFile 中的内容没有变动，那么相应的镜像在 build 的时候会复用之前的 layer，以便提升构建效率。并且，即使文件内容有修改，那也只会重新 build 修改的 layer，其他未修改的也仍然会复用。&lt;/p&gt;

&lt;p&gt;通过了解了 Docker Image 的分层机制，我们多多少少能够感觉到，Layer 和 Image 的关系与 AUFS 中的联合目录和挂载点的关系比较相似。而 Docker 也正是通过 AUFS 来管理 Images 的。&lt;/p&gt;

&lt;p&gt;这里，我们通过 Build 一个镜像，来观察 Image 的分层机制：&lt;/p&gt;

&lt;p&gt;Dockerfile:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# Use an official Python runtime as a parent image
FROM python:2.7-slim

# Set the working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD [&amp;#34;python&amp;#34;, &amp;#34;app.py&amp;#34;]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;构建结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xuran&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exampleimage&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# docker build -t hello ./
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sending&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;build&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Docker&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;daemon&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;5.12&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kB&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FROM&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;python&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.7&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slim&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;804&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b0a01ea83&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WORKDIR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d93c5b91703&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;COPY&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;feddc82d321b&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RUN&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pip&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;trusted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;host&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pypi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;python&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;org&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;requirements&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;txt&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;94695&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;df5e14d&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EXPOSE&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;81&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;43&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c392d51dff&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NAME&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;World&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;78&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c9a60237c8&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;python&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;py&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a5ccd4e1b15d&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Successfully&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;built&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a5ccd4e1b15d&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过构建结果可以看出，构建的过程就是执行 Dockerfile 文件中我们写入的命令。构建一共进行了7个步骤，每个步骤进行完都会生成一个随机的 ID，来标识这一 layer 中的内容。 最后一行的 a5ccd4e1b15d 为镜像的 ID。由于我贴上来的构建过程已经是构建了第二次的结果了，所以可以看出，对于没有任何修改的内容，Docker 会复用之前的结果。&lt;/p&gt;

&lt;h2 id=&#34;docker-和-aufs-是如何联系起来的&#34;&gt;Docker 和 AUFS 是如何联系起来的？&lt;/h2&gt;

&lt;p&gt;和 Docker 有关的 AUFS 相关的内容，都在&lt;code&gt;/var/lib/docker/aufs&lt;/code&gt;目录中。其实，AUFS 不仅会帮忙管理 Docker Image，还会帮我们管理运行中的容器。aufs的目录的结构一般如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@rds-k8s-18-svr0:/var/lib/docker/aufs# tree -L 1
.
├── diff
├── layers
└── mnt&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中 diff 存放的是每一个 Image 中 Layers 的内容， 而 layer 目录则是保存的每一个镜像的 layer 的结构信息。mnt 目录下的内容，其实就是一个镜像或者容器运行起来之后，使用的 AUFS 的挂载点。可以认为它就是你在容器内部所看到的文件系统。通过这三个子目录，docker 就能实现镜像的分层存储、容器的 Copy-On-Write 启动。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;docker inspect hello&lt;/code&gt;命令，我们可以看到之前构建的镜像的 Layer 信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;err&#34;&gt;…&lt;/span&gt;
        &lt;span class=&#34;s&#34;&gt;&amp;#34;RootFS&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;s&#34;&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;layers&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;s&#34;&gt;&amp;#34;Layers&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                &lt;span class=&#34;s&#34;&gt;&amp;#34;sha256:237472299760d6726d376385edd9e79c310fe91d794bc9870d038417d448c2d5&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s&#34;&gt;&amp;#34;sha256:9ff579683928293838edf785162e11d7362bdeadd1b91a913d0d777f07a0c14b&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s&#34;&gt;&amp;#34;sha256:473e9a98e4dd51cc459336e2e411eef27ceeb35c4698b2906d1473c155fbb620&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s&#34;&gt;&amp;#34;sha256:639216b11d4ff9961788a9198e663ae74db047fb720049fe1d84f23b5b5dc9d6&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s&#34;&gt;&amp;#34;sha256:c91ccb170b062fc1de577b156c9f16c6923d5a8ab177861e3a4b67aec53e8f13&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s&#34;&gt;&amp;#34;sha256:d2a243c9257f3caa11f31057472b86eeb91ebd4de14c61293cde71823395a187&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s&#34;&gt;&amp;#34;sha256:0c696b8e58cb0ce8528268fdb480f95ec3f005edc39caef6a31c76a8381e6825&amp;#34;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;…&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Dockerfile 中一共有7个命令，所以layer 信息的数量也同样有7个。这个7个 layer，每一个 layer 都对应到 /var/lib/docker/aufs/diff 目录下的一个目录。但是上述代码段中的 sha256 ID 不是直接映射到 /var/lib/docker/aufs/diff 目录下的目录名的，这之间有一个比较复杂的映射关系。（由于这个映射关系比较复杂，且难以描述，所以这里暂不详细叙述。读者也不用过于纠结这里的映射关系，重点在于理解 AUFS 和镜像分层的工作机制）。&lt;/p&gt;

&lt;p&gt;接下来，我们运行一下刚刚构建好的镜像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@rds-k8s-18-svr0:~/xuran/exampleimage# docker run -it hello bash
root@rds-k8s-18-svr0:~# docker ps | grep hello
9d040e5b9999        hello                                                                                                                       &amp;#34;bash&amp;#34;                   7 minutes ago       Up 7 minutes        81/tcp              laughing_northcutt&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过 &lt;code&gt;docker ps&lt;/code&gt;命令，可以看到当前运行的容器进程 ID 为 9d040e5b9999。按照上面所描述的，一个容器启动之后，会在 aufs/mnt 下挂载一个目录 /var/lib/docker/aufs/mnt/755ee5904e25f223a5393cc9202e4daf0ffc9770f67715c966e939eeedf358d4，这个目录就是容器当中看到的文件系统。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/B2452573-13C1-448A-8D8A-956C2AB4061D.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在通过 mount 命令观察系统中的 AUFS 文件系统挂载情况时可以发现，每一条挂载记录后面都跟了一个sid:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;none&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;755&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ee5904e25f223a5393cc9202e4daf0ffc9770f67715c966e939eeedf358d4&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;relatime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;si&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fcff2ee8dd687806&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dirperm1&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;hello 这个容器挂载的 AUFS 的 SID 为 fcff2ee8dd687806。我们将通过这个 ID，可以在 /sys/fs/aufs 的目录下找到对应的 AUFS  的详细信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k8s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;svr0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;si&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fcff2ee8dd687806&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;# cat br[0-9]*
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;755&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ee5904e25f223a5393cc9202e4daf0ffc9770f67715c966e939eeedf358d4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rw&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;755&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ee5904e25f223a5393cc9202e4daf0ffc9770f67715c966e939eeedf358d4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ro&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wh&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;678e5401&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f758378d36dbc6f410c9324f9c5599db498aea5909b83d6a974af446&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ro&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wh&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;81e4703&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c9d06f502774f8fb9af8734ac222af2c4c3aa65813e7bd73ad23f33cb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ro&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wh&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;877&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a44a6fdba1f633b7051b583ee3cc1953dac242cbf8ff2482b59e782fb2c32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ro&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wh&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;309&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ae284b55e1b4d5238ede32dc6fa197982a9f65c34b78c2091b846d9d089d6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ro&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wh&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;83507e141977&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e72a072d7530cb54ee32abff1ade3a8453183a39f3ea48fb4cfe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ro&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wh&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c2e85f6f2e0d67d38f41adafe94c2d82a41247f5dcca690fedad554611c4dc08&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ro&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wh&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aufs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;787977346&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a1c8653b2c535abd156ddf368f7839e385b237d7325177e6ef335a6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ro&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到，不光是 Docker Image 是通过 AUFS 分层来管理的。因为 Image 是容器内文件的提供者，所以自然而然，容器内部的文件系统也需要通过 AUFS 的方式来进行管理。其中最上面的 branch 是允许修改的，它对应着这个容器内部的文件系统目录：&lt;code&gt;/var/lib/docker/aufs/mnt/755ee5904e25f223a5393cc9202e4daf0ffc9770f67715c966e939eeedf358d4&lt;/code&gt;。其余的 branch 都是只读。这就说明，我们在容器当中做的一些修改操作，最后都会反馈到最上面这个目录下：&lt;code&gt;/var/lib/docker/aufs/diff/755ee5904e25f223a5393cc9202e4daf0ffc9770f67715c966e939eeedf358d4&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一个能够反映出容器和镜像分层之间关系的图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/40A21FCD-8D88-491B-920D-AF10ED59E2D5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中下半部分都是镜像的只读 layer，而顶层才是允许在容器内部修改的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Head First Linux Namespace</title>
      <link>http://littledriver.net/post/2018/10/24/head-first-linux-namespace/</link>
      <pubDate>Wed, 24 Oct 2018 16:16:21 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/10/24/head-first-linux-namespace/</guid>
      
        <description>

&lt;h2 id=&#34;什么是-linux-namespace-它解决了什么问题&#34;&gt;什么是 Linux Namespace？它解决了什么问题？&lt;/h2&gt;

&lt;p&gt;简单来说，Linux Namespace 是操作系统内核在不同进程间实现的一种「环境隔离机制」。&lt;/p&gt;

&lt;p&gt;举例来说：现在有两个进程A，B。他们处于两个不同的 PID Namespace 下：ns1, ns2。在ns1下，A 进程的 PID 可以被设置为1，在 ns2 下，B 进程的 PID 也可以设置为1。但是它们两个并不会冲突，因为 Linux PID Namespace 对 PID 这个资源在进程 A，B 之间做了隔离。A 进程在 ns1下是不知道 B 进程在 ns2 下面的 PID 的。&lt;/p&gt;

&lt;p&gt;这种环境隔离机制是实现容器技术的基础。因为在整个操作系统的视角下，一个容器表现出来的就是一个进程。&lt;/p&gt;

&lt;p&gt;Linux 一共构建了 6 种不同的 Namespace，用于不同场景下的隔离：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mount - isolate filesystem mount points&lt;/li&gt;
&lt;li&gt;UTS - isolate hostname and domainname&lt;/li&gt;
&lt;li&gt;IPC - isolate interprocess communication (IPC) resources&lt;/li&gt;
&lt;li&gt;PID - isolate the PID number space&lt;/li&gt;
&lt;li&gt;Network - isolate network interfaces&lt;/li&gt;
&lt;li&gt;User - isolate UID/GID number spaces&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;docker-的网络隔离机制-linux-network-namespace&#34;&gt;Docker 的网络隔离机制——Linux Network Namespace&lt;/h2&gt;

&lt;p&gt;Docker 使用的网络模型是 CNM（Container Network Model），根据官方的设计文档，它的结构大致如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tonybai.com/wp-content/uploads/docker-cnm-model.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CNM 模型一共需要三个组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NetworkSandbox： 在 docker 中的实现对应 Linux Network Namespace&lt;/li&gt;
&lt;li&gt;Endpoint： 在 docker 中的实现对应 VETH （一种虚拟网卡设备）&lt;/li&gt;
&lt;li&gt;Network： 在 docker 中的实现对应 Linux Bridge&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;什么是-veth-什么是-linux-bridge-什么是-linux-network-namespace&#34;&gt;什么是 VETH ？ 什么是 Linux Bridge ？什么是 Linux Network Namespace&lt;/h3&gt;

&lt;p&gt;Linux Bridge 是 Linux 提供的一种虚拟网络设备，它可以实现多个不同容器在一个以太网内进行通信。&lt;/p&gt;

&lt;p&gt;Bridge 默认情况下工作在二层网络，可以在同一网络根据一定的规则过滤和转发以太网包。若给一个 Linux Bridge 设备分配一个 IP 地址，就会开启它的三层工作模式。&lt;/p&gt;

&lt;p&gt;若你在一台安装了 docker 的 Linux 主机上执行 &lt;code&gt;ip addr&lt;/code&gt;命令，就可以看到一个名为 docker0的Linux Bridge。默认情况下在这台宿主机上启动的容器都会链接到这个 Bridge 上。因为是在同一个网络下，且通过 Bridge 链接在一起，所以不同的容器之间可以进行网络通信。否则，不同的容器之间会因为链接的 Bridge 不同而产生网络隔离。&lt;/p&gt;

&lt;p&gt;VETH 也是 Linux 提供的一种网络设备，它在行为上类似操作系统的 Pipe。因为 VETH 总是成对出现，一端为输入端，一端为输出端。每一个 VETH 设备都可以被赋予一个 IP 地址，然后参与三层网络通信的过程。&lt;/p&gt;

&lt;p&gt;Linux Network Namespace 是 Linux 提供的在不同进程之间的一种网络环境隔离机制。这里可以简单的理解为，每一个进程在自己的 NS 下，都独享了一套完整的网络环境（与宿主机对比）。特定 NS 内的网络环境对外部来说是不可见的，并且在其中对一些网络设置做修改也不会影响到外部（如路由规则）。&lt;/p&gt;

&lt;p&gt;若只考虑两个容器在宿主机上面的网络模型，它的结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tonybai.com/wp-content/uploads/linux-network-namespaces-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;docker-的-hostname-隔离机制-linux-uts-namespace&#34;&gt;Docker 的 Hostname 隔离机制——Linux UTS Namespace&lt;/h2&gt;

&lt;p&gt;简单来说，这是 Linux 提供的一种针对多个进程间的 Hostname 的隔离机制。它允许一个进程在其内部设置自己的 hostname。让我们通过一个例子来了解：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;下面的实例来自于陈皓老师的博客（https://coolshell.cn/articles/17010.html），感谢陈皓老师的文章
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define _GNU_SOURCE
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sched.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt; 
&lt;span class=&#34;cm&#34;&gt;/* 定义一个给 clone 用的栈，栈大小1M */&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define STACK_SIZE (1024 * 1024)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;container_stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;STACK_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
 
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;container_args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;/bin/bash&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;container_main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Container - inside the container!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sethostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;container&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* 设置hostname */&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;execv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;container_args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;container_args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Something&amp;#39;s wrong!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
 
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent - start a container!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;container_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;container_main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;container_stack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;STACK_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
            &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CLONE_NEWUTS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SIGCHLD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*启用CLONE_NEWUTS Namespace隔离 */&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;container_pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent - container stopped!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面的例程是通过创建一个子进程的方式来测试 Linux UTS Namespace 提供的隔离机制。其中被双星号标记的两行代码是比较关键的部分:  &lt;code&gt;CLONE_NEWUTS&lt;/code&gt; 是启动 Hostname 隔离机制的一个系统调用参数，当以这个参数创建进程的时候，就会开启隔离。&lt;code&gt;sethostname&lt;/code&gt;同样是一个系统的调用，它在自己进程内部设置了单独的 Hostname，且不会影响到宿主机。反之，如果没有上面的两行代码的话，子进程中的 Hostname 和宿主机应该是一致的。&lt;/p&gt;

&lt;h2 id=&#34;docker-的-ipc-隔离机制-linux-ipc-namespace&#34;&gt;Docker 的 IPC 隔离机制——Linux IPC Namespace&lt;/h2&gt;

&lt;p&gt;Linux 在实现进程间通信时用了以下几种方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些结构在被创建出来的时候，都会在全局范围内有一个唯一的 ID。所以，如果想要在单独的进程空间中，有一套自己的 IPC 标识并且对宿主机环境屏蔽，这就是 Linux 的  IPC 隔离机制。 IPC Namespace 的实现其实和 UTS 是差不多的：在创建进程的时候加入&lt;code&gt;CLONE_NEWIPC&lt;/code&gt;标志即可。&lt;/p&gt;

&lt;p&gt;当子进程和父进程都被创建之后，在子进程中通过&lt;code&gt;ipcmk -Q&lt;/code&gt;命令创建的消息队列不会在宿主机上被发现，而在宿主机上创建的也不会被子进程发现。&lt;/p&gt;

&lt;h2 id=&#34;docker-的-mount-隔离机制-linux-mount-namespace&#34;&gt;Docker 的 Mount 隔离机制——Linux Mount Namespace&lt;/h2&gt;

&lt;p&gt;Linux Mount Namespace 实现了在不同进程间对于文件系统「挂载点」的隔离机制。每一个进程所持有的挂载点信息都 可以在 /proc/&lt;pid&gt;mounts 和 /proc/&lt;pid&gt;mountinfo 和 /proc/&lt;pid&gt;mountstats 中找到。/proc 是 Linux 提供的一种虚拟文件系统。此目录下保存的文件和目录信息描述了该操作系统一些运行时的信息。我们既可以通过改变目录下的一些内容来影响操作系统运行的结果，也可以查询该目录下的信息以便获得当前操作系统的运行情况。/proc 目录下的东西并不是真的文件和目录，它实际上是存在于内存中的。&lt;/p&gt;

&lt;p&gt;如果想开启这种隔离机制，需要在创建子进程的时候使用&lt;code&gt;CLONE_NEWNS&lt;/code&gt;参数。默认情况下，子进程的挂载点信息一般都是从父进程的 mount namespace 下拷贝的。但是在子进程创建完成之后，两者之间的 mount namespace 以及相应的挂载点信息就没有任何关系了。在子进程中对挂载点信息的操作是不会影响到父进程的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PS: 这里一定要提醒读者的是，Linux Mount Namespace 提供的仅仅是对「挂载点」的隔离，并不是对文件系统的隔离。事实上，即使是在已经建立了Mount Namespace 隔离的两个进程中执行 mount/umount 操作也同样会影响到宿主机的文件系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;docker-的-pid-隔离机制-linux-pid-namespace&#34;&gt;Docker 的 PID 隔离机制——Linux PID Namespace&lt;/h2&gt;

&lt;p&gt;在众多 Linux 中的进程中，有一个进程是比较特殊的：init 进程（PID 为1）。它是操作系统内核初始化后第一个启动的进程，也是整个操作系统范围内的父进程，即祖先进程。之后所有的进程都是从它派生而来。最终形成一个具有层级结构的进程树。Init 进程有很多特殊的权限，如屏蔽一些信号或检查它派生的进程的状态。Init 进程在检查到一些孤儿进程的时候，会对他们进行回收。&lt;/p&gt;

&lt;p&gt;如果能做到 PID 在容器内外部也是隔离的，那么在容器内部看起来进程就好像运行在了一个单独的操作系统中。特定容器内部或者说特定进程空间下的 PID 是可以和宿主机的 PID 取值相同的，并且不会发生冲突。以此类推，若进程和容器内部也有一个PID 为1的进程，它将会独立的管理其创建出的子进程。&lt;/p&gt;

&lt;h2 id=&#34;docker-的-user-隔离机制-linux-user-namespace&#34;&gt;Docker 的 User 隔离机制——Linux User Namespace&lt;/h2&gt;

&lt;p&gt;Linux User Namespace 提供的隔离机制允许多个不同的进程间各有自己独立的一套 UID/GID 体系，并且可以将进程内部的 UID/GID 与宿主机的 UID/GID 进行映射。开启这个隔离机制的方法也很简单：在创建子进程的时候传入&lt;code&gt;CLONE_NEWUSER&lt;/code&gt;参数即可。至于 UID/GID 的映射，可以在&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/uid_map&lt;/code&gt; 和 &lt;code&gt;/proc/&amp;lt;pid&amp;gt;/gid_map&lt;/code&gt; 两个文件中，按照 &lt;code&gt;ID-inside-ns ID-outside-ns length&lt;/code&gt;的形式写入映射记录。&lt;/p&gt;

&lt;p&gt;这里有一个实现进程间「安全机制」的 Case，是通过 Linux User Namespace 来实现的:&lt;/p&gt;

&lt;p&gt;在创建子进程的时候，父进程通过对&lt;code&gt;/proc/&amp;lt;子进程pid&amp;gt;/uid_map&lt;/code&gt; 和 &lt;code&gt;/proc/&amp;lt;子进程pid&amp;gt;/gid_map&lt;/code&gt; 两个文件的写入，将子进程的PID 映射为子进程内部值为0的 uid 和 gid。子进程启动的时候，会因为我们设置了 uid 为0，从而自动切换到 root 用户。这样一来，我们就实现了使用一般用户创建子进程，但是在子进程的内部确是以 root 用户的身份来运行的效果。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;到此为止，Linux Namespace 的隔离机制就全部介绍完了。它是容器技术中「隔离机制」的基础。其实对于这些隔离机制来说，如果想理解透彻，还是要仔细琢磨 Namespace 的概念。这个概念在很多编程语言中都有出现。如果从最简单的字面意思上来理解的话，它就是一个名字空间。不同空间中可以有同一个标识，但是同一个空间中不能出现两个同样的标识。而上面所提到的 PID，Hostname，UID/GID 等等其实本质上都是一种名字的隔离，只有 Network 的部分比较特殊。尤其是在理解 Mount 隔离机制的时候，一定不要忘记一点：我们所做的一切操作都是在宿主机的文件系统上的，隔离的仅仅只是挂载点的记录而已。&lt;/p&gt;

&lt;p&gt;Linux Namespace 的隔离，说到底还是一个逻辑上的概念，它不能切断任何进程和操作系统的链接，所以再怎么隔离是也不彻底的。不同容器或者说进程依赖的都是操作系统的资源，稍有不慎，一些操作还是会影响宿主机系统的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Deep into the process and thread 2</title>
      <link>http://littledriver.net/post/2018/10/21/deep-into-the-process-and-thread-2/</link>
      <pubDate>Sun, 21 Oct 2018 18:23:07 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/10/21/deep-into-the-process-and-thread-2/</guid>
      
        <description>

&lt;p&gt;&lt;strong&gt;Q： 为什么都说「进程切换」是个比较昂贵的操作，它昂贵在哪呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，就是由用户态向内核态的切换。因为我们需要保存旧的进程的状态。其次，我们可能需要执行一个比较复杂的「调度算法」，挑选出一个合适的候选进程。除此之外，每一次进程的切换都会伴随着 CPU 高速缓存的失效。在新的进程被切换到 CPU 上开始运行之后，高速缓存需要从内存中动态装入一些和新的进程运行有关的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q:  在什么情况下需要进行进程的调度（切换）？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进程切换发生的时候是必然会进行进程调度的，因为此时 CPU 空闲，需要让新的进程在上面运行。那么，什么场景下会发生进程间的切换呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CPU 时间片消耗完：这种场景是较为普通和正常的，操作系统为了让所有的进程都能够得到 CPU 的资源，只分配每个进程一定的 CPU 时间片，当时间片消耗完后，进程正常退出，就需要调度新的进程上来。&lt;/li&gt;
&lt;li&gt;I/O 中断触发：当一个进程因触发 I / O 活动而阻塞之后，若相应的 I / O 设备完成了所需的任务，会向 CPU 发送 I / O 中断。此时，需要决定到底调度那类进程运行：阻塞之后满足条件的，随机的就绪进程，刚刚在运行的进程（被中断打断）&lt;/li&gt;
&lt;li&gt;触发阻塞条件：一个进程可能会执行一些会阻塞自身的操作：如阻塞的系统调用，等待某一个资源的释放。此时，操作系统会将另外一个就绪的进程切换上来。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般来说，一个进程的在运行期间过多的是在 CPU 上进行计算，那么它被认为「计算密集型」的。反之，如果大多数时间都消耗在了 I_O 等待上，那么它被认为是「I / O密集型」的。对于当前的 CPU 和 I_O 设备来说，我们可能需要的问题可能更多的和 I / O密集型的进程有关。因为 CPU 的发展速度是远大于 I / O 设备的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: 什么是调度算法？都分为哪几种？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;调度算法是一种规则，调度程序依据它来调度进程到 CPU 上运行。调度算法可以大致分为两大类：1. 抢占式调度  2. 非抢占式调度。其实我们平常所说的「CPU 时间片消耗光，进程从 CPU 被切换下来」，指的就是抢占式调度。抢占式调度一般会规定一个时钟周期，当一个时钟周期结束之后，触发时钟中断，将控制权交给调度程序（scheduler），它会根据一定的规则挑选一个可运行的进程。而非抢占式调度则不会主动进行进程间的切换，除非进程自己进入阻塞状态或者它自己让出 CPU。否则，即使一个进程因中断导致暂时停止运行，在中断被处理掉之后，它仍然会在 CPU 上继续运行，而不会被切换。&lt;/p&gt;

&lt;p&gt;所以，对于非抢占调度和抢占调度来说，它们唯一的区别，就是对中断的处理（时间中断或者其他事件类的中断）。除了通过「处理中断的方式」将调度算法分为两类之外，我们还可以根据调度算法所适配的系统将其分为三类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用于批处理系统的&lt;/li&gt;
&lt;li&gt;用于交互式系统的&lt;/li&gt;
&lt;li&gt;用于实时系统的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于不同的系统，在设计调度算法的时候会有不同的考量。比如批处理系统，基本不会在意终端用户的感受，只要保证批处理任务顺利进行即可。所以，非抢占或者说长时间才抢占的两种调度算法它都能接受。而对于交互式系统来说，抢占是必须要有的，因为它更加的通用，且要保证终端用户的感受。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: 调度算法的设计目标是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;若不考虑特定类型的系统，有以下三个较为通用的目标：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;公平性：保证可调度的进程都有机会在 CPU 上执行&lt;/li&gt;
&lt;li&gt;抢占性：必须要有一定的措施可以响应「抢占性」的调度请求&lt;/li&gt;
&lt;li&gt;平衡性：能够在现有的条件下，最大程度的提升 CPU 的使用率&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Q: 对于批处理系统，有哪些调度算法？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;先来先服务&#34;&gt;先来先服务&lt;/h5&gt;

&lt;p&gt;先来先服务是最好理解的一种调度算法。因为它实在是太符合人们「顺序处理」事情的习惯了，以至于我怀疑它能称得上是一种算法么。先来先服务将待执行的进程放入一个类似单链表的数据结构中，按照从头至尾的顺序运行。若一个进程被阻塞，则切换至另外一个进程。若阻塞的进程被重新唤醒，那么它将被加入到链表尾部，等待运行。&lt;/p&gt;

&lt;h5 id=&#34;最短作业优先-最短剩余时间优先&#34;&gt;最短作业优先 &amp;amp;&amp;amp; 最短剩余时间优先&lt;/h5&gt;

&lt;p&gt;将这两种调度算法放在一起说的原因是：两个算法的顺利执行都依赖于我们必须要事先知道每个进程的运行时间。&lt;/p&gt;

&lt;p&gt;对于最短作业优先算法来说，我们可以考虑这样一个例子：现在有 A， B， C， D 四个进程，四个进程的运行时间分别为 5, 4, 4, 3。 按照正常的顺序，四个进程顺序执行花费的总时间为 5+（4+5）+ （4+5+4）+（3+4+4+5）= 43， 平均时间为 10。如果将例子中具体的数值换为变量，四个进程运行的时间分别为 a, b, c, d, 则总时间为 a + (a+b) + (a+b+c) + (a +b+c+d) = 4a + 3b + 2c +d, 平均时间为 a+ 3/4b + 1/2c + 1/4d。 仔细观察就会发现，在运行总时间不变的情况下，按照对平均时间最终取值的影响程度从大到小排序， a 是影响最大的一个，bcd 依次降低。那么如果我们将 a, b, c, d 的取值按照从小到大来安排，最终的平均运行时间就是最优的。&lt;/p&gt;

&lt;p&gt;但是最短作业优先算法的一个致命缺陷就是它不能动态的调整进程执行的顺序，因为它是一个非抢占式调度的算法。所以，最短剩余时间优先算法就在它的基础上做了改进：若有新的进程进入就绪队列的时候，对比它的执行时间和当前进程剩余的时间大小，选择较小的一个调度至 CPU 运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: 对于交互式系统，有哪些调度算法？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;轮转调度&#34;&gt;轮转调度&lt;/h5&gt;

&lt;p&gt;轮转调度就是我们常说的 round robin 的形式，它维护一个就绪进程的队列，分配给每个进程一个时间片，若某个进程在时间片内被阻塞，则 CPU 会进行进程切换，从就绪队列选取下一个顺位的进程调度上来。此外，若在规定的时间片内，某个进程一直在运行。当时间片被消耗完的时候，CPU 也会进行上述的切换动作&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于这里的抢占行为，笔者觉得应该是通过中断来完成的。如周期性的时钟中断实现的抢占可以保证一个进程不会占用 CPU 太久，而一些事件类的中断如 I / O 中断，将通过给 CPU 发送中断信号的形式来通知它进行处理，此时调度程序也将获得机会，根据已有的策略来运行一个就绪的进程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;轮转调度的实现是比较简单的，但是它也有一个不好控制的地方：时间片的长度。如果时间片长度设置的过长，可能对于短时任务的进程就不是很友好，甚至会出现饥饿的现象。如果时间片设置的太短，那么进程间切换的开销也会消耗相当多的 CPU 资源（保存和恢复进程状态，更新各种表格，清除并重新载入高速缓存）。&lt;/p&gt;

&lt;h5 id=&#34;优先级调度&#34;&gt;优先级调度&lt;/h5&gt;

&lt;p&gt;轮转调度的设计是处在一个特定的前提下的：就绪队列中的每个进程优先级都是相同的。但是很多时候，在一个操作系统中有一部分进程是比较重要的，需要优先来运行，有一部分进程是次要的，可以缓一些时间再运行。基于这种考虑，操作系统给出了名为「优先级调度」的调度算法。&lt;/p&gt;

&lt;p&gt;既然是以优先级为调度，那么自然要将进程分类。为此，一种可能的实现是：按照优先级的划分设置多个就绪进程的队列。将不同优先级的进程放入到相应的队列中。比如， 对于 I / O 密集型的进程我们应该尽快分配给他 CPU，以便它能够尽快的进入 I / O 等待的状态，从而能够和其他进程并行执行。所以它的优先级就会被指定的比较高。那么在同一个优先级的队列中我们应该按照什么样的算法去弹出进程呢？答案当然是「轮转调度」，因为轮转调度本身就是为了优先级相同的进程提供的一种较为公平的调度算法。&lt;/p&gt;

&lt;p&gt;在优先级调度算法中，我们通常会按照优先级从高到低的顺序处理就绪队列中的进程，如先把高优先级队列中的进程调度完，然后再处理次优先级的。但是有一点需要注意，进程的优先级不仅仅需要在创建时就指定，在之后的运行过程中要能有动态调整的能力，不然的话，有些低优先级的进程可能会被饿死。&lt;/p&gt;

&lt;h5 id=&#34;最短进程优先&#34;&gt;最短进程优先&lt;/h5&gt;

&lt;p&gt;这里的最短进程优先算法是借鉴了批处理系统中最短作业优先算法。通过上面的描述我们可以知道，最短进程优先优先在交互式系统中比较难以把控的就是进程的运行时间。因为终端用户有权利运行多样的进程，操作系统不可能像批处理系统一样，在任务没执行之前就准确的估计了任务的执行时间。但是，在交互式系统中，我们可以动态的估计一个进程剩余的运行时间，从而将这个「预估时间」作为依据进行进程调度，这种技术叫做「老化」。如一个进程第一次执行时间为t0,第二次为t1, 通过计算加权和的方式可以估计出它下一次的运行时间为 a*t0 + (1-a) * t1。而加权系数的选择决定了在计算进程运行时间的过程中，想要多快忘记它之前的运行时间。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Deep into the process and thread</title>
      <link>http://littledriver.net/post/2018/10/19/deep-into-the-process-and-thread/</link>
      <pubDate>Fri, 19 Oct 2018 21:08:03 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/10/19/deep-into-the-process-and-thread/</guid>
      
        <description>&lt;p&gt;&lt;em&gt;Q: 什么是进程？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;进程其实是一个比较抽象的概念，它是用来描述多道程序设计系统中的一个工作单元。单纯的给进程下一个定义是没有任何意义的。比如现在所谓的标准答案：进程是操作系统中运行的程序。对于进程，我们更多的要理解它是一个「复合体」，它是一系列活动的组合。它是一个逻辑上的概念，并不是一个现实世界中具体的事物。这一点和 k8s 中的 pod很像。所以，我更倾向于将进程理解为操作系统中的一个复杂且基本的工作单元。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 子进程被创建之后和父进程是如何隔离的？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;通常情况下，在 Linux 系统当中，一旦子进程被创建，那么子进程和父进程就会分别占有两块独立的地址空间。相互之间是隔离的，并且可以通过一些方式来进行通信或者共享某些资源。但是，在之后操作系统发展的过程当中，对于父子进程的创建过程可能会有一些优化，而不仅仅是粗暴的将父进程地址空间中所有的东西都 copy 一份给子进程。这里也是有一个比较重要的机制：COW（写时复制机制）。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: Linux 中的进程和 Windows 中有哪些不同？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Linux 系统中的进程是有严格的「父子关系」的，并且所有的进程会以树形的层次结构组织起来。其中祖先进程可认为是 Init，它是进程树中的根。而 Windows 中的进程，无论父子，都是靠一个叫做「句柄」的概念对一个进程进行标识的，并且这个句柄是可以传递的。所以在 Windows 中，进程间没有严格的父子关系。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 什么是线程？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;线程是轻量级的进程。进程由操作系统来管理而线程由进程来管理。不同进程之间的地址空间是隔离的，但是不同线程之间的地址空间是共享的。一般来说，一个进程通常会有一个主线程，进程负责向内核申请线程运行所需要的资源和环境，而线程才是真正执行程序的单位。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 有了进程为什么还需要线程？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;从程序性能的角度来说，很多程序在一个进程中都会做很多任务。这些任务可以大致的被划分为两类，一类是 I/O, 一类是计算。I/O 通常消耗的时间会比较长，对于只有主线程的进程来说，它会一直处于等待状态，内核分配给他的 CPU 时间片也会被白白的消耗。计算类的任务则会直接消耗 CPU 资源，最大限度的利用了已分配的时间片。所以，如果一个程序中同时包含这两类任务的话，计算类的任务很可能被 I/O 类的任务阻塞，最终导致整个程序的效率下降。因为线程是存在于进程的地址空间中的，如果可以在进程地址空间中创建多个线程，并且让这些线程重叠执行，分别去运行不同类型的任务，就可以在一定的 CPU 时间片内，将程序的效率尽可能的提高。通过上面的一些思考，我们甚至可以延伸出另外一个问题：多线程技术一定会对我们的程序产生积极的影响么？其实也不尽然。如果我们的程序中既包含大量的 I/O 操作，也包含大量的计算操作，那么多线程技术是可以提升我们程序的效率的。因为此时由于多个线程重叠的进行，最大限度的利用了 CPU 的时间片。如果我们的程序基本都是计算类的任务，很少有 I/O 操作，那么多线程的引入可能不会对提升程序的效率有太大的帮助。因为即使线程间的切换消耗再小，还是有 CPU 时间片上面的损耗的。同样，这个问题的思考方式还可以延伸到：多进程技术一定会对我们的程序有积极的影响么？&lt;/p&gt;

&lt;p&gt;从资源共享的角度来说，不同进程间的地址是不同的，所以它们在共享一些资源的时候就会比较麻烦，可能需要借助第三方的东西，比如文件。然而对于同一个进程中的不同的线程来说，这种内存上的隔离是不存在的，它们可以很方便的去共享一些资源。看到这里你可能会说，在地址空间不隔离的条件下，多个线程对同一个资源可能会出现竞争的想象。对于这个问题，我们要明确两点：首先，线程间共享资源的初衷是让多个线程合作，而不是让它们竞争。其次，如果不可避免的发生了竞争，也可以通过一些互斥的机制来解决。&lt;/p&gt;

&lt;p&gt;最后还要提及一点的就是，大多数操作系统对于多线程的实现都是在「用户态」下，且线程中维护的必要信息会较进程少很多。这就造成了线程是比进程更轻量级的。如果不可避免的发生频繁和切换操作，那么很明显线程在这种场景下会更具优势。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 进程和线程之间的关系是什么？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;进程更倾向于从操作系统申请资源，并对这些资源进行统一的管理，提供一个良好的运行环境。线程则更注重利用已经分配好的资源运行程序。也就是说，实际上在 CPU 上调度执行的并不是进程而是线程。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 如何实现线程？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;实现线程有两种思路：在用户态实现 or 在内核态实现。&lt;/p&gt;

&lt;p&gt;当我们想在用户态实现「线程」的时候，就意味着「线程」或者说是「多线程」对于内核来讲应该是透明的。内核与具有单个控制线程的主进程还是按照原来的模式运行（进程模型）。所以，我们很自然的就能够想到，在用户态下需要一系列「过程」的集合来实现和线程有关的操作以及「多线程」技术。这个「过程」的集合可以被称作为是一种 Runtime 系统。&lt;/p&gt;

&lt;p&gt;用户态 Runtime 系统的数和进程数成正比。每一个进程中都有一个 Runtime 去管理进程中的多个线程。它负责线程的创建，销毁。同时也要负责维护一张「线程表」，用于保存进程内部线程的运行状态。更重要的是，这个 Runtime 系统需要借助「线程表」进行线程间的切换，因为同一时刻只有一个线程可以获得 CPU 的时间片。其实，这样看起来，Runtime 运行的方式很像一个有限状态机。它将进程内的线程的状态保存至「线程表」中，当一个线程被调度到 CPU 上执行的时候，Runtime 就需要在线程表中读取和这个线程有关的信息；当一个线程要被调度离开 CPU 的时候，同样需要 Runtime 将此时的状态保存到线程表中，以便下一次复原运行的上下文环境。如果再类比一下进程和操作系统内核的关系就可以得知，用轻量级的进程来描述线程，真的是再合适不过了。&lt;/p&gt;

&lt;p&gt;对于线程间的切换来说，它和进程间的切换的实现有所不同。进程间的切换，要不就是依靠中断机制，强行将进程从 CPU 上拿下来；要不就是等到该进程的 CPU 时间片被消耗完，调度系统切换新的进程上来。由于我们现在是在用户态实现线程，操作系统内核无法干预线程的相关操作。所以，我们需要在 Runtime 中实现一个过程，这个过程在调用之后可以主动的将 CPU 时间片让给其他处于就绪态的线程。这也就是 POSIX 线程标准中定义的 Pthread_yield 所要实现的功能。&lt;/p&gt;

&lt;p&gt;在用户态实现 Runtime 的好处其实很明显：1. 之前看起来比较复杂的操作，如线程间的切换，都是在用户态下完成的，不需要内核的参与，所以肯定要比内核实现的版本效率要高 2. 由于这个 Runtime 是我们自己来实现的，所以它的可定制性是非常强的。我们甚至可以开发出自己的一套「线程调度策略」来保证我们的程序效率最大化。&lt;/p&gt;

&lt;p&gt;在用户态实现 Runtime 的坏处其实都可以归结到一个问题上：阻塞，它既包括线程之间的阻塞也包括线程所在进程的阻塞。线程间的阻塞是指：当一个线程想要进行一些阻塞操作的时候，比如从键盘读取输入信息。如果让这个阻塞操作进行了且它所需要的条件一直没有被满足，那么该进程中其他可运行的线程在这一个 CPU 时间片上就没有机会再被运行了。这其实是不符合「多线程」技术发明的初衷的。进程的阻塞是指：当一个线程执行了一些阻塞系统调用的时候，不仅仅是其他的线程没有运行的机会了，整个进程都会因为进入阻塞态而被调离 CPU。这是一个非常严重的事情。而触发这种问题的 Case 也很常见：缺页中断（线程所需要的数据或者代码没有在内存页中找到而是在硬盘中）。此外，由于多线程间只能够通过主动调用 Pthread_yield 过程来实现切换操作，如果你的代码写的有 bug 的话，其他的线程就会处于「饥饿」或者「饿死」的状态。&lt;/p&gt;

&lt;p&gt;内核态实现的 Runtime 系统的数量不再随着进程数的变化而变化。事实上，如果真的把线程拿到内核态来实现的话，线程和进程基本就没什么区别了。线程会和进程一样，在内核中有一个线程表，用来维护线程的运行情况。通过对比之前在用户态实现线程的缺点可以知道，如果将所有阻塞线程的调用全都以系统调用的形式来实现的话，线程间的切换就统一由内核来进行管理，它会选取一个合适的线程继续使用剩余的 CPU 时间片。这种阻塞调用既包括线程之间的阻塞也包括阻塞的系统调用。&lt;/p&gt;

&lt;p&gt;虽然说，内核态实现 Runtime 开销比较大的问题是不可避免的。但是仍然可以做出一些优化，比如在线程的销毁操作上，如果一个线程需要被销毁，内核可以不进行真正的销毁操作，而是打上一个空闲线程的标记，并且由它统一管理。这样如果有线程创建需求的时候，有可以直接复用之前已经分配的资源。&lt;/p&gt;

&lt;p&gt;很显然，内核态实现 Runtime 也是有很多缺点的。其中最被大家诟病的就是「开销」变大了。这个开销不仅仅是指时间上面的，还包括空间上面的。如：线程的数量一般都是要比进程多的，所以线程表的规模的增长速度会远远大于进程表。当规模大起来之后如何保证一个高效的读取和写入操作呢？毕竟引入线程和多线程相关概念的初衷是在合适的场景下能够提升程序的效率而不是拉低。&lt;/p&gt;

&lt;p&gt;既然两者各有优劣，那么根据操作系统的一贯思想，就是最大化的将这两个方案的优点结合起来，产出一个普适性更强的方案：调度程序激活机制。它借助了用户态 Runtime 系统的优势：高效的进行线程间的切换。同时，在用户态下模拟「内核」线程的功能，防止因线程使用阻塞的系统调用而发生进程的切换。&lt;/p&gt;

&lt;p&gt;调度程序激活机制启用后，内核会为每一个进程分配一个或多个的虚拟 CPU，用户态 Runtime 系统可以将线程分配到这些虚拟的 CPU 上。虚拟 CPU 代表这个进程可以使用的 CPU 核心数。当一个线程被同进程的另外一个线程所阻塞，它会被用户态 Runtime 系统处理，并调度新的进程运行。此时，不会发生用户态和内核态的切换，对于内核来说，这些操作都是透明的。当一个线程被进程之外的因素阻塞住时（阻塞的系统调用，缺页终端），内核会感知到这个问题，它会通知用户态 Runtime 系统，需要重新调度一个就绪的线程运行。而当阻塞的事件被完成的时候，内核也会将这个事件通知给用户态 Runtime 系统，让它自己来决定，下一步应该调度哪个线程运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/E5F7EC18-D476-44B5-844B-90E7F62E7F04.png&#34; alt=&#34;http://o6sfmikvw.bkt.clouddn.com/E5F7EC18-D476-44B5-844B-90E7F62E7F04.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这种内核调用用户态 Runtime 系统的机制被称作为「上行调用」。在CPU中用户空间为上层，内核为下层层，常规调用应该是上层调用下层，下层不应该调用上层，上行调用就是指内核调用用户空间的 Runtime 系统。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 如何实现进程间的通信？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;两个进程或者线程间如果要进行通信，可能涉及到以下三个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何传递信息？&lt;/li&gt;
&lt;li&gt;如何防止「竞争」？&lt;/li&gt;
&lt;li&gt;如何保证进/线程间执行的顺序？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Q: 如何防止「竞争」？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们首先来看下如何在进程间通信过程中避免「竞争」的问题。「竞争」通常出现在两个进程或者线程同时要访问/修改一个共享资源的时候，除了同时读取可能还不会有问题之外，比如一读一写，两个都是写这种组合是肯定会引起资源的「竞争」的。这种「同时操作共享资源」的结果，完全取决于两个竞争者之间执行的时序。但是我们都清楚，在编程的世界中，是不能够对「时序」做任何假设的，因为它的随机性较大，很多「竞争」问题之所以难以 track，就是因为它出现的几率不固定，很难定位。&lt;/p&gt;

&lt;p&gt;那现在问题就变成了：如何在使用共享资源的时候，同一时间只允许一个进程对其操作。这种行为有一个比较统一和抽象的称呼：「互斥」。而产生「竞争」问题的地方或者说要进行「互斥」改造的地方，我们统一把它成为「临界区」。「临界区」是一段操作共享资源的代码，如果能保证同一时间只有一个进程进入「临界区」，那么「竞争」的问题也就随之解决了。&lt;/p&gt;

&lt;p&gt;第一种可实现互斥机制的技术是：屏蔽中断。这应该是最暴力的一种方式了，而且更多的是对于进程间「竞争」问题的解决方案。当一个进程进入临界区后，可以屏蔽所有的中断。此时， CPU 不会再切换进程，已经处在临界区的进程也不会受到影响，它可以放心的操作「共享资源」。但是这种方案的缺点也很明显：1. 进程一旦运行异常很可能从临界区中退不出来，一直不能切换其他进程  2.  在多 CPU 的情形下，除非把所有 CPU 都 disable 掉，否则还是有其他的 CPU 可以调度运行与其「竞争」的进程。&lt;/p&gt;

&lt;p&gt;第二种是在软件层面的方案： 锁变量。进临界区之前查看是否可以获得锁，离开临界区之后释放锁。「获得」和「释放」的操作通过修改某一个变量实现。但是，这其实并没有什么卵用，在 CPU 可以对进程进行任意切换的前提下，锁变量就变成了另外一个「共享资源」。如：在 A 进程进入临界区获得锁之后想更改锁状态时发生了进程间切换，那么 B 进程此时仍然可以获得锁进入临界区，最终的结果就是，A 和 B 都认为自己拿到了这个锁，都进入了临界区。究其原因，还是因为没有保证进程之间对于共享资源操作的顺序性。&lt;/p&gt;

&lt;p&gt;第三种是利用「忙等待」的原理：利用一个全局变量实现两个进程间的同步，保证执行顺序。如，设置一个共享变量 turn，初始值为0。A 进程将通过一个 while 循环检查turn，当其值为0的时候进入临界区，出临界区的时候将其改为1。B 进程将通过一个 while 循环检查 turn，当其值为1的时候进入临界区，出临界区的时候将其改为0。利用这种机制就实现了两个进程严格的「同步」，轮换进入临界区。但是，这种实现有一个Edege Case 没有考虑到，如果两个进程执行的速度相差过大，就会导致速度较快的进程在离开临界区之后，一直在等待速度较慢的进程先进入临界区。此时，速度较快的进程在 CPU 时间片内执行一个死循环，浪费了 CPU 资源，而且最终执行的效率看起来已经完全取决于速度较慢的进程到底有多慢。&lt;/p&gt;

&lt;p&gt;第四种则是在「忙等待」的基础上进行了一些改进，由原来的不断访问锁变量，查看是否可以进入临界区的方式变为：当访问锁变量不能进入临界区的时候就进入睡眠状态，将自身阻塞在临界区外。直到从临界区出来的进程唤醒它。这种方式的本质是实现了一对「同步原语」：Sleep/Wake。不过它的缺陷和使用锁变量是类似的：使用同步原语之前还是需要去访问一个共享变量来决定是否执行 Sleep or Wake。如果在「访问共享变量」和「执行 Sleep 原语」之间发生了进程间的切换，那么很有可能在另外一个进程从临界区出来之后执行 Wake，但是之前被切换的进程因没有执行 Sleep，并没有收到这个信号，从而导致了 Wake 消息丢失的问题。等到下一次它重新获得 CPU 时间片的时候，会将自己Sleep，最终它将无法进入临界区。&lt;/p&gt;

&lt;p&gt;讨论到现在为止，其实有一部分问题都已经解决了，比如：如何实现互斥，如何避免忙等待给系统带来的消耗。唯一一个还没有办法解决的其实就是对共享变量的「互斥访问」问题。而互斥访问这个东西，基本上在用户态下是不太可能做到的，因为内核才是大 Boss，他想把你调离 CPU 那你就是没机会再进行下去了。所以，借鉴上面第一种方案的思路，我们需要借助「屏蔽中断」这一特性来实现共享变量的「互斥访问」。这就必须要提及「信号量」的概念了。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 什么是信号量？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;信号量是一个新的名字，它本质上其实就是我们之前所说的在睡眠和唤醒进程前访问的共享变量。之所以改了一个新的名字，是因为信号量附加的相关操作是通过系统调用+屏蔽中断来实现的，它可以保证将之前讨论的一些可能发生「竞争」的操作实现为一个原子操作。&lt;/p&gt;

&lt;p&gt;信号量是一个整型的变量，它的取值范围为[0, +无穷]，在当前的场景下，它的数值代表了还有多少进程处于睡眠状态中并等待被唤醒。它以系统调用的方式实现了两个操作：Up， Down。Up 操作为唤醒操作，Down 操作即为 Sleep 操作。它的工作机制大致是这样的：&lt;/p&gt;

&lt;p&gt;对于 Down 操作来说，它在操作一个信号量之前会检查它是否大于0，如果大于0，则对信号量进行-1，然后进行剩余的操作；如果等于0，那么将进程睡眠，但是此时 Down 操作还并没有结束，因为它还没有将被它阻塞的进程顺利的送出去。检查，修改，以及后续的操作（睡眠 or 继续）三者是作为一个原子性的操作来处理的。&lt;/p&gt;

&lt;p&gt;对于 Up 操作来说，由于信号量的取值范围是到正无穷的，所以它在对信号量进行+1操作之前是不需要检查相应的值的。信号量一旦执行了Up 操作，就说明此时可以唤醒一个睡眠的进程执行了，而睡眠的进程在被唤醒的时候会使用 Down 操作对信号量-1，这样一增一减也就平衡了。所以，增加信号量的值，唤醒一个进程，两个步骤若被实现为一个原子操作，即可称作是一个 Up 操作。&lt;/p&gt;

&lt;p&gt;上面所说的，基本上是依靠信号量实现了「互斥」的功能，从而可以解决进程之间的「竞争」问题。实际上，由于信号量是一个整型变量，它的取值范围比较大，所以可以利用它的计数功能实现进程间的「同步」，从而保证多进程的执行顺序。所以，对于生产者和消费者模型来说，如何在保证互斥的同时又保证了两者的执行顺序，信号量的使用起到了至关重要的作用。&lt;/p&gt;

&lt;p&gt;信号量的出现极大的丰富了我们处理「互斥」和「同步」问题的方式。若你想解决「竞争」，则可以使用一个仅有「解锁，锁住」两种语义的信号量，我们通常称他为「互斥量」。「互斥量」的作用仅限于避免「临界区」同时多有个进程或者线程进入。若你想解决「同步问题」，则可以使用一个仅有「计数」语义的信号量。「计数量」的作用是在具有依赖关系的两个进程或线程中传递「计数信号」，当「计数量」的值未达到某个进程运行条件时，该进程就会被阻塞，反之会顺利的进行。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 「互斥」+ 「条件」的另一种实现方式是什么？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;了解到目前为止，我们大致可以归纳出操作系统在处理「互斥」和「同步」的问题上究竟依赖的是什么思想了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;互斥：通过某种实现，锁住临界区，防止临界区内同一时间被多个进线程访问&lt;/li&gt;
&lt;li&gt;同步：通过某种实现，在进线程间建立一种「通知」机制，可以按照一定的条件「睡眠」和「唤醒」某个进线程。「通知」机制的运行需要互斥的保护&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实，实现「同步」一种比较简单的方式就是利用我们上面所说的信号量，而且这个信号量还有存储信号的功能，不会怕信号丢失。同步和互斥一般都是在一起使用的：互斥用于锁住临界区，同步用于保证执行顺序。但是在运用他们的时候，请一定要掌握好它们之间语义的差别：互斥作用于进程已经可以执行但是执行过程中受阻，同步作用于进程是否可以执行。这么说可能比较迷惑，我们来看下面一个例子（利用信号量解决生产者、消费者问题）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;m_mux&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 互斥信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_num_empty&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 缓冲区空闲位置个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_num_full&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 缓冲区有数据的位置个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 缓冲区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;producer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
	 &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_num_empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 缓冲区是否已满，可以生产消息
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	 &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 是否可进入临界区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 生产消息
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 离开临界区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	 &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_num_full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 增加有数据的位置个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;comsumer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
	 &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_num_full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 缓冲区是否还有数据，可以消费
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	 &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 是否可进入临界区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 生产消息
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 离开临界区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	 &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m_num_empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 增加空闲的位置个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以目前的状态，上面这个例子运行起来是没有什么问题的。但是如果我们把同步和互斥的语义搞错，粗心一点将down 操作全部颠倒顺序就可能会发生死锁：当 m_mux 在减小 m_num_empty 信号前就被-1且缓冲区已经满了的时候，生产者将会被阻塞，但是此时生产者已经没有机会在释放互斥量了。而消费者会因为被互斥量阻塞的原因无法进入临界区消费，从而不能对m_num_empty信号量执行 up 操作环境生产者。这是一个标准的死锁的例子，它像我们说明了一个事实：在使用同步和互斥的时候要注意对信号量的操作顺序，否则会引起灾难。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 什么是管程？什么是条件变量？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;管程是一种高级的同步原语，它是编程语言的组成部分。管程是「互斥」和「同步」的结合体。其中「互斥」部分仍然由「互斥量」实现，但是它由编译器进行操作。使用管程的人只需要将临界区的代码注入到一个管程中，而不用关注它是怎么实现的。而「同步」的部分，则是通过一个叫做「条件变量」的东西来实现的。条件变量是一种功能单一的信号量。它只负责实现「同步」。条件变量通常还伴随着一个过程的集合，其中它的 Wait 操作的实现是比较有意思的：Wait 操作在发现当前进程因某些条件不满足不能继续执行下去的时候，除了将当前的进程阻塞，还会将另外一个合适的进程调入到管程中来。并且在执行完 Wait 操作之前，不会被任何中断打断，从而引起竞争，因为管程帮我们做了「互斥」的保护。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;其实笔者对于「条件变量」和「信号量」的区别也不是特别清楚，总觉得条件变量是信号量的一个 Special Case。因为条件变量能做的东西，信号量也一样可以做。所以，在这篇文章中，我们姑且就按照这样来理解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Q: 通过信号量实现的「互斥」和「同步」在哪些场景下会有缺陷呢？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;使用信号量实现「互斥」和「同步」有一个比较大的限制：通过将共享变量放在共享内存，并且通过 TSL 等指令来保护这些变量的操作，以避免竞争。但是，当在一个由多个操作系统组成的分布式系统中，每个 CPU 都有自己的私有内存，且还可以通过网络互连，那么信号量的保护机制就将失效了。看起来，信号量并不能解决处于不同机器之间的进程的通信问题。&lt;/p&gt;

&lt;p&gt;所以，操作系统又实现了两个新的原语：Send &amp;amp;&amp;amp; Receive。 通过字面的意思就可以看出，这是一种通过消息传递的方式来实现「互斥」和「同步」的。共享变量在通信双方的机器上都需要被「互斥」机制保护，这一点在单机上实现起来应该是比较简单的。发送进程可以调用 Send 原语发送信息，而接受进程可以调用 Receive 源于来接受消息。至于「阻塞」和「唤醒」则可以通过网络在双端传输共享变量来实现：如生产者进程在启动时调用 Receive  等待消费者向他传递缓冲区的空闲情况，因为它还不知道现在的情况是否可以传递消息，所以会进入阻塞状态。消费者在启动后，先调用 Send 将缓冲区的空闲情况发送给生产者，然后再调用 Receive 等待接受消息。生产者收到消息后会查看缓冲区的情况，如果确认可以发送，则调用 Send 向消费者发送消息。 在执行了一个循环之后，整个通信流程就变成了以下几个步骤重复执行：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生产者发送完消息被阻塞&lt;/li&gt;
&lt;li&gt;消费者接受并消费消息&lt;/li&gt;
&lt;li&gt;消费者发送缓冲区空闲情况&lt;/li&gt;
&lt;li&gt;消费者等待消息被阻塞&lt;/li&gt;
&lt;li&gt;生产者接受到和缓冲区空闲情况有关的消息&lt;/li&gt;
&lt;li&gt;生产者生产消息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Q: 如果需要「同步」机制的不是一个进程而是一个进程组，我们需要怎么办呢？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;信号量，管程都是针对于两个进程间通讯所遇到的问题的解决方案。但是，当同步机制作用于进程组的时候，问题似乎更加抽象了。如，现在一共有八个进程为一组。这里的同步是指，无论执行的速率，只有等到进程组内所有的进程都执行完了某一阶段逻辑，它们才能够继续向下运行。&lt;/p&gt;

&lt;p&gt;所以，操作系统专门为进程组的同步创建了一个原语：屏障（barrier）。它也是通过一个系统调用来实现的，且最终操作的肯定还是一个进程组内多个进程共享的变量。以上面的进程组为例来描述一下屏障的工作机制：进程组中的每一个进程在执行完它自己的第一阶段逻辑之后都会调用 barrier 原语，此时，如果该进程不是进程组中最后一个执行完毕的进程，那么它会被挂起，直到最后一个进程执行完且调用了 barrier 原语之后，所有的进程才会被释放去执行第二阶段的逻辑。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Head First SDS in Redis</title>
      <link>http://littledriver.net/post/2018/10/14/head-first-sds-in-redis/</link>
      <pubDate>Sun, 14 Oct 2018 18:37:32 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/10/14/head-first-sds-in-redis/</guid>
      
        <description>

&lt;h1 id=&#34;redis-设计与实现之动态字符串&#34;&gt;Redis 设计与实现之动态字符串&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Q: 什么是 SDS&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;SDS 是 Redis 在实现过程中使用的一种「动态字符串」。由于 Redis 的代码基本都是通过 C 语言来实现的，所以 SDS 在最底层还是依赖于&lt;code&gt;char buf[]&lt;/code&gt;来存储数据。SDS 对象的数据结构大致如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/211A932F-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出，SDS 结构体成员中有三个属性：len，free，buf。其中 len 标识一个 SDS 对象管理的字符串有效字符是多少个，而 free 则代表这个 SDS 在不扩充空间的前提下还可以存储多少个有效字符，buf 则是一个&lt;code&gt;char[]&lt;/code&gt;类型的指针，它指向一段连续的内存空间，这里才是真正存储字符串的地方（有效字符串是指除\0以外的字符串集合）。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 有了 C 字符串，为什么还需要 SDS？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;通过阅读相关数据以及对 Redis 文档的查阅，可以总结出以下几点使用 SDS 而不适用原生 C 字符串的好处&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;    * 更高效的获取一个 SDS 对象内保存的字符串的长度
    * 杜绝缓冲区溢出
    * 减少因字符串的修改导致的频繁分配和回收内存空间操作
    * 二进制安全
    * 和 C 语言有关字符串的库函数有一个更高的兼容性&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其实看到这里，如果你之前使用其他语言中的「普通数组」实现过一个「动态数组」的话，那么除了「二进制安全」这一条好处可能不太理解之外，其余的应该都比较熟悉。下面我们就来分别说一下这几个好处。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 如何更高效的获取字符串的长度？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这个问题在传统的 C 字符串中算是一个痛点。在一个线性的数据结构中，我们都只能通过遍历这个数据结构中所有的有效元素才能够获取它准确的长度，这个操作的时间复杂度是 O(N) 级别。但是当我们只是把 C 字符串作为 SDS 这个数据结构中的一个成员时，我们就可以通过增加另外一个成员&lt;code&gt;len&lt;/code&gt;来实时的计算字符串的准确长度。计算的方式也很简单，就是在字符串做「新增元素」的操作时对&lt;code&gt;len&lt;/code&gt;+1，做「减少元素」的操作时对&lt;code&gt;len&lt;/code&gt;-1。这样一来，就可以通过访问&lt;code&gt;len&lt;/code&gt;来获取 SDS 内存储的字符串的长度。类似于这样的实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sub&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Q: 如何杜绝缓冲区溢出？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;缓冲区溢出换成另外一种更加直白的说法：篡改了内存中本不属于你的空间中的数据。这种现象在字符串拼接以及字符串的新增字符的操作中比较常见。处理这种问题的办法也很简单：在内存容量允许的情况下，当一个字符串需要更多的内存空间的时候，重新分配1块「更大」的连续空间，将原来空间中的有效数据 copy 过去。其中，检测是否超出剩余空间，完全可以使用&lt;code&gt;free&lt;/code&gt;属性的值，因为它代表了数组中现在还有多少可用的空间。
如果你认真的阅读了上一段的内容，就可以发现，在防止缓冲区溢出的过程中有几个「丑陋」的步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可能多次在内存中分配一段连续的空间&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可能多次将原来空间中的有效数据 copy 到新的空间中&lt;/li&gt;
&lt;li&gt;分配出去的空间如果没有回收，一直在持续分配，可能会出现内存泄漏
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;针对于新出现的问题，我们采取了以下办法来解决：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按照一定的策略分配新的内存空间，尽量减少分配次数&lt;/li&gt;
&lt;li&gt;当空闲空间达到一定阈值的时候，回收多余的内存空间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Redis 中，通过两个步骤来确定「预分配」空间的大小：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果修改之后的字符串长度（len）小于1MB，除了分配必要的空间之外，还需要分配大小等同于&lt;code&gt;len&lt;/code&gt;的空闲空间。例如，修改之后的字符串长度为10（len=10）,那么在修改之后，新的内存空间大小为=10+10+1=21。&lt;/li&gt;
&lt;li&gt;如果修改之后的字符串长度（len） 大于1MB，除了分配必要的空间之外，还需要分配大小等同于1MB的空闲空间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 SDS 相关的修改操作中，会先对可用空间和实际所需要的空间进行对比，若超出，则会分配新的空间，否则使用旧的空间。通过上面的策略，基本上可以把「重新分配内存空间」和「将原来空间中的有效数据 copy 到新的空间中 」的次数由每次必定发生，降低到最多发生 N 次（N 为修改操作进行的次数）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里插入一个笔者小的心得：很多程序员在解决问题的时候都倾向于找到一个完美的解决方案，若是笔者的话，可能在看到这个问题的时候也会想，能否有一个完美的办法来解决上面的问题。但是，我们可以看到，在 Redis 这种工业级的项目中，它采取的方案仍然是很普通的，甚至是我们平时做练习就会用到的「实现」。一个看似「延迟让风险发生」的办法，有的时候就是最「完美」的办法。程序员更多的应该关注如何解决问题，而不是如何「完美」的解决问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了通过分配「预留空间」的方式来减少「分配」操作的次数之外，我们还担心的一点就是，如果一直无限制的进行分配，那么内存终有耗尽的时候。这就是我们常说的内存泄漏问题。想解决它也很简单，就是按照一定的策略回收已经分配的内存空间。比如：当一个 SDS 绑定的内存空间的使用量已经低于25%，那么我们就将它的内存空间缩小为原来的一半。至于为什么只缩小原来的一般而不是全部将空余空间回收，仔细思考一下就知道，如果回收的方式过于极端，那么就将「预分配」空间的优势全部抹杀了（增加内存分配的次数）。&lt;/p&gt;

&lt;p&gt;所以，在 SDS 相关的修改（主要是删除元素）操作中，不会立刻对空闲的空间进行回收，而是将它们作为「预留空间」。为了防止「内存泄漏」，Redis 提供了专门的 API，真正的对内存空间进行释放。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: 如何保证 SDS 是二进制安全的？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;「二进制安全」听起来是个比较陌生的词，但是如果你综合了 C 语言字符串的特点和二进制内容的特点就可以知道，二进制安全主要是防止它的内容中出现像&lt;code&gt;\0&lt;/code&gt;这种特殊字符，干扰了对原字符串的正确解释。听起来比较高大上的问题，往往解决它的方案都是比较简单的。在 Redis 中，为了保证「二进制安全」，不在使用 C 语言字符串的&lt;code&gt;\0&lt;/code&gt;字符作为其所存储的字符串的边界，而是使用&lt;code&gt;len&lt;/code&gt; 这个属性，标识字符串中有效字符的个数。&lt;/p&gt;

&lt;p&gt;虽然，为了保证「二进制安全」我们可以无视 C 语言字符串以&lt;code&gt;\0&lt;/code&gt;作为字符串结尾的事实。但是，多数情况下大家还是会使用 Redis 储存「文本信息」（符合 C 语言字符串规则的，内容中不含有&lt;code&gt;\0&lt;/code&gt;）。此时，对他们的操作可能要依赖于 C 语言和字符串相关的库函数，所以，在 SDS 的实现中会保持这样两个惯例：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;给字符串分配内存空间时会考虑多分配1byte 的空间给&lt;code&gt;\0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在修改字符串内容的时候，都会在最后追加一个&lt;code&gt;\0&lt;/code&gt;字符&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>How to Deploy Jaeger Cluster</title>
      <link>http://littledriver.net/post/2018/09/26/how-to-deploy-jaeger-cluster/</link>
      <pubDate>Wed, 26 Sep 2018 17:58:57 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/09/26/how-to-deploy-jaeger-cluster/</guid>
      
        <description>

&lt;h1 id=&#34;deploy-jaeger-in-kubernetes&#34;&gt;Deploy Jaeger in Kubernetes&lt;/h1&gt;

&lt;h2 id=&#34;preparation&#34;&gt;Preparation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://www.jaegertracing.io/img/architecture.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过一张 Jaeger 的架构图，我们可以知道，要在我们的开发环境中部署一套Jaeger，需要部署以下几个组件&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;jaeger-agent&lt;/li&gt;
&lt;li&gt;jaeger-collector&lt;/li&gt;
&lt;li&gt;data-storage

&lt;ol&gt;
&lt;li&gt;Elasticsearch&lt;/li&gt;
&lt;li&gt;Cassandra&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于我们想将 jaeger 部署到 k8s 集群中，针对于这个特定的部署环境，我们可以对部署方案做如下的梳理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;部署方式： helm+jaeger 的 chart 包（参考：&lt;a href=&#34;https://github.com/jaegertracing/jaeger-kubernetes&#34;&gt;https://github.com/jaegertracing/jaeger-kubernetes&lt;/a&gt;, &lt;a href=&#34;https://github.com/helm/charts/tree/master/incubator/jaeger）&#34;&gt;https://github.com/helm/charts/tree/master/incubator/jaeger）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;存储中间件：helm + ElasticSearch 的 chart 包（参考：&lt;a href=&#34;https://github.com/helm/charts/tree/master/incubator/elasticsearch）&#34;&gt;https://github.com/helm/charts/tree/master/incubator/elasticsearch）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;底层存储方案：宿主机外挂500G 数据盘+ Ceph RBD&lt;/li&gt;
&lt;li&gt;访问：ingress+nginx—ingress-controller+service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过对&lt;a href=&#34;https://github.com/jaegertracing/jaeger-kubernetes&#34;&gt;GitHub - jaegertracing/jaeger-kubernetes: Support for deploying Jaeger into Kubernetes&lt;/a&gt;的了解，我们可以知道，其实 jaeger 本身的组件部署时比较简单的，直接 kubectl applpy 一个编排文件即可搞定。唯一比较麻烦的是对底层存储的配置。针对这样的情况，我们决定将 jaeger 部署的顺序做如下安排：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;准备一个 k8s 集群（笔者有一个一主一从的 k8s 集群，基于虚拟机建立的），主从节点各挂在一块500G 的数据盘&lt;/li&gt;
&lt;li&gt;Ceph RBD 集群和 k8s 混布（╮(╯▽╰)╭，没办法，穷啊），创建需要分配存储的测试 pod，查看 pvc 和 pv 的创建情况&lt;/li&gt;
&lt;li&gt;部署 Elasticsearch&lt;/li&gt;
&lt;li&gt;部署 Jaeger，测试集群内部是否能够成功访问 jaeger-query&lt;/li&gt;
&lt;li&gt;部署 ingress+nginx-ingress-controller，测试集群外部访问情况&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;本文默认用户已经部署好了 k8s 集群并且挂载了数据盘，因为 k8s 的部署步骤也比较复杂，足以写另外一篇文章了。而且对于挂载磁盘的问题来说，用户所处平台的不同（云主机，物理机，本地的虚拟机）可能处理的方式也不太一样。这两部分在本文中就不做过多的描述了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;部署-ceph-rbd-集群&#34;&gt;部署 Ceph RBD 集群&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Ref: &lt;a href=&#34;https://tonybai.com/2016/11/07/integrate-kubernetes-with-ceph-rbd/&#34;&gt;https://tonybai.com/2016/11/07/integrate-kubernetes-with-ceph-rbd/&lt;/a&gt; （感谢作者）&lt;br /&gt;
部署 ceph 的部分，都是借鉴作者的经验，这里只是做一个记录，帮自己梳理部署的步骤。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个 Ceph RBD 集群可以大致分为三个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deploy Node：部署节点，相当于 k8s 集群中的 Master 节点&lt;/li&gt;
&lt;li&gt;OSD Node： 存储节点&lt;/li&gt;
&lt;li&gt;MON Node： 监控节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，我们需要安装 ceph 官方提供的部署工具： ceph-deploy。由于 k8s 集群所在 Node 的系统是 Ubuntu，所以这里使用 apt-get 来安装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/debian-jewel
export CEPH_DEPLOY_GPG_URL=http://mirrors.163.com/ceph/keys/release.asc
（使用国内的镜像，速度会快一点）
将 deb https://mirrors.163.com/ceph/debian-jewel/ xenial main 写入到 /etc/apt/sources.list 中
apt-get update	
apt-get install ceph-deploy&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;为了方便起见，我们给安装 ceph 创建一个具有 root 权限的专门的 user&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;以下命令在每个Node上都要执行：

useradd -d /home/cephd -m cephd
passwd cephd

添加sudo权限：
echo &amp;#34;cephd ALL = (root) NOPASSWD:ALL&amp;#34; | sudo tee /etc/sudoers.d/cephd
sudo chmod 0440 /etc/sudoers.d/cephd&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;将不同 Node 上面的 ssh public key 相互拷贝到 &lt;code&gt;~/.ssh_authorized_keys&lt;/code&gt; 文件中，且在 &lt;code&gt;~/.ssh_config&lt;/code&gt; 中配置好使用 cephd 账户登录到其他机器上面的捷径。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Host xr-service-mesh-lab
   Hostname xr-service-mesh-lab
   User cephd
Host xr-service-mesh-lab1
   Hostname xr-service-mesh-lab1
   User cephd&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果你之前在当前集群安装过 ceph，可以运行如下命令清理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;ceph-deploy purge xr-service-mesh-lab xr-service-mesh-lab1
ceph-deploy forgetkeys
ceph-deploy purgedata xr-service-mesh-lab xr-service-mesh-lab1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在集群的任意节点中，选取一个作为 deploy node，以 cephd 账户登录。在该节点上执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ceph-deploy new xr-service-mesh-lab(nodeName)```&#34; data-lang=&#34;ceph-deploy new xr-service-mesh-lab(nodeName)```&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ceph-deploy new xr-service-mesh-lab(nodeName)```&#34; data-lang=&#34;ceph-deploy new xr-service-mesh-lab(nodeName)```&#34;&gt;将该节点同时作为 monitor 节点。执行了该命令之后，我们可以发现，在当前目录下会自动生成一些文件，这些文件是在之后的部署过程中会用到的。

编辑 `ceph.conf`文件，在末尾添加几行内容：&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;osd pool default size = 2 (该参数可以根据自己搭建的 ceph 集群的 osd 节点的个数修改)
osd max object name len = 256
osd max object namespace len = 64&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;接下来，执行

```ceph-deploy install xr-service-mesh-lab xr-service-mesh-lab1```

命令，在两个节点上安装好部署 ceph 集群所需要的 binary。

在 mon-node 上（如果你没有切换过节点操作的话，就是当前的 node，也是 deploy-node），进行初始化操作 

```ceph-deploy mon create-initial```

执行完毕后，会在当前目录下观察到很多以 .keyring 后缀结尾的文件。之后，可以运行

 ```ps aux | grep ceph```
 
 命令，查看 ceph-mon 进程已经运行。

截止目前，对于这个 ceph 集群，我们还有 osd 节点没有部署。osd 节点的部署分为两部分：prepare, activate

### Prepare

&amp;gt; 执行这一步之前，最好是在 Node 上都挂载好了专用的数据盘，否则，只能是创建一个目录，使用「系统盘」的空间。笔者在部署的时候，在两个节点的_mnt目录下分别挂在了两块500G 的 数据盘，并且在这两块盘上分别创建了两个目录： /mnt/osd0 /mnt/osd1  

在 deploy-node 上执行如下命令：`ceph-deploy osd prepare xr-service-mesh-lab:/mnt/osd0 xr-service-mesh-lab1:/mnt/osd1`

### Activate

在 deploy-node 上执行如下命令：`ceph-deploy osd activate xr-service-mesh-lab:/mnt/osd0 xr-service-mesh-lab1:/mnt/osd1`
若发现如如下报错信息：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;[WARNIN] 2016-11-04 14:25:40.325075 7fd1aa73f800 -1  ** ERROR: error creating empty object store in /mnt/osd0: (13) Permission denied&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;进一步查看 `/mnt/osd0`目录权限信息：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;drwxr-sr-x 2 root root 4096 Nov  4 14:25 osd0&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;可以发现该目录的 user 和 group 都是 root，且除了创建者之外其余的 user 是没有 w 权限的，这也就解释了上面，创建目录因权限问题失败的现象。
再次观察执行 activate 命令输出的日志，可以发现：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip; &amp;hellip;
[xr-service-mesh-lab][WARNIN] got monmap epoch 1
[xr-service-mesh-lab][WARNIN] command: Running command: /usr/bin/timeout 300 ceph-osd &amp;ndash;cluster ceph &amp;ndash;mkfs &amp;ndash;mkkey -i 0 &amp;ndash;monmap /mnt/osd0/activate.monmap &amp;ndash;osd-data /mnt/osd0 &amp;ndash;osd-journal /mnt/osd0/journal &amp;ndash;osd-uuid 6def4f7f-4f37-43a5-8699-5c6ab608c89c &amp;ndash;keyring /var/mnt/keyring &amp;ndash;setuser cephd &amp;ndash;setgroup cephd&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;我们在 Node 上启动 ceph-osd 进程使用的都是名为 cephd 的 user 和 group。所以，要处理这个问题，可以手动对 Node 上对应的目录使用`chown -R cephd:cephd &amp;lt;dir&amp;gt;`命令，更改目录权限。修复完成后可以重新执行 activate 命令，正常情况下会顺利通过。

### Ceph rbd Cluster State

 ceph 集群 activate 成功之后，可以在 deploy-node 上使用两个命令来查看集群的健康情况：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;$ ceph osd tree&lt;/p&gt;

&lt;p&gt;ID WEIGHT  TYPE NAME                     UP/DOWN REWEIGHT PRIMARY-AFFINITY
-1 0.49959 root default
-2 0.01909     host xr-service-mesh-lab
 0 0.01909         osd.0                      up  1.00000          1.00000
-3 0.48050     host xr-service-mesh-lab1
 1 0.48050         osd.1                      up  1.00000          1.00000&lt;/p&gt;

&lt;p&gt;$ ceps -s&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;cluster d38afe19-16bd-40f1-b1e4-4249471d656c
 health HEALTH_OK
 monmap e1: 1 mons at {xr-service-mesh-lab=172.20.6.29:6789/0}
        election epoch 3, quorum 0 xr-service-mesh-lab
 osdmap e10: 2 osds: 2 up, 2 in; 10 remapped pgs
        flags sortbitwise,require_jewel_osds
  pgmap v31: 64 pgs, 1 pools, 0 bytes data, 0 objects
        11934 MB used, 473 GB / 511 GB avail
              54 active+clean
              10 active&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;可以看到，两个 osd 节点目前都是正常的

### Cooperate with kubernetes

在部署了 ceph 集群之后，要想在 kubernetes 中通过 ceph 使用集群中的存储资源，还需要一个「桥梁」，它就是 Storage Class。Storage Class 究竟是什么，以及我们要如何构造一个 Storage Class。可以看下另外一篇文章，对 Storage Class 有一个基本的了解：[notion-of-pv-and-pvc](http://localhost:1313/posts/notion-of-pv-and-pvc/)。

要想创建 ceph rbd 的 Storage Class，根据如下链接所给出的步骤操作即可：[https://github.com/kubernetes-incubator/external-storage/tree/master/ceph/rbd](https://github.com/kubernetes-incubator/external-storage/tree/master/ceph/rbd)

### Create pod with pv on ceph

在按照上面的步骤创建好了 ceph rbd 集群以及对应的 Storage Class 资源对象之后，就可以通过创建一个使用了存储资源的 Pod 来测试我们的 ceph rbd 集群是否工作正常。

首先，我们创建一个 PVC，在 ceph rbd 集群上申请一定量的存储资源：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: claim1
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: rbd
  resources:
    requests:
      storage: 1Gi&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;其次，创建一个 Pod，并且通过挂载的方式，在容器内使用我们刚刚申请的存储资源：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;kind: Pod
apiVersion: v1
metadata:
  name: test-pod
spec:
  containers:
  - name: test-pod
    image: gcr.io/google_containers/busybox:1.24
    command:
    - &amp;ldquo;/bin/sh&amp;rdquo;
    args:
    - &amp;ldquo;-c&amp;rdquo;
    - &amp;ldquo;touch /mnt/SUCCESS &amp;amp;&amp;amp; exit 0 || exit 1&amp;rdquo;
    volumeMounts:
    - name: pvc
      mountPath: &amp;ldquo;/mnt&amp;rdquo;
  restartPolicy: &amp;ldquo;Never&amp;rdquo;
  volumes:
  - name: pvc
    persistentVolumeClaim:
      claimName: claim1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;最终，我们可以看到 PV 成功的被创建：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;root@xr-service-mesh-lab:~/external-storage/ceph/rbd# kubectl -n xuran get pv pvc-556fbe5a-c074-11e8-a174-fa163eebca40 -o yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  annotations:
    pv.kubernetes.io/provisioned-by: ceph.com/rbd
    rbdProvisionerIdentity: ceph.com/rbd
  creationTimestamp: 2018-09-25T03:37:38Z
  finalizers:
  - kubernetes.io/pv-protection
  name: pvc-556fbe5a-c074-11e8-a174-fa163eebca40
  resourceVersion: &amp;ldquo;2755796&amp;rdquo;
  selfLink: /api/v1/persistentvolumes/pvc-556fbe5a-c074-11e8-a174-fa163eebca40
  uid: 59406bdb-c074-11e8-a174-fa163eebca40
spec:
  accessModes:
  - ReadWriteOnce
  capacity:
    storage: 1Gi
  claimRef:
    apiVersion: v1
    kind: PersistentVolumeClaim
    name: claim1
    namespace: xuran
    resourceVersion: &amp;ldquo;2755787&amp;rdquo;
    uid: 556fbe5a-c074-11e8-a174-fa163eebca40
  persistentVolumeReclaimPolicy: Delete
  rbd:
    image: kubernetes-dynamic-pvc-59252351-c074-11e8-9c73-dab2986e8f3a
    keyring: /etc/ceph/keyring
    monitors:
    - 172.20.6.29:6789
    pool: kube
    secretRef:
      name: ceph-secret
      namespace: kube-system
    user: kube
  storageClassName: rbd
status:
  phase: Bound&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;## 部署 ElasticSearch
在部署 elasticsearch 的时候，我们将参考 elasticsearch Chart 中的编排文件：[https://github.com/helm/charts/tree/master/incubator/elasticsearch](https://github.com/helm/charts/tree/master/incubator/elasticsearch)。它将帮助我们搭建一个含有三个 master 节点，两个 client 节点	，两个 data 节点的 elasticsearch 集群。

在部署之前，对于上述编排文件，唯一需要改正的就是 elasticsearch 依赖的 storageclass。对此，我们可以使用`helm template`命令，对 storageclass 的相关参数进行修改，并且最终导出到一个 yaml 文件中，方便我们后续部署.

首先，我们需要下载相应的 chart 包，然后执行如下命令：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;helm template elasticsearch &amp;ndash;name jaeger-es &amp;ndash;set cluster.name=tracing-es &amp;ndash;set master.persistence.storageClass=ceph &amp;ndash;set data.persistence.storageClass=ceph &amp;gt; jaeger-es.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;**注意：persistence.storageClass 的值一定要和我们之前部署 ceph 时创建的 StorageClass 的 meta.name 的值相同**

然后，我们可以执行 `kubectl create -f jaeger-es.yaml -n xxx`命令来部署 elasticsearch。

## 部署 Jaeger
在部署 Jaeger 的时候，我们参考：[GitHub - jaegertracing/jaeger-kubernetes: Support for deploying Jaeger into Kubernetes](https://github.com/jaegertracing/jaeger-kubernetes)。由于我们已经部署好了 elasticsearch，所以链接中关于存储中间件的内容我们可以不用关心。

首先，我们需要创建一个 configMap：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;kubectl create -f &lt;a href=&#34;https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/production-elasticsearch/configmap.yml&#34;&gt;https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/production-elasticsearch/configmap.yml&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;然后，开始部署 jaeger 相关的 component：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;kubectl create -f &lt;a href=&#34;https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/jaeger-production-template.yml&#34;&gt;https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/jaeger-production-template.yml&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Jaeger 部署成功之后，可以在相应的 ns 下发现一个名为 jaeger-query 的 service。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;root@xr-service-mesh-lab:~/external-storage/ceph/rbd# kubectl -n istio-system get svc | grep jaeger
jaeger-collector                    ClusterIP      10.103.47.166    &lt;none&gt;        14267/TCP,14268/TCP,9411/TCP                                                                                              5d
jaeger-es-elasticsearch-client      ClusterIP      10.100.101.147   &lt;none&gt;        9200/TCP                                                                                                                  5d
jaeger-es-elasticsearch-discovery   ClusterIP      None             &lt;none&gt;        9300/TCP                                                                                                                  5d
jaeger-query                        LoadBalancer   10.105.139.8     &lt;pending&gt;     80:31624/TCP                                                                                                              5d&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;如果是在集群内部，我们是可以直接通过这个 service 的地址访问 jaeger 的查询页面的。但是由于我们现在想在集群外部访问，可选择的方案有如下几种：

1. 修改这个 service 的 type 为 nodePort 并指定一个宿主机的端口。这样在集群外部就可以通过集群的`外网 IP：宿主机端口/path` 的形式访问 jaeger-query。请求的流量将从宿主机的端口转发至目的 Pod 对应的端口。
2. 使用 ingress+ingress-controller 的形式。 ingress 写入转发规则，属于一个具有文本记录功能的资源对象。ingress-controller 会根据 ingress 中写入的规则，将请求的流量转发到目的 Pod 对应的端口上。

**如果想了解更多关于 k8s 中部署的服务和「访问」相关的问题，可以看下这个链接：https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/**

## 部署 ingress+nginx-ingress-controller
首先，我们需要创建一个 Ingress：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: tracing
  namespace: istio-system
spec:
  rules:
  - host: tracing.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: jaeger-query
          servicePort: 80&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;规则写的很清楚，当我们进行一次 host 为 tracing.istio.io，且 path 为根目录，端口为80的 http 请求的时候，流量就会被转发到同 ns 下的一个名为 jaeger-query 的 svc 上，最终，由这个 svc 将请求流量打向目的 Pod。

有了 ingress 还不行，还需要一个 ingress-controller 加载上面的规则并且根据它转发请求流量：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;kubectl apply -f &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml&#34;&gt;https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml&lt;/a&gt;
```&lt;/p&gt;

&lt;p&gt;在本次部署中，笔者使用了 nginx-ingress-controller。本质上来说，nginx-controller 就是对 nginx 的一个封装。你可以这样理解 ingress 和 nginx-ingress-controller 之间的关系：ingress 写入一系列的路由规则，nginx-ingress-controller 中封装的 nginx 会加载这些规则，以实现对指定请求的流量控制。&lt;/p&gt;

&lt;h2 id=&#34;访问-jaeger-query&#34;&gt;访问 jaeger-query&lt;/h2&gt;

&lt;p&gt;此时，将你的 k8s 集群的公网 ip 和 tracing.istio.io 的 DNS解析映射关系写入你所在机器的 /etc/hosts 文件，然后就可以在浏览器通过访问 &lt;a href=&#34;http://tracing.istio.io&#34;&gt;http://tracing.istio.io&lt;/a&gt; 看到 jaeger-query 的 UI 界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/jager-ui&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Head First of Tracing System</title>
      <link>http://littledriver.net/post/2018/09/26/head-first-of-tracing-system/</link>
      <pubDate>Wed, 26 Sep 2018 17:58:42 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/09/26/head-first-of-tracing-system/</guid>
      
        <description>

&lt;h2 id=&#34;什么是-link-tracing-为什么我们需要-tracing&#34;&gt;什么是 Link Tracing？ 为什么我们需要 Tracing？&lt;/h2&gt;

&lt;p&gt;Link Tracing 字面意思就是链路追踪，它是一个抽象的概念。针对于一个分布式的系统来说，「链路」主要是某个请求从进入到这个系统一直到被处理完成的整个路径。而「追踪」就更好理解了，它可以给我们提供一定的信息，方便我们了解在这个链路上都发生了什么。&lt;/p&gt;

&lt;p&gt;传统的「服务」像是一锅大杂烩，将所有的功能都集成到一个 binary 中，如监控，日志收集，UI，存储等等。多个模块硬耦合在一起，带来的后果就是整个系统变得臃肿和不可控，修改起来也相当的麻烦。更新频率较低的功能，往往会受到更新频率较高的功能的影响。由于种种原因，越来越多的开发团队企图将他们的「大杂烩」剥离成一个个相互合作的微服务。多个具有合作关系的微服务统称为一个「分布式系统」（笔者自己对分布式系统的简单理解）。&lt;/p&gt;

&lt;p&gt;分布式系统以及微服务给开发人员和运维人员带来好处的同时也引入了一些难题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于服务和服务之间依靠网络通信，请求链路变长使得延迟有一定的升高，所以我们可能需要做一些优化&lt;/li&gt;
&lt;li&gt;现代服务多使用「并发」来实现一些 feature。并发逻辑若出现 bug，在一个分布式系统中就需要一个有效的措施去定位和解决&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而「链路追踪」技术就旨在为分布式系统解决这些问题。它提供一些方便且有效的手段，使我们可以清晰的了解到整条请求链路中各个阶段的耗时。若在请求处理的过程中出错，尤其是在一些不是我们自己实现的组件中出错，「链路追踪」也可以准确的捕获这类信息。目前已经有了一些成熟的「分布式链路追踪」系统，如 Zipkin or Jaeger。&lt;/p&gt;

&lt;h2 id=&#34;tracinggraph&#34;&gt;TracingGraph&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/tra&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果让我们通过一个图来描述一个请求的「链路」，基本上可以画成上面的样子，从1-8。这个「链路追踪」图示有优势也有劣势&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优势：

&lt;ul&gt;
&lt;li&gt;可以看清楚各个组件之间的调用关系。从用户的角度出发观察整个请求的处理链路较为直观&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;劣势：

&lt;ul&gt;
&lt;li&gt;整个请求执行的过程中，无法区分哪些逻辑是串行的，哪些逻辑是并行的&lt;/li&gt;
&lt;li&gt;无论是其中的一个小步骤还是整个请求，都无法观察到它们的运行时间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/D5AA4C42-8D14-4C45-993A-C636D567BC6E.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面的「链路追踪」图，在保留了「可以看清调用关系」的基础上，针对我们之前谈到过的几个问题作出了改进。在整个的 tracing 过程中，每一个带有不同颜色的矩形区域都被称作是一个 Span，它代表了一个调用的过程（逻辑上的一个工作单元）。一个 Span 的长度结合 X 轴可以判断它的 processing duration。并且，在按照层级将调用分类之后，可以明显的区分出「串行」和「并发」的逻辑（如图中的container start-up 调用和 stoage allocation两者就是并发执行的，而 container start-up 和 start-up scripts 就是串行执行的）。&lt;/p&gt;

&lt;h2 id=&#34;jaeger&#34;&gt;Jaeger&lt;/h2&gt;

&lt;p&gt;Jaeger 是一个由 Uber 公司开发的分布式的链路追踪系统。它遵循了 OpenTracing 提出的和「链路追踪」有关的一系列的数据模型和标准。jaeger 还实现了 OpenTracingAPI（golang），使得应用程序接入 jaeger 更加的方便。一个 jaeger 通常包含以下几个组件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;jaeger-client：业务接入 jaeger 所需要的 SDK，由特定的语言实现&lt;/li&gt;
&lt;li&gt;jaeger-agent：作为 daemon 进程部署在每一个 host/container 上，用以收集追踪数据发送至 collector&lt;/li&gt;
&lt;li&gt;jaeger-collector：收集从 jaeger-agent 上反馈而来的数据，以特定的存储组件进行持久化（es）&lt;/li&gt;
&lt;li&gt;jaeger-ui&amp;amp;jaeger-query：提供 UI 界面和查询追踪数据的服务，使得用户能够方面的查看每个请求的「链路追踪」信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://www.jaegertracing.io/img/architecture.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果是部署在生产环境的 k8s 集群中，除了上述说到的几个组件之外，还需要一个持久化存储的中间件，为 jaeger 管理海量的「追踪数据」。对于 jaeger 来说，存储中间件有几个可以供选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cassandra&lt;/li&gt;
&lt;li&gt;Elasticsearch&lt;/li&gt;
&lt;li&gt;Kafka&lt;/li&gt;
&lt;li&gt;Memory（only in test）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，如果想将 Jaeger 部署到你的 k8s 的集群中，可能还涉及到「集群外部访问集群内部服务」的问题。这可能需要你额外的为 jaeger 配置 ingress 或者直接使用 NodePort 的 Service。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;链路追踪系统，对于一个分布式系统来说是非常重要的。它为开发者收集在一个请求的生命周期内与其有关的全部信息，并最终利用这些信息构造出一个完成的「请求链路」&lt;/li&gt;
&lt;li&gt;链路追踪的相关信息对业务服务的优化以及疑难问题的定位和修复都将会提供很大的帮助&lt;/li&gt;
&lt;li&gt;OpenTracing 提供了一套标准的链路追踪的数据模型。Jaeger 和 Zipkin 都是实现了这套标准的一个「链路追踪系统」。Jaeger 是兼容 Zipkin 的数据格式的，所以 Jaeger 可以让业务方很方便的从 Zipkin 迁移过来&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>The brief of PV and PVC</title>
      <link>http://littledriver.net/post/2018/09/26/the-brief-of-pv-and-pvc/</link>
      <pubDate>Wed, 26 Sep 2018 17:58:12 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/09/26/the-brief-of-pv-and-pvc/</guid>
      
        <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;在 kubernetes 上部署服务，无论是「有状态」的，还是「无状态」的，可能大部分都有存储数据的需求。随之而来的就是对存储资源的需求。对于 k8s 来说，最底层的存储资源，我们可以直接利用 local storage，即机器的本地磁盘，也可以使用 ceph rbd 这种存储插件，单独的搭建一个存储的集群，使得运行在k8s 上的服务可以使用 network storage。&lt;/p&gt;

&lt;p&gt;但是，在搭建好了一个 ceph 存储的集群之后，我们要如何使用它呢？&lt;/p&gt;

&lt;h2 id=&#34;pv-pvc&#34;&gt;PV &amp;amp;&amp;amp; PVC&lt;/h2&gt;

&lt;p&gt;在 k8s 中，定义了两个资源来管理和使用集群中的存储资源：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Persistent Volumes： 可以认为是 k8s 集群提供的存储资源的一种抽象，由 k8s 集群自动创建&lt;/li&gt;
&lt;li&gt;PersistentVolumeClaim： 可以认为是 User(广义的 User，泛指一切想使用存储资源的事物) 对存储资源的一个请求声明&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于两者的「合作」模式，可以简单的做如下理解：&lt;/p&gt;

&lt;p&gt;用户申请一个定量的存储资源，创建一个 PVC，集群内部的某些组件在收到 PVC 的创建消息之后，根据要求创建一个相应的 PV，并且会为这个 PV 分配实际的存储空间（在本地磁盘，或者是在 ceph rbd 这种网络存储上）。但是，如果不能满足 PVC 所申请的 volume 资源，那么 PV 不会被创建，而这个 PVC 也会一直保留在那里，直到它所申请的 Volume 容量被满足。&lt;/p&gt;

&lt;p&gt;对于 PV 来说，集群对它的提供方式一般有两种：动态和静态。静态的 PV 一般都是由 k8s 集群内特定的组件预先分配好的，在用户需要使用的时候，可以直接将 PVC 和 PV 做一个「绑定」的操作即可。而动态的 PV 则需要一个叫做 StorageClass 的东西。&lt;/p&gt;

&lt;h3 id=&#34;storage-class&#34;&gt;Storage Class&lt;/h3&gt;

&lt;p&gt;一个 storage class 的资源对象，可以认为是底层存储插件的一个抽象。若我们使用 rbd 作为底层的存储插件，那么就需要创建一个 ceph rbd 的 storage class 的资源对象，若我们使用 cinder, 那么就需要创建一个 openstack clinder 的 storage class 的资源对象。在有动态分配 PV 需求的情况下，它相当于底层存储插件和 PV 之间的一个桥梁。&lt;/p&gt;

&lt;p&gt;对于一些第三方的存储插件来说，要创建对应的 Storage class 资源对象，可以在这个 repo 中搜索，并按照文件进行部署：&lt;a href=&#34;https://github.com/kubernetes-incubator/external-storage/tree/master/ceph/rbd&#34;&gt;external-storage/ceph/rbd at master · kubernetes-incubator/external-storage · GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-to-use&#34;&gt;How to use?&lt;/h2&gt;

&lt;p&gt;一个 Pod 中的 container 通过 PVC 和 PV 使用存储资源的过程如下：&lt;/p&gt;

&lt;p&gt;首先，我们要创建一个 PVC，也就是要申请一定额度的存储资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  resources:
    requests:
      storage: 8Gi
  storageClassName: slow
  selector:
    matchLabels:
      release: &amp;#34;stable&amp;#34;
    matchExpressions:
      - {key: environment, operator: In, values: [dev]}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其次，构造一个 pod 的编排文件, 并且在容器中通过挂在的方式使用之前通过 PVC 申请的存储资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;kind: Pod
apiVersion: v1
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: nginx
      volumeMounts:
      - mountPath: &amp;#34;/var/www/html&amp;#34;
        name: mypd
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: myclaim&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个编排文件像我们展示了如下几个关键的信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用的 PVC 名称为 myclaim，ns 和 pod 被创建的 ns 相同&lt;/li&gt;
&lt;li&gt;若申请存储资源顺利，那么最终存储资源将会挂载到名称为 myfrontend 的容器中的&lt;code&gt;/var/www/html&lt;/code&gt;路径下&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结一下： spec.containers.volumeMounts.name&amp;lt;-&amp;gt;volumes.name&amp;lt;-&amp;gt;pvc.claimName&amp;lt;-&amp;gt;pv&amp;lt;-&amp;gt;storage resource&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Contrain Pod Scheduling</title>
      <link>http://littledriver.net/post/2018/09/11/contrain-pod-scheduling/</link>
      <pubDate>Tue, 11 Sep 2018 16:52:58 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/09/11/contrain-pod-scheduling/</guid>
      
        <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;当我们创建一个 Pod 之后，Kubernetes 自身的一些调度规则将会根据集群节点的各项指标，为这个 Pod 选出一个合适的 Node 且将其调度上去。我们姑且可以认为这个调度的过程对我们来说是「随机」的。因为在没有了解清楚 Kubernetes 的调度规则之前，我们也不知道创建的一个 Pod 将会被调度到哪台节点上。
但是在日常开发的过程中，尤其是基于 k8s 开发一些数据库相关应用的时候，我们通常对 Pod 被调度的节点是有要求的，比如：我们需要将主节点强制调度到某台机器上，或者我们需要主从节点所在的 Pod 不能调度到同一个 Node 上。&lt;/p&gt;

&lt;p&gt;这些要求在 kubernetes 上是可以实现的，它提供以下几种方式来方便使用者干预 Pod 的调度策略：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;NodeSelector&lt;/li&gt;
&lt;li&gt;Taints and Tolerations&lt;/li&gt;
&lt;li&gt;Anti-Affinity/Affinity&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;nodeselector&#34;&gt;NodeSelector&lt;/h2&gt;

&lt;p&gt;NodeSelector 是依靠 LabelSelector 实现的一种调度策略。若想使用 NodeSelector， 需要分为两部分来考虑&lt;/p&gt;

&lt;h3 id=&#34;node&#34;&gt;Node&lt;/h3&gt;

&lt;p&gt;我们需要在集群中某一个我们想要调度到的 Node 上打上一个label，比如，A Node上的硬盘是 SSD，那我们就可以使用 kubectl 命令将 A Node 打上一个 disktype=ssd 的 Label。 &lt;code&gt;kubectl label nodes &amp;lt;node-name&amp;gt; &amp;lt;label-key&amp;gt;=&amp;lt;label-value&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;pod&#34;&gt;Pod&lt;/h3&gt;

&lt;p&gt;对于 Pod 来说，我们需要在它的 spec 段内，加入 nodeSelector 段。并且在 nodeSelector 段中填入「目的 Node」 所携带的 Label。比如我们想将一个 Pod 强制调度到 Node A 上，那么在构造 Pod 的基本信息的时候，就要相应的做如下修改（以 yaml 文件为例）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    env: test
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
  nodeSelector:
    disktype: ssd&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;(该 Pod 将会被强制调度到 Node Label 中有 disktype=ssd 的 Node 上)
一个可被调度的 Node 中的 labels 必须包含 Pod 的 nodeSelector 中指定的 labels。&lt;/p&gt;

&lt;h2 id=&#34;anti-affinity-affinity&#34;&gt;Anti-Affinity/Affinity&lt;/h2&gt;

&lt;p&gt;Kubernetes 提供了一种基于「亲和性」和「反亲和性」的调度策略。它实现了 NodeSelector（NodeSelector 基本相当于 NodeAffinity）能够提供的所有功能，并且额外做了如下改进：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不但支持 Node 与 Pod 之间的「关系计算」（NodeSelector），还支持待调度 Pod 和已经运行在某个 Node 上面的 Pod 之间的「关系计算」&lt;/li&gt;
&lt;li&gt;「关系计算」支持逻辑运算（AND， OR…）&lt;/li&gt;
&lt;li&gt;对一个调度策略所需要满足的条件支持两种模式：「硬性」/「软性」。「硬性」意味着如果找不到符合指定条件的 Node，那么 Pod 将会调度失败。「软性」意味着，如果有符合调度条件的 Node 那么将优先采用。否则，将会根据默认的策略进行调度，从而最大限度的保证 Pod 被成功调度运行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;nodeaffinity&#34;&gt;NodeAffinity&lt;/h3&gt;

&lt;p&gt;NodeAffinity 有两种类型:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;li&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;两种类型的区别在于前半部分：requiredDuringScheduling or preferredDuringScheduling。 简单来说，requiredDuringScheduling属于「硬性」要求，即如果它指定的条件没有被满足的话，那么相应的 Pod 可能会调度失败。而 preferredDuringScheduling 属于「软性」要求，即如果它指定的条件没有被满足的话，也会按照默认的策略继续调度 Pod。 NodeAffinity 提供的调度策略的功能基本上和 NodeSelector 是一样的，都是通过 Node 和 Pod 之间的「关系计算」指定一个调度策略。&lt;/p&gt;

&lt;p&gt;两种类型的相同点在于后半部分： IgnoredDuringExecution。也就是说，如果某一个 Pod 所在的 Node 的 label 发生了变化，导致一些已经运行在该 Node 上的 Pod 不符合运行条件，那么这些 Pod 也不会受到影响。总结下来就是，目前的「调度策略」都是在调度的过程中生效，至于已经调度完成的 Pod 不会受到影响。&lt;/p&gt;

&lt;p&gt;为了更加直观的了解 NodeAffinity 的功能，我们通过一个例子来了解：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: with-node-affinity
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/e2e-az-name
            operator: In
            values:
            - e2e-az1
            - e2e-az2
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        preference:
          matchExpressions:
          - key: another-node-label-key
            operator: In
            values:
            - another-node-label-value
  containers:
  - name: with-node-affinity
    image: k8s.gcr.io/pause:2.0&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;首先，如果在一个 Pod.Spec 段内同时指定了两种 NodeAffinity 的话，那么最好的情况下是调度到两个调度策略都满足的 Node 上。否则，优先满足 required 的。&lt;/p&gt;

&lt;p&gt;其次，对于 requiredDuringSchedulingIgnoredDuringExecution 和 preferredDuringSchedulingIgnoredDuringExecution 类型来说：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果一个 nodeSelectorTerms 中包含多个 item，那么必须要所有的 item 都满足，该条件才会被认为已满足&lt;/li&gt;
&lt;li&gt;如果是有多个 nodeSelectorTerms 的话，那么只要有一个 nodeSelectorTerms 满足，该条件就会被认为已满足&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;两者之间的差别在于 weight 字段。因为 preferred是一个「软性」的要求，所在在调度 Pod 的时候，如果同时有多个候选 Node 的话，k8s 会对这些 Node 进行打分，从而选出一个分数最高的 Node 进行调度。打分的过程中，如果preferredDuringSchedulingIgnoredDuringExecution 中指定的条件被满足的话，Weight 就会被计入相应 Node 所获得的总分内。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果 NodeAffinity 和 NodeSelector 同时被指定的时候，必须两者都满足，该 Pod 才可被成功调度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;inter-pod-affinity-and-anti-affinity&#34;&gt;Inter-pod affinity and anti-affinity&lt;/h3&gt;

&lt;p&gt;pod affinity/anti-affinity 是基于 Pod 的 label 制定调度策略，而不是 Node 的 label。同时，除了 affinity 特性之外，Pod 还增加了 anti-affinity。两者的区别可以做如下理解：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;affinity: 如果 affinity 的条件满足，那么 Pod 可以被调度到对应的 Node 上&lt;/li&gt;
&lt;li&gt;anti-affinity：如果 anti-affinity 的条件满足，那么 Pod 不可以被调度到对应的 Node 上&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pod affinity/anti-affinity 实现的调度策略可以用一句话来概括&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The rules are of the form “this pod should (or, in the case of anti-affinity, should not) run in an X if that X is already running one or more pods that meet rule Y”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中 Y 可以被认为是 PodSelector， 即去筛选特定的一类 Pod。X 在这里也不仅仅代表某一个 Node，而是代表了一组 Node。Nodes 以一个特殊的字段作为标准进行分组：&lt;code&gt;topologyKey&lt;/code&gt;（其实 topologyKey 就是 NodeLabel 中的一个 Key， 可以认为我们把带有 Label 为 topologyKey 的 Node 划分成了一组）。所以，对于 pod 的 affinity/anti-affinity 来说，我们首先要找到一组候选的 Node，然后再根据这些 Node 上面运行的 Pod 的 Label 来决定该 Pod 是否应该调度（or 不应该调度）到相应的节点上。&lt;/p&gt;

&lt;p&gt;为了更加直观的了解，我们可以看一个具体的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: with-pod-affinity
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: security
            operator: In
            values:
            - S1
        topologyKey: failure-domain.beta.kubernetes.io/zone
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: security
              operator: In
              values:
              - S2
          topologyKey: kubernetes.io/hostname
  containers:
  - name: with-pod-affinity
    image: k8s.gcr.io/pause:2.0&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;该 Pod 设置了 pod affinity/anti-affinity 两个调度条件。
对于 podAffinity 来说，我们需要先找到一组带有 label 为 failure-domain.beta.kubernetes.io/zone 的 Node。如果这些 Node 上有运行 label key 为 security， value 为 S1 的 Pod，那么应该将 Pod 调度到这些 Node 上。该条件为「硬性」限制。也就是说，如果找不到符合上面要求的 Node，这个 Pod 将会面临着调度失败的情况。&lt;/p&gt;

&lt;p&gt;对于 podAntiAffinity 来说， 我们首先要找到一组带有 label 为 kubernetes.io/hostname 的 Node（这个 Label 是每个 Node 默认具有的，不需要我们制定，属于 built-in 类型）。如果这些 Node 上有运行 label key 为 security ， value 为 S2 的 Pod，那么不应该将 Pod 调度到这些 Node 上。但是这个条件为「软性」限制，满不满足都不会影响 Pod 的调度。&lt;/p&gt;

&lt;p&gt;综合起来，对于实例中的这个 Pod 来说，它的调度策略应为如下内容：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;首先要找到一组 Node 带有 label 为 failure-domain.beta.kubernetes.io/zone 且 Node 上需要运行 label key 为 security， value 为 S1 的 Pod。否则，调度失败。&lt;/p&gt;

&lt;p&gt;若 podAffinity 条件成立，则在已经筛选出来的 Node 中继续寻找带有 label 为 kubernetes.io/hostname 的 Node 且 Node 上有运行 label key 为 security ， value 为 S2 的 Pod。若找到符合 podAffinity 条件的 Node 则更好，即使找不到也无所谓，可以继续进行调度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了上面我们谈到的几点之外，pod affinity/anti-affinity 还有一个比较特殊的地方，就是 &lt;code&gt;namespace&lt;/code&gt;。因为 Pod 是处于某个 namespace 下面的。所以在通过 pod 的 labelSelector 筛选符合条件的 Node 的时候，必须要带上 namespace。默认情况下，如果不指定 namespace，可以认为它就是 定义了 pod affinity/anti-affinity 的 pod 所在的 namespace（被调度的 Pod 所在的 namespace）。&lt;/p&gt;

&lt;h2 id=&#34;taints-and-tolerations&#34;&gt;Taints and Tolerations&lt;/h2&gt;

&lt;p&gt;taints 和 toleraitons 其实是一对的，需要配合在一起使用。taints 作用于 Node 侧，tolerations 作用于 Pod 侧。taints 和 tolerations 本质上来说和 label 的作用差不多，是一种起到标记作用的文本。&lt;/p&gt;

&lt;p&gt;当一个 Node 打上了一个或者多个 taints，如果一个 Pod 没有指定 tolerations 或者指定的 tolerations 和 这个 Node 所指定的 taints “不匹配”。这个 Pod 就不能够被调度到这个 Node 上。如果“匹配”，那么这个 Pod 就可以被调度到这个 Node 上。&lt;/p&gt;

&lt;p&gt;我们可以通过 kubectl 命令去指定 Node 的 taints &lt;code&gt;kubectl taint nodes node1 key=value: NoSchedule&lt;/code&gt;。指定之后，通过 kubectl 观察 Node 的基本信息，可以看到如下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;  taints:
  - effect: NoSchedule
    key: key
    value: &amp;#34;value&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个 taints 的作用就是：不允许任何 Pod 调度到该 Node 上，除非这个 Pod 指定了 tolerations 且和该 taints“匹配”。&lt;/p&gt;

&lt;p&gt;taints 的作用通过 effect 字段进行标识。除了 NoSchedule 之外，还有一个 PreferNoSchedule，与 NoSchedule 相比，它是一个「软性」的作用。也就是说，k8s 尽量不把 Pod 调度到 tolerations 和 taints 不匹配的 Node上，但是不排除「特殊情况」。taints 还有另外一个作用就是 NoExecute。当一个 Node 指定了 effect 为 NoExecute 的 taints，如果该 Node 上面的 Pod 的 tolerations 没有匹配它的 taints，这些 Pod 会被 kubelet 给 evicted 掉。(小朋友不要轻易尝试这个操作 o(&lt;em&gt;￣︶￣&lt;/em&gt;)o)。不过，对于 tolerations 和 taints 匹配的 Pod，在 effect 为 NoExecute 的时候也不一定是「安全」的。原因在于，我们可以在 pod.Spec 中配置一个 tolerationSeconds 的字段，它的作用是：即使是 pod 的 tolerations 和 Node 的 taints 匹配，该 Pod 也只会存活 tolerationSeconds 秒的时间（从匹配成功开始算起），最终仍然会被 evicted 掉。&lt;/p&gt;

&lt;p&gt;tolerations 需要在 pod.Spec 中进行指定：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;tolerations:
- key: &amp;#34;key&amp;#34;
  operator: &amp;#34;Equal&amp;#34;
  value: &amp;#34;value&amp;#34;
  effect: &amp;#34;NoSchedule&amp;#34; // &amp;#34;PreferNoSchedule&amp;#34;

tolerations:
- key: &amp;#34;key&amp;#34;
  operator: &amp;#34;Exists&amp;#34;
  effect: &amp;#34;NoSchedule&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;tolerations 和 taints 的匹配过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tolerations.key, tolerations.effect 必须要与 taints 的同名字段的值严格匹配&lt;/li&gt;
&lt;li&gt;tolerations.value 在与 taints.value 匹配的过程中，需要遵循 operator 的规则&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;operator 的规则有 Exists 和 Equal 之分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Exists：只要是 key 匹配就可以了，value 是什么并不重要。且在指定 tolerations 的时候，如果 operator 为 Exists，不应该指定 value&lt;/li&gt;
&lt;li&gt;Equal：tolerations.value 在与 taints.value 必须要严格匹配&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;add-taints-automatically&#34;&gt;Add taints automatically&lt;/h2&gt;

&lt;p&gt;在 k8s 1.6 的版本之后，对于 pod 新增了一些基于 taints 的 evict 策略。在 1.8 版本之后更是增加了「根据 node condition 自动添加 taints」 的特性。综合起来可以认为：nodeController（or kubelet） 会根据 node 当前的健康状态为其添加一些 effect 为 NoExecute 的taints。从而实现「根据 Node 状态 evict Pod」的功能。&lt;/p&gt;

&lt;p&gt;例如，当某个 Node 节点的网络情况发生异常的时候，nodeController 就会给该 Node 打上一个如下的 taints：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;  taints:
  - effect: NoExecute
    key: node.kubernetes.io/network-unavailable
    value: &amp;#34;value&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Heade First Redis Sentinel</title>
      <link>http://littledriver.net/post/2018/08/27/heade-first-redis-sentinel/</link>
      <pubDate>Mon, 27 Aug 2018 16:00:20 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/08/27/heade-first-redis-sentinel/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;WARNING: 本篇文章是在阅读了 Redis Sentinel 的&lt;a href=&#34;https://redis.io/topics/Sentinel-spec&#34;&gt;设计文档&lt;/a&gt;之后产出的。但是由于该设计文档已经被官方标识为 draft 且时间也比较久远，笔者在阅读这份文档的时候还是发现了几处与当前新版本实现不同的地方，甚至是有一些错误的。所以本文的目的也就在于：先借助该设计文档对 Sentinel 这套高可用的方案有一个宏观上的了解，具体的实现细节，之后会另写几篇博文对 Sentinel 的源码进行分析。若是有能力直接阅读源码的读者可直接去阅读源码。如果你在阅读这篇文章的时候，发现了一些错误并且愿意帮忙改正的话，请私信联系我。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先说明几个这篇 blog 使用的名词&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- 「Redis Sentinel」指通过 Sentinel 实现的 Redis 高可用方案
- 「Sentinel 节点」指 Redis 集群中运行的某一个 Sentinel 节点（redis-server）&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Q: 什么是「Redis Sentinel」?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Redis Sentinel 是一套「方案」。它能够提升 Redis 集群的可用性，也就是我们常说的「高可用」&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: Sentinel 通过哪些功能可以实现 Redis 集群的「高可用」？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Redis 集群的「高可用」，在我理解，可以分为「用户」和「服务」两个维度进行讨论&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- 用户维度
    - Sentinel 通过某些命令可以让用户实时获取当前集群的 Master 节点的地址（Sentinel 会进行故障转移操作）
    - 预设了一些「通知」机制，可以在 Redis 集群内部发生异常的时候通知给集群的维护者或者使用者
- 服务维度
    - 监控集群中主从节点以及 Sentinel 节点的健康状态
    - 集群 Master 发生故障时可自动进行「故障转移」操作来恢复集群&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;总结下来，这套「高可用」方案既可以保证 Redis 集群自身的健康，同时也在发生故障的时候尽量降低对集群使用者的影响。Redis 的作者对这套高可用方案有着更加清晰的概括&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	So the three different roles of Redis Sentinel can be  summarized in the following three big aspects:
	
	1. Monitoring.
	2. Notification.
	3. Automatic failover.
		&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Q: 「Redis Sentinel」将以何种方式实现？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;「Redis Sentinel」将通过多个 Sentinel 节点一起合作实现。一个 Sentinel 节点也是一个 redis-server。与普通数据节点不同的是，「Sentinel 节点」将会以特殊的 mode 运行，只接受「Redis Sentinel」 相关的命令。在代码层面上，「Sentinel 节点」和数据节点将会共用很多代码，避免重复实现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: 一个标准的「一主一从」的 Redis 集群若使用了「Redis Sentinel」，它的服务拓扑是什么样的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Redis-Sentinel%201-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的拓扑图中可以看出，任意一个「Sentinel」 节点都监控了集群中除自身之外的所有节点。Master 和 Slave 之间会进行双向通信，在此通信过程中实现的最重要的功能就是「主从数据同步」。「Sentinel 节点」使用&lt;code&gt;Ping&lt;/code&gt;命令对其他节点进行监控，并且其自身也能够正常的响应&lt;code&gt;Ping&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: 以上的服务拓扑关系是如何建立起来的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以 Sentinel 为起点来说，它需要与整个集群内部所有的节点都建立链接，这些链接有些是用来监控对方的健康状态，有些则是需要获取一些有用的信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- Sentinel-&amp;gt;Master: 这条连接被用作 Sentinel 监控 Master。它可以对 Sentinel 节点执行一条命令来建立： `Sentinel monitor &amp;lt;Master-group-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt; &amp;lt;quorum&amp;gt;`
- Sentinel-&amp;gt;slaves: 这条连接被用作 Sentinel 监控 slave节点。它通过 Sentinel 节点对 Master 节点执行 `INFO`命令来获取集群中与 mater 节点建立了主从关系的 slave 节点。
- Master-&amp;gt;slave: Master 和 slave 之间的链接主要用于主从数据同步。这条连接也是通过一条命令建立起来的`SLAVEOF host port`。初始启动时，两个数据节点可能都是以 Master 的身份启动的。此时如果没有特殊需求，可对任意一个 slave 节点执行这条命令，主从节点之间的链接便会成功建立。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;图中不同 Sentinel 节点之间建立关系的过程要比上面所描述的复杂一些，我们首先来看下 Sentinel 节点之间建立的链接有何作用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;a) 监控除自己之外的 Sentinel 节点 
b) 在集群发生故障的时候，通过这条连接 Sentinel 节点相互之间要进行通信&amp;amp;合作，从而实现「故障转移」的功能。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;事实上，Sentinel 节点在启动的时候并不知道它所在的集群中是否还有其他的节点。Sentinel 节点是通过一种消息的「订阅/发布」机制来进行服务发现的。这个 msg 的「集散地」就是 Master 节点，因为在任意一个 Sentinel 节点启动时都只知道 Master 节点的信息（上述监控 Master 节点的 monitor 命令我们一般都会放在 Sentinel 启动的配置文件中）。每一个 Sentinel 在启动之后都会向 Master 节点的一个 channel Pub 一条消息，这条消息的内容包括了 Sentinel 节点自身的信息(runid, IP, port)。除了执行 Pub 操作之外，每个 Sentinel 节点也会订阅（Sub）这个 channel，以便接收其他 Sentinel 节点发送来的消息进行服务发现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: Sentinel 节点是如何监控集群中「其他节点」的呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;任意一个 Sentinel 节点在对整个集群的「服务拓扑」有了完整的了解之后，会通过&lt;code&gt;PING&lt;/code&gt;命令对其他节点进行「健康检测」。如果&lt;code&gt;PING&lt;/code&gt;命令的超过「一定的时间」(down-after-milliseconds) 没有被响应或者返回一个错误，那么 Sentinel 节点将会判定这个被监控的节点是不健康的。「一定的时间」是可以自由进行设置的，但是很难给出一个最佳的实践。&lt;code&gt;PING&lt;/code&gt;命令响应延迟的长短可能和很多因素都有关系，如果贸然设置的很大，那么「健康检测」将会很迟钝，反之，可能会误报。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: Sentinel节点 是以什么标准来判定 Master 节点故障的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个 Redis 集群内，往往至少要有三个 Sentinel 节点才能正常的使用它提供的「高可用方案」。通过对上一个问题的了解，我们知道每一个 Sentinel 节点都会对 Master 节点进行监控，从而对他的健康状态做出一个判断。既然是分开判断的，那么肯定会发生判断结果不一致的情况。所以在「Redis Sentinel」 中，将会通过以下几种方式来保证对 Master 节点状态做出的判断是可靠的。&lt;/p&gt;

&lt;p&gt;首先，Sentinel 节点将不健康的 Master 状态以较粗的粒度划分为了两类：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- Subjectively Down(aka S_DOWN): 主观下线。顾名思义就是「Master节点已经不健康」的判断仅来源一个 Sentinel 节点，只代表了它自己的观点。
- Objectively Down(aka O_DOWN): 客观下线。集群中「一定数量」（quorom）的 Sentinel 节点都做出了「Master节点已经不健康」的判断，代表了大部分甚至是全部 Sentinel 节点的观点。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;这里需要提及的一点就是：「一定数量」的 Sentinel 节点到底指的是多少个。它其实是一个参数：quorom，可以由 Redis 集群的创建者进行设置的。之前在&lt;a href=&#34;http://littledriver.net/posts/redis-Sentinel-explanation-1/&#34;&gt;Redis-Sentinel-Explanation&lt;/a&gt;一文中有提到过这个参数的意义。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后，当一个 Sentinel 节点判定 Master 节点处于 S_DOWN 状态之后，它会向集群内其余 Sentinel 节点执行&lt;code&gt;Sentinel is-Master-down-by-addr&lt;/code&gt;命令，以便了解其他 Sentinel 节点对于 Master 节点状态的判断。如果该 Sentinel 节点发现集群中已经超过 quorom 个 Sentinel 节点都认为 Master 处于 S_DOWN 状态的话，那么它认为 Master 节点已经处于 O_DOWN 状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: 这个 quorom 值应该如何设置呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，根据上面描述的「判断 Master 节点故障」的过程，我们可以知道：触发「故障转移」的灵敏度其实来自于 quorom 这个值的大小。例如，你的 Redis 集群中有5个 Sentinel 节点，当 quorom 设置为2的时候，如果有两个Sentienl 节点都认为 Master 节点处于 S_DOWN 状态，那么这个 Master 就会被判定为 O_DOWN状态。若以上的过程都正常，那么接下来就会进行和「故障转移」相关的步骤。当 quorom 设置为4的时候，就必须要4个 Sentinel 节点对 Master 节点做出 S_DOWN判定才会继续处理。&lt;/p&gt;

&lt;p&gt;除了会影响「灵敏度」之外，当集群发生了网络割裂或者大部分 Sentinel 节点都 down 掉的时候，quorom 值设置的越小，你的 Redis 集群就越有可能在发证故障的时候能被「故障转移」正常的恢复。反之，这个「Redis Sentinel」 的高可用方案可能就不起作用了。所以说 quorom 值的设置将是一把双刃剑。需要按照Redis 集群所处的网络环境以及发生故障的类型及频率综合考虑之后给出一个值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里需要提及的一点就是：对于 Master 节点状态的判断，每一个 Sentinel 都是独立执行的，他们之间可以相互合作（O_DOWN 的判断），但是最终的决策还是靠自己所掌握的信息做出的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Q: 在真正执行「故障转移」操作之前，「Redis Sentinel」 还需要做些什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一个 Redis 集群中，如果有超过 quorom 个 Sentinel 节点 都认为 Master 节点处于 S_DOWN 状态的时候，那么这个 Master 将会被 Sentinel 节点标记为 O_DOWN 状态。除此之外，在真正执行「故障转移」操作之前，多个 Sentinel 节点还将选取出一个 Leader 去做这件事情。那么，Sentinel 节点是如何进行 Leader 选取的呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为了方便阐述 Leader 的选取过程，我们假设现在的 Redis 集群是一主一从+三个 Sentinel 节点的配置。quorom 值设为2。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，既然要选取 Sentinel Leader，那么肯定就需要先确定 Candidate。那究竟什么样的 Sentinel 节点才可以作为 Candidate 呢？很简单，只要是可以连通的 Sentinel 节点都可以作为 Candidate。&lt;/p&gt;

&lt;p&gt;在明确了 Candidate 之后，「Redis Sentinel」 将会使用一种「投票」的机制，选出一个 Leader。「投票」机制核心内容是很简单的：所有的 Candidate 都把票投给 runid 最小的那个 Sentinel 节点。如果对 Redis 不熟悉的读者可能在这里会对以下三个问题比较疑惑：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;* Q1: runid 是什么？
* Q2: 多个不同的 Sentinel 节点之间是如何知道彼此的 runid 的？
* Q3: 选举出来的 leader 如何知道它已经被其他 Sentinel 节点认可了呢？

* A1: runid， IP，port 三个元素将会构成一个三元组，唯一的标识一个集群中正在运行的 Sentinel 节点。runid 在每次节点重启之后都会变化，所以它能够标识正在集群中运行的 Sentinel 节点，而不是旧的。因为 Sentinel 节点的 IP 和 port可能都是不变的，尤其是在物理机运行的时候。
* A2: 回忆一下 Sentinel 节点如何做服务发现的过程就可以知道，Sentinel 节点向 Master 节点的 channel Pub 消息的时候会带上自己的详细信息，而这些详细信息里面就包括：runid， IP， port。
* A3: 当集群中的每一个 Sentinel 节点都选出了自己的 Subjective Leader（主观 leader）之后，Sentinel 节点之间还是会每隔 1s 中会相互发送一个`Sentinel is-Master-down-by-addr`命令。每个 Sentinel 节点在回复这个 command 的时候都会带上自己选出的 Subjective Leader的 runid。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当某一个 Sentinel 节点收到了其他 Sentinel 节点的投票结果之后，它接下来会做如下几个判断：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;1. 有没有投自己一票 
2. 至少有 quorom-1个 Sentinel 节点对 Master 节点的状态做出了 O_DOWN 的判定
3. 至少有 sum(Sentinels) / 2 + 1 个（也就是半数以上）的 Sentinel 节点将票投给了自己&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当上述三个条件全部成立的时候，该 Sentinel 节点将作为 Leader 执行接下来的步骤。&lt;/p&gt;

&lt;p&gt;截止到目前为止，「Redis Sentinel」已经确认了 Master 的故障状态，且选举出来了一个 Leader。在真正完成「故障转移」操作之前，Leader 还需要在集群中找出一个合适的 Slave 节点。为什么要找一个 Slave 节点呢？要解释这个问题，就必须提前介绍一下「故障转移」操作的的本质：「切主」。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「故障转移」其实最终只是为了完成一个目标：在 Redis 集群发生故障的时候，从可用的 Slave 节点当中挑选一个作为新的 Master 节点且重新建立整个集群的拓扑结构。&lt;/p&gt;

&lt;p&gt;这种故障处理措施和 Redis 的使用方式是密切相关的。对于一个 Redis 集群，我们可以利用一些技巧提升它的性能，如：读写分离。但是一个始终不变的事实就是：在 Redis 集群中，数据同步都是从 Master 节点同步至 Slave 节点。使用 Redis 集群，其写入操作是必须要作用于 Master 节点上的。由于前面说到的数据同步的方向性，如果写入操作到了 Slave 节点，那么就会有丢失数据的影响。所以，无论是用户还是集群的维护者都不能够忍受一个集群的 Master 节点长时间不可用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可供选择的 Slave Candidate 一般都会具有如下两个条件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- Slave 节点本身是可正常访问的
- Slave 节点不能与 Master 节点断开连接时间过长&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中第一个条件很容易理解，而第二个条件则是保证「切主」后 Master 节点的数据不会过于陈旧。陈旧的数据对于将 Redis 作为缓存来使用的服务会产生较大的影响。对于符合了上述两个条件的 Slave 节点，我们会根据他们的「priority（优先级）」进行排序，选取一个低优先级的节点。priority 相当于每一个 Slave 节点的权重，priority 越低，证明这个节点在集群中的同类节点里权重越大（priority 可以通过 Slave 节点的启动配置文件中的 slave-priority 进行配置）。若有多个节点的 priority 相同的话，Leader 将会选取runid 较小的一个节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: 「故障转移」都做了些什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;「故障转移」主要是由 Leader Sentinel 节点来操作的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;1. 对选取出来的 Slave 节点执行`SLAVEOF NO ONE`命令，将这个 Slave 节点提升为 Master 节点
2. 对集群中余下的 Slave 节点（如果有）按照顺序依次执行`SLAVEOF NEWMaster PORT`命令，尝试重新建立主从节点之间的链接
3. 调用「监控脚本」（如果有）通知用户当前正在进行「故障转移」
4. 开始监控新的 Master 节点，将旧的 Master 节点的相关信息从自己的配置文件中删除&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Q: Sentinel Leader 在执行「故障转移」的时候，其余的 Sentinel 节点在做什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;稍微思考一下就可以知道，对于其他的 Sentinel 节点来说，可能需要做的事情有两件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;1. 观察「故障转移」的执行结果
2. 重新进行服务发现&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Sentinel 节点不再依靠和 Leader 通信来获取「故障转移」的相关信息。由于「故障转移」最终实现的就是一个「切主」的操作，所以其余的Sentinel 节点将会通过观察 Slave 节点的信息来判断「故障转移」的执行情况。接下来，我们统一把这些扮演观察者角色的 Sentinel 节点称作 Observer Sentinel，并了解一下它们在这期间具体都做了些什么：&lt;/p&gt;

&lt;p&gt;当 Leader 选中了一个合适的 Slave 节点并想将其提升为新的 Master 节点的时候，它会为这个 Slave 节点打上一个名为&lt;code&gt;FAILOVER_IN_PROGRESS&lt;/code&gt;的 flag。Observer Sentinel 将会持续关注所有的 Slave 节点。当其中一个 Slave 节点被提升为 Master 且其余的 Slave 节点都和其建立了新的主从关系之后，Observer Sentinel就认为此时「故障转移」操作已经完成了。「故障转移」完成之后，Leader 会去掉新 Master 节点上&lt;code&gt;FAILOVER_IN_PROGRESS&lt;/code&gt;的 flag。而这一些的操作 Observer Sentinel都是非常清楚的。当 Sentinel 节点已经明确了它所要监控的 Master 节点之后，就会很容易的按照我们之前描述的步骤重新建立集群的拓扑结构。至于故障的旧的 Master 节点，我们可以手动或者使用&lt;code&gt;代码&lt;/code&gt;将它启动起来，作为 Slave 节点与新的 Master 节点建立主从关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q: 有哪些因素会影响 Sentinel 节点执行「故障转移」？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在对「Redis Sentinel」 这套高可用方案有了一个简单的了解之后，我们可以粗略的归纳出：影响「故障转移」操作正常执行的因素有两个：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- 网络环境
- Sentinel 节点本身是否健康&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;因为 Sentinel 节点在执行「故障转移」操作期间会频繁的与其他节点交换信息或者执行一些命令，如果此时网络环境较差，那么将会发生很多不可预期的情况，如脑裂。&lt;/p&gt;

&lt;p&gt;除此之外， Sentinel 节点本身的健康状态也是非常重要的。尤其是对于 Leader 节点来说，如果在执行「故障转移」的过程中或者准备执行之前发生了一些异常，那么也将会导致很多非预期的行为。除了 Sentinel 节点间的监控之外，在「Redis Sentinel」 中，每一个 Sentinel 节点会每隔 100ms 运行一个定时任务。这个定时任务主要的内容就是计算一下上一次执行的该任务的时间与目前的时间之间的差值。如果这个差值已经过大或者说已经是负值的话，该 Sentinel 节点将会进入一种「保护模式」——— TILT。在这种模式下，Sentinel 节点除了会执行常规的监控操作之外会暂停所有其他的活动。所以对于「Redis Sentinel」 这套高可用的方案来说，它会尽最大的努力来保证「故障转移」操作的正常执行。&lt;/p&gt;

&lt;p&gt;另外，已经进入了 TILT 模式的 Sentinel 节点，上述所提到的「定时任务」还是会正常执行。若在 30s 中之内该定时任务所计算出的时间间隔一直是正常的，那么该 Sentinel 节点将会退出 TILT 模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过对「Redis Sentinel」 Design Doc 的阅读，笔者在较为宏观的层面上了解了这套高可用的方案。在基于 Kubernetes 开发高可靠的 Redis APP 的过程中，不得不说，我对这套方案是又爱又恨的。「爱」是觉得它的设计思路很不错，没有和 Redis 本身提供的「数据库」相关的功能混杂在一起，即使一两个 Sentinel 出问题 down 掉也不会影响集群的正常访问。「恨」是因为这套高可用的方案运行在容器和 k8s 的环境上多多少少有点「水土不服」。所以，我们（其实就我一个人╮(╯▽╰)╭）在开发 APP 的过程中，会针对「Redis Sentinel」 在容器上使用的一些缺陷做出了相应的补足措施。这是一件很不容易的事，不容易的地方在于，我们的「措施」是不能够和他本身的高可用方案发生冲突的。在博客后续的文章中，我将会持续的和大家分享「基于 Kubernetes 开发高可靠 APP」 的经验以及对「Redis Sentinel」 源码学习的过程。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Head First Scheduler of Golang</title>
      <link>http://littledriver.net/post/2018/08/14/head-first-scheduler-of-golang/</link>
      <pubDate>Tue, 14 Aug 2018 15:45:25 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/08/14/head-first-scheduler-of-golang/</guid>
      
        <description>

&lt;h2 id=&#34;我们的程序是如何被运行的&#34;&gt;我们的程序是如何被运行的？&lt;/h2&gt;

&lt;p&gt;学习过操作系统的人，应该对进程和线程的模型都是有所了解的。按照我的理解：「进程」是操作系统资源分配的基本单位，它给程序提供了一个良好的运行环境。「线程」则是一个轻量级的进程，一个「进程」中可以有很多线程，但是最终在一个 CPU 的核上只能有一个「进程」的其中一个「线程」被执行。所以，我们的一个程序的执行过程可以粗略的理解为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;程序的可执行文件被 Load 到内存中&lt;/li&gt;
&lt;li&gt;创建进程&amp;amp;创建主线程&lt;/li&gt;
&lt;li&gt;主线程被 OS 调度到合适的 CPU 执行&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;goroutine-是什么&#34;&gt;goroutine 是什么？&lt;/h2&gt;

&lt;p&gt;看了很多文章对于 goroutine 的描述，其中出现最多的一句话就是「The goroutine is a lightweight thread.」。在结合了对操作系统的线程模型的理解之后，我觉得 goroutine 就是一个在用户空间（usernamespace）下实现的「线程」，它由 golang 的 runtime 进行管理。goroutine 和 go runtime 的关系可以直接的类比于线程和操作系统内核的关系。至于它是不是轻量级，这需要和操作系统的线程进行对比之后才能够知道。在此我们先避免「人云亦云」。&lt;/p&gt;

&lt;h2 id=&#34;goroutine-和-thread-有什么不同&#34;&gt;goroutine 和 thread 有什么不同？&lt;/h2&gt;

&lt;p&gt;目前看起来 goroutine 和 thread 在实现的思路上是比较相似的。但是为什么说 goroutine 比 thread 要轻量呢？从字面的意思上来理解，「轻量」肯定意味着消耗的系统资源变少了。&lt;/p&gt;

&lt;h3 id=&#34;内存消耗&#34;&gt;内存消耗&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/Gocon-2014-40.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;os&#34;&gt;OS&lt;/h4&gt;

&lt;p&gt;从 OS 的层面来说，内存大致可以分为三个部分：一部分为栈（Stack）另外一部分为堆（Heap），最后一部分为程序代码的存储空间（Programe Text）。既然在逻辑上 OS 已经对内存的布局做了划分，如果栈和堆之前如果没有遵守「分界线」而发生了 overwrite，那么结果将是灾难性的。为了防止发生这种情况，OS 在 Stack 和 Heap 之间设置了一段不可被 overwrite 的区域：Guard Page&lt;/p&gt;

&lt;h4 id=&#34;thread&#34;&gt;thread&lt;/h4&gt;

&lt;p&gt;通过对 OS 中线程模型的了解，我们可以知道：同一个进程的多个线程共享进程的地址空间。所以，每一个 thread 都会有自己的 Stack 空间以及一份 Guard Page用于线程间的隔离。在程序运行的过程中，线程越多，消耗的内存也就越多。当一个线程被创建的时候，通常会消耗大概1MB的空间（预分配的 Stack 空间+ Guard Page）。&lt;/p&gt;

&lt;h4 id=&#34;goroutine&#34;&gt;goroutine&lt;/h4&gt;

&lt;p&gt;对于一个 goroutine 来说，当它被创建的时候，有一个初始的内存使用量。这个使用量在 Go 1.2~1.4 版本的时候发生过几次改变，最终确定为2KB。当一个 goroutine 在运行的过程中如果需要使用更多的内存，那么它将会在 Heap 上申请。&lt;/p&gt;

&lt;p&gt;对于 Guard Page 的问题，goroutine 采取了一种「用前检查」的方式来解决：每当一个函数调用的时候，go runtime 都会去检查当前 goroutine 的 stack 空间是否够用，如果不够就在 Heap 上分配一块新的空间，该块空间使用完还会被回收。&lt;/p&gt;

&lt;p&gt;这种「用前检查」的动态分配内存的方式使得 goroutine 在内存的消耗上相较于 thread 来说具有明显的优势。所以在写 golang 程序的时候，我们几乎可以对收到的每一个 Request 都开一个 goroutine 处理。但是如果使用 thread这么做的话，你就等着 OOM 吧:)。上面的描述并不代表对于 goroutine 你就可以随意分配使用而不及时回收，如果 goroutine 数量太多它一样会 OOM，只不过 goroutine 相较于 thread 的内存增长率要低很多罢了。在同等的量级下，thread 会引起程序 OOM 但是 goroutine 不会。&lt;/p&gt;

&lt;h3 id=&#34;创建和销毁的性能&#34;&gt;创建和销毁的性能&lt;/h3&gt;

&lt;h4 id=&#34;thread-1&#34;&gt;thread&lt;/h4&gt;

&lt;p&gt;线程的创建和销毁都需要通过系统调用来实现，也就是说，这些动作都必须要和 OS 的内核进行交互。&lt;/p&gt;

&lt;h4 id=&#34;goroutine-1&#34;&gt;goroutine&lt;/h4&gt;

&lt;p&gt;goroutine 的创建和销毁操作都是由 go runtime 来完成的，在用户空间下直接进行处理。&lt;/p&gt;

&lt;p&gt;对于创建和销毁的性能问题，这里不做过多介绍。本质上来说，goroutine 和 thread 就相当于「用户级线程」和「内核级线程」。感兴趣的可以去找下相关资料深入了解下两者的区别。否则，可以简单的理解为「goroutine 的创建和销毁是程序自己做的，但是 thread 得麻烦 OS 的内核，两者的性能当然不一样」&lt;/p&gt;

&lt;h3 id=&#34;上下文切换的消耗&#34;&gt;上下文切换的消耗&lt;/h3&gt;

&lt;h4 id=&#34;thread-2&#34;&gt;thread&lt;/h4&gt;

&lt;p&gt;当不同的线程发生切换的时候，如上面提到的创建和销毁操作一样，都需要和 OS 的内核进行交互。调度器将会保存/恢复当时所有寄存器当中的内容：PC (Program Counter), SP (Stack Pointer) 等等一系列的上下文数据。这些操作都是非常「昂贵」的&lt;/p&gt;

&lt;h4 id=&#34;goroutine-2&#34;&gt;goroutine&lt;/h4&gt;

&lt;p&gt;多个 goroutine 在发生切换的时候，由于是在同一个 thread 下面，只会保存/恢复三个寄存器当中的内容：Program Counter, Stack Pointer and DX。另外，如果你对 golang scheduler 的调度模型比较熟悉的话，那么你应该知道，同一时刻同一个 thread 只会执行一个 goroutine，未被执行但是已经准备好的 goroutine 都是放在一个 queue 中的，他们是被串行处理的。所以，即使一个程序创建了成千上万的 goroutine 也不会对上下文的切换造成什么影响。最重要的是，golang scheduler 在切换不同 goroutine 的操作上基本上达到了 O(1) 的时间复杂度。这就使得上下文切换的时间已经和 goroutine 的规模完全不相关了。&lt;/p&gt;

&lt;h2 id=&#34;goroutine-是如何工作的&#34;&gt;goroutine 是如何工作的？&lt;/h2&gt;

&lt;p&gt;通常来讲，一个 goroutine 运行起来通常需要三个「组件」参与：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;golang runtime&lt;/li&gt;
&lt;li&gt;runable goroutine&lt;/li&gt;
&lt;li&gt;thread&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;golang runtime将会创建一些 thread 以便提供 goroutine 的运行环境。一个可运行的 goroutine 将会被调度到 thread 上执行。当该 goroutine 被 block 住（没有 block 住对应的 thread，如系统中断等）的时候，会从「runable goroutines」中获取一个 goroutine 进行上下文切换以至于这个新的 goroutine 能够被执行&lt;/p&gt;

&lt;h2 id=&#34;golang-的-scheduler-是如何工作的&#34;&gt;golang 的 scheduler 是如何工作的？&lt;/h2&gt;

&lt;h3 id=&#34;golang-的调度模型&#34;&gt;golang 的调度模型&lt;/h3&gt;

&lt;p&gt;对于 thread 和 os 内核来说，如果他们彼此的数量关系是1：1，在机器是多核的情况下，其并行计算能力将会被发挥到极致。但是，线程上下文切换的消耗将会对整个 OS 的性能有所影响。如果他们彼此的数量关系是 N:1,  虽然上下文切换的消耗降低了，但是 CPU 的利用率却会下降。&lt;/p&gt;

&lt;p&gt;在 golang 的调度模型中，对于 goroutine 和 thread 的数量关系，采取了 M:N 的形式：它可以调度任意数量的 goroutine 到任意数量的 thread 上。在尽可能提高 CPU 利用率的同时，也保证了 goroutine 的上下文切换操作是较为「便宜」的（都是在 usernamespace 下进行，不需要 OS 内核参与）。 golang 对于 goroutine 的调度，设计了三个基本的对象：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;machine（M）&lt;/li&gt;
&lt;li&gt;goroutine（G)&lt;/li&gt;
&lt;li&gt;processor（P)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中 M 代表的是一个可供使用的 thread，它被 OS 内核管理。G 则代表一个 goroutine，它是轻量级的 thread。P 代表一种「资源」，只有它和 M 一起配合才能够运行一段 golang 的代码，所以姑且可以把 P 理解为 goroutine 执行过程中的上下文环境。P 是一个桥梁，他把1：1和1：N 这两种模型结合了起来，最终产出了 M:N 的调度模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/in-motion.jpg&#34; alt=&#34; golang schedule model &#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据上面的模型图可以看出, golang 程序的并发能力除了受到 M（thread）的限制之外，还受到了 P（processor）数量的限制。 Thread 可以通过系统调用进行创建，那么 P 的数量可以通过什么来进行设置呢？在名为 &lt;code&gt;runtime&lt;/code&gt;的 package 中有一个&lt;code&gt;GOMAXPROCS&lt;/code&gt; 方法，我们可以通过它设置最大可使用的 P 的数量。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runtime. GOMAXPROCS&lt;/code&gt;这个函数本质上是用来设置最大可用的 CPU 核心数量：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &amp;lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于 CPU 核心数和 P 是1：1的关系（M 的数量可以多于 P），我们认为设置最大可用的 CPU 核心数就是设置最大可用的 P 的数量（对于一个 go 程序来说）&lt;/p&gt;

&lt;h3 id=&#34;调度过程&#34;&gt;调度过程&lt;/h3&gt;

&lt;p&gt;我们将分四种情况来了解 golang scheduler 调度 goroutine 的过程。假设现在有两个 M，两个 P，若干个 G&lt;/p&gt;

&lt;h4 id=&#34;steady&#34;&gt;steady&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/in-motion.jpg&#34; alt=&#34; golang schedule model &#34; /&gt;&lt;/p&gt;

&lt;p&gt;图中灰色的 G 表示了可被执行但是还未被调度的 goroutine。P 每次从「可被执行的 goroutine 队列」中选取一个 goroutine 调度到 M 执行。当前的 goroutine 被执行完成之后，将从队列中弹出。P 会不断的重复上述的过程处理 goroutine。&lt;/p&gt;

&lt;p&gt;值得注意的是，在 golang 1.2之前的版本当中，「可被执行的 goroutine 队列」和 P 并不是 1：1 的关系。整个 go runtime 中只有一个全局的「可被执行的 goroutine 队列」。它通过一个全局的锁来防止并发读写时的「竞争」问题。这种设计无疑是低效的，尤其是在 CPU 核心数较多的机器上。&lt;/p&gt;

&lt;p&gt;理论上来说，只要 P 所控制的「可被执行的 goroutine 队列」不为空，那么这个调度过程就是稳定的。&lt;/p&gt;

&lt;h4 id=&#34;busy&#34;&gt;busy&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/in-motion.jpg&#34; alt=&#34; golang busy model&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Busy 的情况就是指所有的 M 上都有正在运行的 G，没有空闲的 P，也没有空闲的 M。此时整个调度过程如上面 steady 情况所描述的一样。&lt;/p&gt;

&lt;h4 id=&#34;idle&#34;&gt;idle&lt;/h4&gt;

&lt;p&gt;通过对上面两种情况下调度过程的了解，我们再次回顾一下，一个「最小的调度单位」都包括哪些元素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Gs(runable goroutine queue)&lt;/li&gt;
&lt;li&gt;M&lt;/li&gt;
&lt;li&gt;P&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Idle 状态即是：部分 P 中挂载的 runable goroutine queue已经没有剩余的 goroutine 可供调度。如下图所示，两个「最小调度单位」中，已经有一个的 runable goroutine queue 为空了。此时，为了能够让所有的 M 的利用率达到最大，golang runtime 会采取以下两种机制来处理 idle 状态：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从 global runable goroutine queue 中选取 goroutine&lt;/li&gt;
&lt;li&gt;若 global runable goroutine queue 中也没有 goroutine，随机选取选取一个 P，从其挂载的 runable goroutine queue 中 steal 走一半的 goroutine&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/steal.jpg&#34; alt=&#34;golang idle model&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一个更加通用的调度过程的描述如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;runtime.schedule() {
    // only 1/61 of the time, check the global runnable queue for a G.
    // if not found, check the local queue.
    // if not found,
    //     try to steal from other Ps.
    //     if not, check the global runnable queue.
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在描述 steady 状态的调度过程的时候，我们提到过老版本的 Go 中没有和 P 绑定的 runable goroutine queue， 而只有一个全局的 gloabl runable goroutine queue。虽然在之后的版本中不再使用锁+全局队列的机制来实现调度器，但它仍然被保存了下来，并且在查找可被调度的 goroutine 时还会被访问到。至于原因，我们会在后面说到。&lt;/p&gt;

&lt;h4 id=&#34;syscall&#34;&gt;syscall&lt;/h4&gt;

&lt;p&gt;当我们的 goroutine 逻辑中有使用「系统调用」的代码时，其对应的 M 会被阻塞。此时 P 中挂载的 runable goroutine queue 中的 goroutine 在短时间内将不会被这个 M 调度执行。现在看起来这些「剩余」的 goroutine 进入了一个比较尴尬的状态，它们似乎只能等待其对应的 M 从阻塞状态中释放出来才能够被重新调度执行。&lt;/p&gt;

&lt;p&gt;在了解 go scheduler 如何处理这种情况之前，我们可以根据之前的了解先自己思考一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将剩余的 goroutine 全部放入 global runable goroutine queue 中等待被调度执行&lt;/li&gt;
&lt;li&gt;进行 context switch 操作，将 P 连同剩下的 runable goroutine queue 切换到一个较为 idle 的 M 上等待被调度执行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种办法最简单暴力，但是缺点也很明显，全局队列是需要有锁参与的，效率肯定不高。第二种办法的思路来源于对 idle 状态的讨论。既然不同的 P 之前都可以 steal 彼此的 goroutine，那么为什么不能直接一次性把 P 和整个 runable goroutine queue 都拿过来呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/syscall.jpg&#34; alt=&#34;sysCall&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实际上，golang scheduler 的做法和我们想的第二种比较相似。不同的 P 之间会进行上下文切换。将已经被 block 住的 M 上挂载的 P 连同 runable goroutine queue 全部切换到到一个空闲的 M 上等待被调度执行。而之前那个被 block 住的 M 将会带着一个 G 等待被 unblock。 Unblock 之后，对于一个「最小调度单位」而言，旧的 M 和 G 显然是缺少了一个 P 的。所以它按照「之前别人对付它的方式」看是否有机会能够从其他的 M 上 steal 到一个 P 和其挂载的 runable goroutine queue。如果这个 steal 的行为失败，那么它将会把带着的 G 丢到 global runable queue 中。至于这个 M 如何被进一步处理，那又是一个新的问题了，我们在剩余的篇幅中将会提到。&lt;/p&gt;

&lt;p&gt;至此，对于 golang scheduler 调度 goroutine 的执行过程我们就大致的讲完了。对于在讨论 idle 情况的时候，我们留下的那个「为什么 global runable queue 会被保留」的问题，相信在讨论 syscall 情况的时候已经给出了答案。&lt;/p&gt;

&lt;h3 id=&#34;为什么会有空闲的-thread-在等待被使用呢-spinning-thread&#34;&gt;为什么会有空闲的 thread 在等待被使用呢？（Spinning Thread）&lt;/h3&gt;

&lt;p&gt;在讨论调度过程中关于 syscall 情况的时候，你会发现，有以下几个比较奇怪的地方：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Golang scheduler 不是会最大限度的提高 thread 的利用率么？为什么还有一个空闲的 M 在那呢？&lt;/li&gt;
&lt;li&gt;那个空闲的 M 为什么没有 P 呢？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;理论上来说，一个thread 如果完成了它所要做的事情就应该被 OS 销毁，接下来其他进程中的 thread 就可能被 CPU 调度执行。这也就是我们常说的操作系统中线程的「抢占式调度」。考虑上面 syscall 中的情况，如果一个程序现在有两个 M，其中一个因为事情做完而被销毁，另外一个因为 syscall 的原因被 block。此时，被block 的 M 上挂载的 runable goroutines 就必须要等到下一次这个 M 被 OS 调度执行的时候才会机会继续被处理。频繁的线程间的抢占操作不但会使得 OS 的负载升高，对一些对性能要求较高的程序来讲几乎是不可接受的。&lt;/p&gt;

&lt;p&gt;golang scheduler 的设计者在考虑了「 OS 的资源利用率」以及「频繁的 thread 抢占给 OS 带来的负载」之后，最终提出了「Spinning Thread」的概念。自旋线程在没有找到可供其调度执行的 goroutine 之后，并不会销毁，而是采取「自旋」的操作保存了下来。虽然看起来这是浪费了一些资源，但是考虑一下 syscall 的情景就可以知道，比起「自旋」，线程间频繁的抢占以及频繁的创建和销毁操作可能带来的危害会更大。&lt;/p&gt;

&lt;p&gt;对于一个 go 的程序来说，可存在的「Spining Thread」的数量是可以通过&lt;code&gt;runtime. GOMAXPROCS&lt;/code&gt;函数设置的。&lt;code&gt;runtime. GOMAXPROCS&lt;/code&gt;函数本意是设置最大可用的 CPU 核心数，但是仔细想想就可以明白「Spining Thread」出现的目的就是在其他 M 出现问题的时候，可以直接接管 P 继续处理 G。而 P 的概念在 golang 的调度模型中又相当于是 CPU 的一个核。所以 「Spining Thread」的数量最合适的就是和最大可用的 CPU 核心数保持一致。&lt;/p&gt;

&lt;p&gt;举例来说，在具有1个 M和1个 P的一个程序中，如果正在执行的 M 已经被 syscall block 住，那么仍然需要和 P 数量相同的「Spining Thread」才能够让等待的 runable goroutine 继续执行。所以，在此期间， M 的数量是要多余 P 的数量的（一个 Spinning Thread+一个被 block 住的 thread）。这也就是为什么，当&lt;code&gt;runtime. GOMAXPROCS&lt;/code&gt;函数设置的值为1的时候，程序仍然是处于多线程运行的状态的。&lt;/p&gt;

&lt;p&gt;根据上面的描述，「Spining Thread」是一个特殊的 M，当一个 M 具有以下几个特点中的一个的时候，它就可以被称作是一个「Spining Thread」：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;1. An M with a P assignment is looking for a runnable goroutine.
2. An M without a P assignment is looking for available Ps.
3. Scheduler also unparks an additional thread and spins it when it is readying a goroutine if there is an idle P and there are no other spinning threads.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;针对一开始我们谈到的两个问题现在也不难给出答案：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;充分提高 thread 利用率是在 runable goroutine 数量足够多的情况下，尽可能的将它们调度到 M 执行。但是当 runable goroutine 数量不会让所有的 M 都处于工作状态的时候，golang scheduler 也并不会直接把它们销毁，而是至多留出&lt;code&gt;runtime. GOMAXPROCS&lt;/code&gt;个处于 Spinning 状态的 M，等待被阻塞的 M 下挂载的 runable goroutine。这是为了避免线程间频繁的抢占操作给 OS 带来的压力，同时也尽可能的保证了 runable goroutine 能够快速的被处理&lt;/li&gt;
&lt;li&gt;空闲的 M 但是没有挂载 P 也是「Spining Thread」 中的一类&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Redis 数据持久化机制</title>
      <link>http://littledriver.net/post/2018/08/05/redis-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 05 Aug 2018 20:11:46 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/08/05/redis-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</guid>
      
        <description>

&lt;h3 id=&#34;redis-有两种持久化数据的机制&#34;&gt;Redis 有两种持久化数据的机制&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AOF： 将对数据库所有的「写操作」以追加的方式，写入一个文件当中。待 Redis 重启之后，可以通过这些指令恢复数据&lt;/li&gt;
&lt;li&gt;RDB： 以生成数据集快照的方式，全量备份数据。生成一个 dump 文件，落盘保存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种持久化机制可以同时启用，redis-server 默认在启动的时候，会使用它们持久化的数据对自身的数据集进行恢复。但是会优先使用 AOF，因为RDB 在备份的过程中，如果集群出现重启等极端现象，会丢失一部分数据。而 AOF 基本上是间隔一秒执行一次fsync，最大限度的确保不会丢失数据。&lt;/p&gt;

&lt;h3 id=&#34;rdb-持久化的大致过程&#34;&gt;RDB 持久化的大致过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;redis-server 每隔一段时间就执行一次 BGSAVE 命令&lt;/li&gt;
&lt;li&gt;redis-server 的主进程会 Fork 一个子进程进行持久化操作&lt;/li&gt;
&lt;li&gt;子进程将此时内存中的数据写入进一个临时文件中&lt;/li&gt;
&lt;li&gt;写入成功之后，原子的将旧的 rdb 文件替换为新的并删除旧的备份文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RDB持久化过程享受了 OS 中 COW （ &lt;a href=&#34;https://en.wikipedia.org/wiki/Copy-on-write&#34;&gt;Copy-on-write &lt;/a&gt;） 机制的优势。早期 Linux 内核的 Fork 过程会无脑的直接将父进程的各种资源 Copy 一份给子进程。这种旧的机制在效率上有很大的问题。但是在有了 COW 机制之后，若父进程的内存段中的内容都没有修改，那么就只会分配给子进程很少的一部分资源，如进程描述符等等。实际上此时父子进程是共享内存地址空间的，达到了资源共享的效果。若父子进程共享的内存中的内容有修改，才会真正的去复制一份内存当中的内容给子进程.&lt;/p&gt;

&lt;p&gt;所以，你会发现，在你的redis-server 没有接受任何写操作的时候，你执行 bgsave 和 save 是非常快的。但是，若你一遍在疯狂的写入数据，一边在执行bgsave或者 save，他们的执行时间就会随着写入速度的增加而增加，且有可能发生 OOM 的现象。&lt;/p&gt;

&lt;p&gt;另外还有一个问题就是：Redis 在执行 bgsave 操作的时候，如果此时还有写操作在执行，那么最新的修改会被同步到新的 RDB 的文件中么？根据 COW 的机制思考一下就可以知道，当发生写入操作之后，父子进程的实际物理内存已经分开了两份，而最终本次 RDB 操作产生的备份文件也是根据子进程内存中的内容来的，所以，可以说 RDB 执行完成后文件中的内容，就是 fork 函数执行那一刻，内存中的内容（此时，父子进程共享内存）&lt;/p&gt;

&lt;h3 id=&#34;aof-文件重写大致过程&#34;&gt;AOF 文件重写大致过程&lt;/h3&gt;

&lt;p&gt;由于 aof 文件是以追加的形式将写入命令持久化到该文件中，那么这个文件的大小应该一直是一个递增的状态。Redis 为了避免该文件过大，会按照一定的策略执行「AOF 文件重写」的操作，以此保证 aof 文件中是能够恢复数据的最小指令集&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Redis 执行 fork（），创建一个子进程&lt;/li&gt;
&lt;li&gt;子进程复制旧的 aof 文件中的内容，写入至一个临时文件中&lt;/li&gt;
&lt;li&gt;在 AOF 持久化期间，当有新的执行命令进来的时候，该命令先被缓存到内存中，然后写入到旧的 aof 文件中&lt;/li&gt;
&lt;li&gt;子进程完成对旧 aof 文件的复制，向其父进程付出「完成」信号。父进程将在内存中缓存的新执行的写入命令追加到该临时文件中&lt;/li&gt;
&lt;li&gt;原子替换旧的 AOF 文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的的是，BGSAVE 和 BGREWRITEAOF(AOF 文件重写)两个命令是不能够同时执行的。原因也很简单，两条命令的执行都会给系统造成比较大的 IO 压力。&lt;/p&gt;

&lt;h3 id=&#34;rdb-的优点与缺点&#34;&gt;RDB 的优点与缺点&lt;/h3&gt;

&lt;h4 id=&#34;优点&#34;&gt;优点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对主进程的性能没有影响：使用 RDB 在进行备份的时候通常有两个命令可供选择：SAVE 和 BGSAVE。两个操作主要的区别就在于前者会阻塞主进程，而后者是通过 fork 一个子进程来做的。在使用的过程当中，大家通常会选择 BGSAVE。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;很适合做多版本恢复：因为 RDB 是全量备份数据（snapshot），且备份的时间可以自由指定。这就给灾备和多版本备份提供了便利。而 AOF 显然是不具备这一优势的。它总是以当前 aof 文件中的操作去恢复数据，一旦Redis执行过一些清除数据的命令并发生了文件重写之后，如&lt;code&gt;FLUSHALL&lt;/code&gt; 等，那么它的记录将不再具有历史追溯性。&lt;/p&gt;

&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;全量复制：RDB 在持久化的时候，采用的是全量保存数据库的内容。若当前已经有持久化的进程在执行，那么想再次触发持久化操作是会被 ban 的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;阶段性复制：是否执行 RDB 持久化是由一些策略决定的，这也就是说，两次 RDB 持久化可能会间隔一段时间。那么在这段时间中，发生一些极端情况，如掉电等等，Redis 数据库可能会丢失一段时间的数据。这对数据完整性要求较高的使用者来说是不能够接受的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;阻塞客户端访问：在需要备份的数据集较大的时候，fork 子进程进行 RDB 持久化处理可能会耗时较长的时间，而在这段时间内，主进程是被block住的，因此，部分客户端的请求可能会被阻塞&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无法及时更新：若在执行备份操作期间还有数据写入的话，是不会影响正在执行的 RDB 备份操作的。RDB 备份的数据版本取决于 bgsave 或者 save 执行的那一刻数据库中的「快照」&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;aof-的优点与缺点&#34;&gt;AOF 的优点与缺点&lt;/h3&gt;

&lt;h4 id=&#34;优点-1&#34;&gt;优点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;AOF 默认情况下会每秒执行一次fsync，将 redis-server 的写入操作持久化到aof 文件中。最大限度的保证了数据的完整性。即使出现极端情况导致数据丢失，也只会丢失1s的数据。且执行fsync的策略是可以进行设置的，如，每次发生写入操作再进行fsync&lt;/li&gt;
&lt;li&gt;AOF 以追加的方式进行写入，不会使用seek等移动文件指针的系统调用。即使写入的命令不完整，或者有错误，也有redis-check-aof工具可以进行修复&lt;/li&gt;
&lt;li&gt;AOF 会在 aof 文件体积过大的时候进行重新，尽量缩减文件当中的命令，保证 aof 文件中的命令是能够恢复 redis-server 数据的最小集。在新的文件重写完成之后，会进行新旧 aof 切换&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;缺点-1&#34;&gt;缺点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;AOF 文件的体积通常要大于 RDB 文件的体积&lt;/li&gt;
&lt;li&gt;由于 AOF 默认每秒都在进行 fsync，那也就是说每秒都会有i/o上面的消耗&lt;/li&gt;
&lt;li&gt;坑&lt;/li&gt;
&lt;li&gt;在使用 AOF 的过程当中，我觉得是有一个「深坑」的：如果你在误操作执行了 FLUSHALL 命令之后，要么在执行 AOF 重写前到线上机器的 aof 文件中把 FLUSHALL 这行命令的记录给去掉，要么，你就只能接受，aof 文件被重写后只有一条 FLUSHALL 命令的结果了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;持久化方式的-理论最佳实践&#34;&gt;持久化方式的「理论最佳实践」&lt;/h3&gt;

&lt;p&gt;这里之所以说是理论最佳实践，是因为用户可能要根据自己的业务需求来选择合适的持久化方式。至于适不适合得经过实践的检验，但目前笔者只能给出理论上的建议。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若用户完全不关心数据的安全性（几乎把 Redis 当做memcache来使用）：那么你可以把 AOF 和 RDB 两个持久化机制都关掉。这样在大数据量的情况下，你的 Redis 的性能将会有所提升&lt;/li&gt;
&lt;li&gt;若用户可以容忍丢失一部分数据：建议只使用 RDB 的持久化方式。没必要在开启 AOF，这部分性能，资源的损耗完全没有必要&lt;/li&gt;
&lt;li&gt;若用户几乎不可以容忍丢失数据：建议 RDB 和 AOF 同时开启。为什么要同时开启而不只开启 AOF 呢？原因有二：首先 AOF 有一个坑，如果只开启 AOF，一旦踩进去，那就不是丢失个几分钟数据的事了。其次，RDB 最有用的一个优点就在于，他可以为灾备和多版本备份提供良好的支持&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>关于「争论」的一点思考</title>
      <link>http://littledriver.net/post/2018/08/05/%E5%85%B3%E4%BA%8E%E4%BA%89%E8%AE%BA%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</link>
      <pubDate>Sun, 05 Aug 2018 20:11:46 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/08/05/%E5%85%B3%E4%BA%8E%E4%BA%89%E8%AE%BA%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</guid>
      
        <description>

&lt;h1 id=&#34;关于-争论-的一点思考&#34;&gt;关于「争论」的一点思考&lt;/h1&gt;

&lt;p&gt;当我和其他人发生争论之后，我都有回家之后自己反思一下这个过程。这个行为在我18年初进入容器团队之后愈发频繁。促使我这么做的原因就是，在我和思路比我更清晰，想问题更透彻的人交流的过程中，我发现我的思考是站不住脚的。这导致我在一些问题的讨论上不占优势，不能准确的把我的想法表达出来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;简单的概括一下，核心的观点只有一个：「尽量想好和这个问题相关的全部细节再开始说话」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;改掉一个「说话不经过谨慎思考」的毛病会比较难，但是好在我的工作环境中有在这方面做得比较好的人，以至于每次讨论问题如果不下三个回合我就被对方的问题问住的时候，我就知道，这是因为我的一次思考上的缺陷，导致的一次失败的讨论。如果此时我还浑然不知的话，那么这可能就会进化为一次「争论」，因为人总是希望在讨论中说服对方，而「争论」也总是会给参与的双方造成不小的伤害。&lt;/p&gt;

&lt;p&gt;所以，不仅限于在工作当中，生活中即使和我父母，女朋友相处的时候，我也尽量做到在「全面」和「细致」的思考后再来对一个问题进行交流。因为我觉得这是一种解决问题最好的方式，也是一种最有效的沟通方式。虽然我现在还不能100%做到这一点，但是我已经意识到了，并且会提醒自己改正，甚至会影响我身边的人做一些转变，我觉得就是一个好的开始。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;通常在讨论一个问题的过程当中，我会大致按照以下的思路进行思考问题：&lt;/p&gt;

&lt;h2 id=&#34;在我是被提问者的情况下&#34;&gt;在我是被提问者的情况下&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;我会反复和提问者确认「你的问题是什么」？在这期间其实会碰到很多提问者是没有想清楚自己的问题的。犯这个毛病的包括我自己。但是当我自己做被提问者的时候我才会发觉这个问题是如此的严重&lt;/li&gt;
&lt;li&gt;我会问，你想怎么做？这个阶段主要的目的就是确认，提问者是来讨论「方案」的，还是来寻求「帮助」的。如果是寻求帮助，且时间允许，我可能会先把这个问题了解清楚再和他交流。如果是讨论「方案」，我会针对这个方案提出我的一些疑问，直到我明白了以下几点：a) 这个方案核心的逻辑是什么 b)这个方案到底能不能解决问题&lt;/li&gt;
&lt;li&gt;若这个问题我熟悉，我会想想我会怎么解决。若我觉得时间较长，可能会中断这次交流，等准备好了再进行下一次。若时间比较短，我会想好之后再和对方说明我的方案。若我对问题不熟悉，我也会直接告诉提问者，我无法帮助你
在双方第一次阐述过自己的方案之后，可能会有一些冲突。此时，我会希望和被提问者找出问题的矛盾点，看是因为对方案理解上的偏差导致的矛盾，还是方案本身就有硬伤。&lt;/li&gt;
&lt;li&gt;找出矛盾点，摆证据，为什么你的方案不行，我的行。如果我的不行，那么对方也需要摆证据，证明不行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本上在上述5个步骤执行完之后，问题是可以顺利解决的。即使在这次沟通的过程当中不能解决，那么至少能够明白是哪些问题不能解决，这对于下一次沟通是非常有帮助的。总的来说，按照上面的思路，应该会是一个比较有效的沟通方式。
但是「争论」往往都是在4，5步的过程中产生的。产生「争论」的原因挺多的，我目前也没有找到根本原因。但就经验来说，基本上有以下因素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没理解清楚对方的意图&lt;/li&gt;
&lt;li&gt;急迫的想说服对方，已经忽略了沟通的目的&lt;/li&gt;
&lt;li&gt;对方的思路本身就是混乱的，自己都没有搞清楚矛盾究竟在什么地方&lt;/li&gt;
&lt;li&gt;自己没表达清楚自己的意图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上四个因素，都是我自己在沟通的过程中遇到了以及我自己常犯的几个错误。个人觉得一个比较有效的方法，就是听人家说完了，先等个几分钟，不说话。想清楚了，或者借助一些工具，把自己的思路整理好，再开始说话。&lt;/p&gt;

&lt;h2 id=&#34;在我是提问者的情况下&#34;&gt;在我是提问者的情况下&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若我是寻求「帮助」：
我会描述清楚问题的现象以及我做的操作，我执行这些操作所处的环境
我期望的回答有三种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我遇到的问题是「预期行为」，这个预期行为包括异常的也包括正常的。总之，需要给我一个这个问题产生的原因。异常的话我等待处理，正常的话我了解之后就算结束了&lt;/li&gt;
&lt;li&gt;我遇到的问题是「非预期行为」，给我一个时间点，我回去等待处理。或者现在不能处理，要告诉我原因.&lt;/li&gt;
&lt;li&gt;我自己的操作姿势不对，没仔细看文档，或者文档本身就不全，那么直接给出我正确的姿势&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若我是寻求「方案」：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我会先描述清楚，问题是什么&lt;/li&gt;
&lt;li&gt;我会描述我的方案是什么&lt;/li&gt;
&lt;li&gt;等待对方的提问并回答提问&lt;/li&gt;
&lt;li&gt;问对方的方案。对方若没有方案，可以给出一些思路。若还没有，可以针对我的方案给出一些建议，如果能找出缺陷，那是极好的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我在作为提问者的过程当中，是被怼的最多的。当然，这也是我决定要改正这个问题的一个动机。其实上面说的一大堆，最终的目的都是要解决问题，既然要解决问题，无外乎就需要经过以下几个阶段&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;问题是什么？为什么会出现这个问题？这个问题是「问题」么？&lt;/li&gt;
&lt;li&gt;有没有解决方案？解决方案是什么？如果有多个方案我为啥要选择这个？这个方案带来的成本是什么？收益又是什么？性价比是不是最高的？对方的方案有啥致命缺陷？&lt;/li&gt;
&lt;li&gt;实施确定的解决方案需要什么资源？&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;其实，人在交流的过程当中，很难像上面说的那么理智和冷静，不然那就不是人了，而是机器。人会受到很多情绪和性格方面的影响，甚至是身体不舒服或者遇到了心烦的事，都会让这次交流失败。我其实并不是一个脾气很好的人，我也非常的易于受到情绪的影响。更重要的是，我这个人是典型的吃软不吃硬，要是真较上劲，其实我就不会在乎这个事情本身了，会把它转换为一次人和人之间的对抗。这一点，我相信我女朋友和我妈，都是有切身的体会的，我为此也经常会问她们和我交流问题的感受。
写这么多的原因，是因为最近低效且消极的交流有两次。虽然我之前在尽力避免，但是「交流失败」的结局出现的频率有点高，我就决定今天再梳理一下我交流问题的「方法论」。一个是提醒自己要尽力的进行理性交流，另外一个就是告诉自己允许「交流失败」的发生。一旦意识到，目前已经不是在寻求解决问题的办法而是在相互扯皮或者发泄情绪，应该立即停止交流。如果多次交流还解决不了，那只能交给能够对这个问题负责的人去决断了。&lt;/p&gt;

&lt;p&gt;做人，做事都是这样，问心无愧就行了。有错就改错，没错就忘了那些「不愉快」的事情即可。原则只有一个：「解决问题」&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Golang Log Level Best Pratice-1</title>
      <link>http://littledriver.net/post/2018/05/03/golang-log-level-best-pratice-1/</link>
      <pubDate>Thu, 03 May 2018 13:39:17 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/05/03/golang-log-level-best-pratice-1/</guid>
      
        <description>

&lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;

&lt;p&gt;在使用 Golang 语言开发的过程中，被广大开发者广泛使用的 Debug 方式应该就是观测服务输出的关键性日志信息了。这也就是我们俗称的「日志 Debug」 方式。虽然 Golang 也可以通过一些断点调试的方法去 Debug，这种方式在 Demo 阶段或者仅仅做一个 Experiment 的时候可能是比较好的，但是在真正的生产环境中或者说高并发的场景下，断点调试就会显得力不从心了。所以，主流的方式可能仍然是「日志 Debug」。&lt;/p&gt;

&lt;p&gt;对于 Log 的使用，可能大多数人都倾向于使用一些第三方的日志工具。毕竟 Golang 官方的 Log 库提供的功能以及对 Log 输出的可定制性都是有限的。主流的日志工具库有以下两个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sirupsen/logrus&#34;&gt;https://github.com/sirupsen/logrus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/glog&#34;&gt;https://github.com/golang/glog&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个日志工具库都提供了丰富的功能，其中一个共性的功能就是「按照级别输出日志」。因为在输出日志的时候，可能会有以下输出级别给你选择，不同的级别可能代表着这条日志输出的优先级，重要性，作用都是不同的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Error&lt;/li&gt;
&lt;li&gt;Fatal&lt;/li&gt;
&lt;li&gt;Info&lt;/li&gt;
&lt;li&gt;Warn&lt;/li&gt;
&lt;li&gt;Debug&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么在接下来的两篇关于「Golang Log」的文章当中，将会根据笔者的实践经验，在日志级别的使用以及日志库工具的使用上给出一些我自己的「Best Practice」。&lt;/p&gt;

&lt;h2 id=&#34;warn&#34;&gt;Warn&lt;/h2&gt;

&lt;p&gt;Warn 这种日志级别一直让我感觉比较困惑，按照单词的字面意思来理解，它是用来输出警告信息的。那警告这种级别到底是用于什么场景呢？如果是错误的话那应该直接用 Error，如果是简单的输出一些信息的话，那么用 Debug 和 Info 都是可以的。这样看来，Warn 这种级别就很尴尬，和其他的级别没有明显的区别，导致开发者在选择日志输出级别的时候就多了一种令人困惑的选择。如果你一直在使用 Warn 这种日志级别在输出「错误」信息的话，建议还是改成 Error 较好。最主要的原因就是，滥用 Warn 级别可能会给我们的日志造成很大的噪音，因为大家潜意识里就认为 Warn 不重要，Error 才是需要注意的。这样一来，把错误信息放在 Warn 里面输出就是非常不合适的，很有可能让我们忽略一些关键的信息。&lt;/p&gt;

&lt;p&gt;日志输出级别上的 Warn 和监控报警级别中的 Warn 显然不是一回事，前者是将输出的日志信息划分等级，以此来帮助我们追查问题和观察程序运行的情况。后者则是用来像我们报告服务的某些指标已经很接近 Error 报警的阈值，提醒我们要注意。并且监控报警中的 Warn 级别也是提倡要善用的，滥用同样会导致噪声。&lt;/p&gt;

&lt;p&gt;即使在 logrus 日志工具库中提供了 Warn 日志级别，它的注释中也对这种日志级别定义的比较模糊：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-// WarnLevel level. Non-critical entries that deserve eyes.```&#34; data-lang=&#34;// WarnLevel level. Non-critical entries that deserve eyes.```&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-// WarnLevel level. Non-critical entries that deserve eyes.```&#34; data-lang=&#34;// WarnLevel level. Non-critical entries that deserve eyes.```&#34;&gt;&amp;gt; Best Practice1: 不要在你的服务中使用 Warn 的日志级别。根据日志输出的性质不同，选择更加明确的日志级别


## Fatal

无论是 Golang Standard Library 中的 Log 库，还是 Logrus 这种第三方日志工具库，Fatal 级别的日志输出实现起来都是相同的：

1. 输出日志信息
2. 调用 ```os.Exit(1)```方法结束程序

有了上面信息，在思索一下 Golang 中内置的一些函数，就会发现，Fatal 和 Panic 只差的了一个输出信息的功能。既然涉及到了 Panic，那么就不得不对 Fatal 的使用场景做出区分了。

### 在 Library 中

在对外提供的 Package 中，社区的建议是不应该使用 Panic 的。那么很自然的，使用  Fatal 也是不合适的。道理很简单，任何一个使用你提供的 Package 的程序结束与否，都不应该由你来决定，而是需要调用者来决定。

### 在 Main 中

我们通常看到 Fatal 出现频率最高的地方估计就是启动一个 Server 的时候了：&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;s := &amp;amp;http.Server{
    Addr:           &amp;ldquo;:8080&amp;rdquo;,
    Handler:        myHandler,
    ReadTimeout:    10 * time.Second,
    WriteTimeout:   10 * time.Second,
    MaxHeaderBytes: 1 &amp;lt;&amp;lt; 20,
}
log.Fatal(s.ListenAndServe())&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;然而启动一个 Server 的逻辑也大都出现在 Main 函数中。

所以，如果要使用 Fatal ，也不要在 Library 中进行使用。即使在 Main 函数中，可能还有另外一个问题需要注意----「Gracefully Shutdown」。因为直接调用 `os.Exit` 函数，一些包含在 defer 执行的函数内的「清理」操作就都不会被执行了，所以在使用 Fatal 的时候，要注意一下「Gracefully Shutdown」的问题，尤其是在使用一些第三方的日志工具库的时候。

&amp;gt; Best Practice2: 出于对 Gracefully Shutdown 问题的考虑，尽量不要使用 Fatal 这种日志级别。若确实在程序中遇到了无法处理的错误且必须要结束程序，可以将错误一直向上抛出，直到 Main 函数中。并且在退出程序之前还需要处理好 resource clearup 的问题。


## Error

Error 这个日志级别应该是我们在开发过程中最常使用的。但是很多人在使用的过程中可能都存在一个比较大的误区，就是把 「Error Handling」 和 「Error Logging」 混淆了，甚至是将它们合二为一，用 「Error Logging」 作为 「Error Handling」的方式。
那么当我们在面对一个`error`的时候，我们有哪几种处理它的选择呢？

1. Return the caller
2. Handle at once

对于第一个选择来说，它绝不意味着下面的代码：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;if err := SayHello(); err != nil {
    logger.Error(err)
    return err
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;仔细想想上面的这段代码，它的目的是非常不清晰的。如果是想将错误抛给调用者，那么应该直接 `return err`而不是在 return 之前还要用 Error 输出一下错误信息。上面的实现方式，明显是把错误处理和错误返回混合在一起使用了，并且错误处理的方式就是----输出错误信息（(⊙﹏⊙)b。

对于第二种选择来说，如果想在调用报错的位置处理错误，如进行重试等，则可以输出错误信息并执行相应的错误处理函数&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;if err := SayHello(); err != nil {
    logger.Error(err)
    HandleError()
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;现在看来，除了在能够处理错误的地方可以输出错误信息之外，其余的地方都是不适合的。但是这仅限于 Library 和 Package 中的功能性函数里，如果是在一些对外暴露的 HTTP 接口中，在将错误信息返回给 client 之前，输出错误信息还是非常必要的。不过，如果在你的代码中，error 一直向上抛，结果抛到顶层了还没有处理他的地方，或处理不了退出整个程序的地方，可能就是你的程序有问题了。需要再仔细的检查下你代码。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;BestPractice3: 只在可以处理 Error 的位置输出 Error 信息，无法处理 Error 就应该把 Error 抛给调用者&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;info-debug&#34;&gt;Info &amp;amp;&amp;amp; Debug&lt;/h2&gt;

&lt;p&gt;Info 级别应该是除 Error 级别用的最多的一个了，从字面上的意思就可以知道，Info 是用来输出信息的，这些信息不属于 Error。Debug 同样可以用来输出一些我们关心的信息，那么针对这两者在使用上我们应该如何区分呢？&lt;/p&gt;

&lt;p&gt;作为一个服务的实现者，应该考虑如下几个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;什么样的信息是你关心的？也就是在开发的过程中那些对你有用的信息，在服务运行的过程中能够帮助你观测其运行情况的信息&lt;/li&gt;
&lt;li&gt;什么样的信息是使用你服务的人关心的？也就是你的 Package 开发完成之后的使用者关心的信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;思考过上面的两个问题，相信对于 Info 和 Debug 的使用你已经有了自己的主意。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;BestPractice4: 输出开发者关心的信息使用 Debug，输出用户关心的信息使用 Info。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>gRPC Deadline Explanation</title>
      <link>http://littledriver.net/post/2018/04/21/grpc-deadline-explanation/</link>
      <pubDate>Sat, 21 Apr 2018 21:23:55 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/04/21/grpc-deadline-explanation/</guid>
      
        <description>

&lt;h2 id=&#34;什么是-grpc-deadline&#34;&gt;什么是 gRPC Deadline&lt;/h2&gt;

&lt;p&gt;gRPC 框架中的 Deadline 的概念主要是针对于客户端而言的。它表明了一个 RPC 请求在完成之前或者被错误终止之前，gRPC client 需要等待多长时间。如果我们在使用 gRPC 框架进行 RPC 请求的时候没有指定这个值，它的默认值是依赖于不同编程语言的实现的。理论上来说， 若不指定，应该是一个非常大的值。&lt;/p&gt;

&lt;h2 id=&#34;为什么要设置-deadline&#34;&gt;为什么要设置 Deadline&lt;/h2&gt;

&lt;p&gt;一个 RPC 请求的处理端大部分是我们所实现的一个服务，如果此时客户端请求不设置 Deadline，那么服务端的资源就会一直被占用（如内存，CPU，网络端口等），而且，任意一个客户端请求都可能会达到默认的 Deadline 最大值。&lt;/p&gt;

&lt;h2 id=&#34;什么是一个合适的-deadline-值&#34;&gt;什么是一个合适的 Deadline 值&lt;/h2&gt;

&lt;p&gt;对于 Deadline 值的设定，gRPC 官方的文档中并没有给出一个具体的最佳实践。仔细一想，这也是比较正确的。因为使用 gRPC 框架的服务性质各不相同，所以一个「最佳」的值，即使给出来也是没有多的意义的。所以，我们就得出了一个结论：「Deadline 的最佳值是和业务紧密相关的」。&lt;/p&gt;

&lt;p&gt;上面在提到「为什么要设置 Deadline 值」的时候，我们举了一个客户端和服务端的例子。但其实在真正的工业环境当中，gRPC 请求的通信双方基本上同时扮演着客户端和服务端的角色。在请求过程中角色的不同，就导致他们是相互独立的两个个体。对于一次请求来说，它是否成功可能在服务端和客户端上的认知上是有差异的。如，一个请求从 A 发送至 B，B 处理完成之后发送 Response。此时 B 会认为本次的 RPC 请求已经成功结束。但是，由于各种各样的问题，该 Response 可能没有按时到达 A 端。那么 A 在等待这个回应的时候很有可能过了它设置的 Deadline 值，或者是默认值。此时，A 会认为本次请求失败。在理解这里的时候，如果联想一些「TCP 三次握手」以及「全双工通信」的原理，迁移一下就会很容易明白了。对于这个问题，gRPC官方的文档中是建议我们能够在 Application Layer 去检查和解决他们。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PS: 笔者在使用 gRPC 框架到公司的项目中时，也被这个问题搞得非常的头疼。一开始是觉得官方肯定会给出一个 Deadline 的最佳实践的，然而并没有。这种客户端和服务端对一次 RPC 请求成功与否的认知差别，会在服务刚刚设置这个 Deadline 的时候稳定性会受到一定的影响。由于是和网络请求相关联的值，那么它受到网络环境好坏的影响也是非常大的。所以，笔者觉得这个 Deadline 的值是要定期去审视和修改的。因为随着业务的变动，同一个请求所需要的时间会有所变化，而且这个时间的设置一定程度上还要对网络环境进行容错。目前觉得最好的时间就是对服务的 gRPC 请求增加可视化监控，监测 &lt;code&gt;DEADLINE_EXCEEDED&lt;/code&gt;出现的比例。如果发生了陡增的现象，那么就提醒你可能要重新调整 Deadline 的阈值了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;一些-bestpractice&#34;&gt;一些 BestPractice&lt;/h2&gt;

&lt;p&gt;首先是来自官方文档中的一些最佳实践（具体代码不列举了，主要说一些这些实践最佳在哪里）&lt;/p&gt;

&lt;p&gt;以 Go 语言举例。对于使用 gRPC 框架创建的服务端来说，都会有一个 &lt;code&gt;context.Context&lt;/code&gt; 的参数从客户端的请求中传递过来。服务端可以在这个参数中获取到客户端的有关信息。那么我们想一下这个问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果客户端已经主动断开连接取消了这次请求，那么服务端还有必要去执行接下来的处理逻辑么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于这个问题，简单的考虑有必要和没必要是不正确的。笔者认为正确的思考方式是要去仔细的分析你服务端的方法中处理的请求有哪些特质。比如，你的请求可能有如下的特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;「资源收割机」，往往是耗费服务端资源的大户&lt;/li&gt;
&lt;li&gt;请求响应内容的时效性不重要，但是稳定性和性能极其重要&lt;/li&gt;
&lt;li&gt;非常要求时效性&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;如果你的请求同时具有1-2两个特点-那么对于上面所提出的问题-回答应该是有必要的&#34;&gt;如果你的请求同时具有1，2两个特点，那么对于上面所提出的问题，回答应该是有必要的。&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;最佳实践1：当你的请求不要求时效性，且很耗费资源的时候。如果客户端取消了 gRPC 请求，那么服务端仍然可以继续处理这个请求，并把请求的结果缓存起来(如按照 key-value 的形式)。这样下次同样的请求过来就可以更快的进行回复&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;如果你的请求通知具有1-3两个特点-那么对于上面所提出的问题-回答是没有必要的&#34;&gt;如果你的请求通知具有1，3两个特点，那么对于上面所提出的问题，回答是没有必要的&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;最佳实现2： 当你的请求非常要求时效性，且很耗费资源的时候。如果客户端取消了 gRPC 请求，服务端没必要在进行处理。所以正确的做法是在服务端执行处理请求的逻辑之前检测请求带过来的 context 参数是否已经处于异常状态，如：超时，取消等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;if ctx.Err() == context.Canceled {
	return status.New(codepb.CANCELLED, &amp;#34;Client cancelled, abandoning.&amp;#34;)

if ctx.Err() == context.DeadlineExceeded {
	return status.New(codepb.DEADLINEEXCEEDED, &amp;#34;Client deadline exceeded.&amp;#34;)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;如果你的服务经常在功能上需要变动-那么你应该对你服务中的-grpc-请求增加监控&#34;&gt;如果你的服务经常在功能上需要变动，那么你应该对你服务中的 gRPC 请求增加监控&lt;/h3&gt;

&lt;p&gt;正如我在「什么是一个合适的 Deadline」 一节中提到的那样。如果我们的服务功能经常会有变化，那我们一定要对 gRPC 的请求增加监控，在功能变化的前后要密切注意各项指标，尤其是 gRPC ErrorCode 出现的比例。因为很可能你之前设置的 Deadline 时间是100ms，但是随着服务功能的复杂化，100ms 显然不够用了，这个时候，客户端对于和这个功能有关的请求可能会出现大量的报错。&lt;/p&gt;

&lt;p&gt;针对 go+gRPC 的组合来讲，目前比较推荐的监控方案就是 Prometheus+Grafana+go-grpc—prometheus。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>记一次追查 gRPC Server 报错的过程</title>
      <link>http://littledriver.net/post/2018/04/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BF%BD%E6%9F%A5-grpc-server-%E6%8A%A5%E9%94%99%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Thu, 19 Apr 2018 23:56:41 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2018/04/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BF%BD%E6%9F%A5-grpc-server-%E6%8A%A5%E9%94%99%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      
        <description></description>
      
    </item>
    
    <item>
      <title>Kubernetes pod schedular strategy</title>
      <link>http://littledriver.net/post/2018/04/17/kubernetes-pod-schedular-strategy/</link>
      <pubDate>Tue, 17 Apr 2018 14:34:48 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2018/04/17/kubernetes-pod-schedular-strategy/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;在 k8s 中，调度 Pod 到 Node 上通常是不需要我们关心的。K8s 会自动的帮我们寻找具有合适资源的 Node，并且 Pod调度在上面。但是，有的时候，我们需要将 Pod 调度到一些特定的 Node 上面，比如一些挂在了 SSD 硬盘的 Node。因为有这样的需求，k8s 可以让我们自己控制 Pod 调度至 Node 的策略。这些策略是通过 labelSelector 来实现的。&lt;/p&gt;

&lt;h1 id=&#34;nodeselector&#34;&gt;NodeSelector&lt;/h1&gt;

&lt;p&gt;NodeSelector 是PodSpec 中的一个 Field。它是一个 key-value 的 pair。key 对应了 Node 中的 label，value 对应了Node 中的 labelValue。当这个 Pod 被创建之后，k8s 会按照这个 nodeSelector 的规则在集群中进行匹配，找到合适的 Node 进行调度。否则，这个 Pod 将不会被成功调度并且会报错： No nodes are available that match all of the following predicates&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;affinity-and-anti-affinity&#34;&gt;Affinity and anti-affinity&lt;/h1&gt;

&lt;p&gt;Affinity（anti-affinity） 是对 NodeSelector 的一种功能上的扩展，NodeSelector 可以做到的东西，它一样可以做到。功能上的加强有以下几个方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不仅支持对单个的 key-value pair进行匹配，还支持逻辑运算的语义。如 AND 等&lt;/li&gt;
&lt;li&gt;设置的调度策略将分为：强制和非强制两种类型。强制类型则和 NodeSelector 的功能一样，如果匹配失败，那么也就意味着调度失败。非强制类型则优先会匹配设置好的策略，如果没有匹配成功，k8s 会自动按照它的默认策略调度 Pod 至 Node 上。&lt;/li&gt;
&lt;li&gt;调度策略可供设置的粒度更细，不但支持 NodeLabel 粒度的，还支持 PodLabel 粒度的。这也就是说，我们不但可以根据 Node 本身的 label 设置调度策略，还可以根据目标 Node 上所运行的 PodLabel 设置。如 RedisAPP 中，主从节点的 Pod 肯定是不能被调度到一个 Node 上的。这个功能的产生，主要是考虑到了同一个 Node 上面运行的 Pod 之间会有业务上的影响&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;node-affinity&#34;&gt;Node affinity&lt;/h2&gt;

&lt;p&gt;NodeAffinity 分为两种类型：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;li&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前者的作用和 NodeSelector 一样，可以认为这是一个强制的策略：如果 Pod 在调度的时候，NodeAffnity 没有成功匹配到任何 Node 的 Label，那么这个 Pod 将会调度失败。而后者则是一个「软性」的策略，虽然会按照 NodeAffinity 设置的策略进行匹配，但是它最终保证的是 Pod 调度成功。如果设置的 NodeAffinity 匹配失败，Pod 会按照 k8s 默认的策略进行调度。&lt;/p&gt;

&lt;h2 id=&#34;inter-pod-affinity-and-anti-affinity&#34;&gt;Inter-pod affinity and anti-affinity&lt;/h2&gt;

&lt;p&gt;对于pod affinity and anti-affinity来说，调度策略同样分为两种类型：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;li&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（其实 Node affinity 也是有 anti-affinty 的，只不过它是通过 matchExpressions 中的 NotIn 等否定的 Operator 来实现的）&lt;/p&gt;

&lt;p&gt;Pod 粒度的调度策略，增加了一个新的概念：topologyKey&lt;/p&gt;

&lt;h3 id=&#34;topologykey&#34;&gt;topologyKey&lt;/h3&gt;

&lt;p&gt;Pod 粒度的调度策略，是根据 Pod 的 Label来进行制定的。但是Pod本身受到来自两个方面的限制：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;namespace&lt;/li&gt;
&lt;li&gt;node&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在使用 PodLabel 的时候，必须要限定 Pod 所在的 Namespace，否则匹配是没有意义的。其次，在 Pod 粒度的调度策略中，可以通过topologyKey（通过 NodeLabel 实现）指定一组 Node，这些 Node 上可能每一台都有与调度策略匹配的 Pod，也可能没有。但是 Pod 都可以调度到这一组的任何一个 Node 上。因为这里强调的可调度 Node 单位不再是一台 Node，而是一组 Node。举例来说：&lt;/p&gt;

&lt;p&gt;集群中现在有两个 Node（A， B），他们都有一个 Label 为 kubernetes.io/hostname=abc。 现在 A 上有一个 Pod，label 为 app=poda。此时被调度的 Pod 的调度策略为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;podAffinity:
  requiredDuringSchedulingIgnoredDuringExecution:
  - labelSelector:
      matchExpressions:
      - key: app
        operator: In
        values:
        - poda
    topologyKey: kubernetes.io/hostname&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;此时这条调度策略可以做如下翻译：&lt;/p&gt;

&lt;p&gt;Pod 可以被调度到一组 Node 的任意一个 Node上，当这些 Node 具有 kubernetes.io/hostname Label, 并且与 PodLabel 为 poda 的 Pod 所在 Node 的 kubernetes.io/hostname Label 的值相同。用英文可能更好表述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;My Pod should run in the same kubernetes.io/hostname as a poda Pod.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果上面的调度策略换成了 &lt;code&gt;podAntiAffinity&lt;/code&gt;, 则翻译成：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;My Pod should not run in the same kubernetes.io/hostname as a poda Pod&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说，当一个 Pod 配置了 Affinity 调度策略且指定了 topologyKey 字段的时候，我们可以做如下理解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先通过 PodAffinity 或者 PodAntiAffinity 中的 labelSelector 找到匹配的 Pod，根据这些 Pod 初步筛选出一部分 Node&lt;/li&gt;
&lt;li&gt;如果指定的是 Affinity，那么可被调度的 Node 中与 topologyKey 同名的 label 的 value 必须和已匹配的 Pod 所在 Node 相应的 Label 值相等&lt;/li&gt;
&lt;li&gt;如果指定的是 AntiAffinity，则正好相反&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;更详细的关于 topologyKey 的描述，可以看下这篇&lt;a href=&#34;https://medium.com/kokster/scheduling-in-kubernetes-part-2-pod-affinity-c2b217312ae1&#34;&gt;blog&lt;/a&gt;:&lt;/p&gt;

&lt;h1 id=&#34;example-在具有-redis-实例的-node-上部署-webserver&#34;&gt;Example&amp;ndash;在具有 Redis 实例的 Node 上部署 WebServer&lt;/h1&gt;

&lt;p&gt;前提：实例中所用集群Node 数量为3&lt;/p&gt;

&lt;h3 id=&#34;redis&#34;&gt;Redis&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;apiVersion: apps/v1beta1 # for versions before 1.6.0 use extensions/v1beta1
kind: Deployment
metadata:
  name: redis-cache
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: store
    spec:
      containers:
      - name: redis-server
        image: redis:3.2-alpine&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;首先在集群的三个节点上以 Deployment 的方式部署三个 redis 实例，PodLabel 为 app：store&lt;/p&gt;

&lt;h3 id=&#34;webserver&#34;&gt;webServer&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;apiVersion: apps/v1beta1 # for versions before 1.6.0 use extensions/v1beta1
kind: Deployment
metadata:
  name: web-server
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: web-store
    spec:
      affinity:
        podAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - store
            topologyKey: &amp;#34;kubernetes.io/hostname&amp;#34;
      containers:
      - name: web-app&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;部署 Webserver 的时候，指定 PodAffinity 调度策略，要求目的 Node 与运行 PodLabel 为 app=store 的 Pod的 Node 在同一个分组，分组标准为kubernetes.io/hostname的 NodeLabel。此时，当被调度 Pod 数小于等于集群 Node 数时，会对策略匹配成功的 Node 节点进行轮询选取。否则，可能会出现多个Pod 被调度到同一个 Node 上的情况。&lt;/p&gt;

&lt;p&gt;最终调度结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/image2018-2-26_17-40-16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;highavailible&#34;&gt;HighAvailible&lt;/h1&gt;

&lt;p&gt;对于数据库等具有主从关系的 APP 集群来说，在使用 StatefulSets 部署时，一般都不希望多个实例共存至同一个 Node 上。原因很简单，整个集群挂掉的风险比较高。我们可以通过 Inter-Pod Anti-Affinity来实现这一目的。&lt;/p&gt;

&lt;p&gt;使用 requiredDuringSchedulingIgnoredDuringExecution 类型的 Anti-Affinity 策略，指定PodLabel 为被调度 Pod 的 Label。这样一来，在 Pod 被调度的过程当中，PodLabel 相同的 Pod 就属于互斥的关系。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Redis Sentinel Explanation 1</title>
      <link>http://littledriver.net/post/2018/04/01/redis-sentinel-explanation-1/</link>
      <pubDate>Sun, 01 Apr 2018 19:49:35 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2018/04/01/redis-sentinel-explanation-1/</guid>
      
        <description>

&lt;h1 id=&#34;什么是-sentinel&#34;&gt;什么是 Sentinel?&lt;/h1&gt;

&lt;p&gt;Sentinel 这个词在 Redis 中有很多不同的含义，它可以代表 Redis 的一种高可用的方案，也可以代表一个以 Sentinel 模式启动的 Redis 实例，甚至是可以代表你的 Redis 集群中，多个以 Sentinel 模式启动的 Redis 实例集合。我们可以这样来理解和定义 Sentinel：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sentinel 是一套方案。它在集群模式下为我们的 Redis 集群提供了「高可用」的保证。
Sentinel 也是一个小型的分布式系统，在多个 Sentinel Process 的协同作战下，保证了 Redis 集群的「高可用」。减少故障误报率，在部分 Sentinel Process 异常的情况下，仍能够为集群提供可靠的服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;sentinel-都有哪些功能&#34;&gt;Sentinel 都有哪些功能？&lt;/h1&gt;

&lt;p&gt;上面说到，Sentinel 为我们的 Redis 提供「高可用」的保证。那么，他提供了哪些措施去实现「高可用」呢？让我们首先来看一下，在没有 Sentinel 的时候，使用一主一从的模式部署我们的 Redis 集群，可能会在使用上遇到哪些问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;健康检测（monitor）：我们需要一个可靠的检测机制去观察 Redis 实例的健康状态&lt;/li&gt;
&lt;li&gt;通知（notification）：当 Redis 实例发生故障的时候，我们需要一个可靠的通知机制来告知集群的管理者&lt;/li&gt;
&lt;li&gt;故障自动处理（failover）：一些简单的，处理方式可以被固化的故障能够自动被修复。一方面，能够最大限度的保证集群对用户的可用性，另外一方面，能够加快故障处理速度，减轻维护者的负担&lt;/li&gt;
&lt;li&gt;负载均衡（LB）：当集群发生故障的时候，如果进行了主从切换，那么要把最新可用的 Master 节点地址通知给用户&lt;/li&gt;
&lt;li&gt;服务发现（Service discovery）：自动的查找并监控集群内所有的实例，不需要人工去配置所有的监控关系&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sentinel 基本上是从以上五个维度对 Redis 做了「高可用」的保证。相对于 Mysql 来说，Redis 的「高可用」方案采取了和集群本身的实例分离的方式来做。也就是说，「高可用」的逻辑并没有和数据节点的逻辑混杂在一起。这一点在部署使用 Sentinel 方案的 Redis 集群就可以看出来：数据节点和 Sentinel 节点是需要分开部署的，使用的配置文件也是不一样的。&lt;/p&gt;

&lt;h1 id=&#34;部署-sentinel-须知&#34;&gt;部署 Sentinel 须知&lt;/h1&gt;

&lt;p&gt;在使用 Sentinel 方案部署你的 Redis 集群之前，你需要注意以下几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以 Sentinel 模式启动的节点必须不少于三个，且这三个节点部署在物理机或者虚拟机的时候，需要采用反亲和性的配置（两个 Sentinel 节点不能部署在同一台机器上）&lt;/li&gt;
&lt;li&gt;如果你在 Docker 中部署 Redis，或者是使用了某些特殊的网络方案，就需要额外的注意，因为这可能会影响 Sentinel 的 Service discovery 机制（后面会详细介绍）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个最基本的 Sentinel 节点启动配置文件如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;sentinel monitor mymaster 127.0.0.1 6379 2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;你需要为你的 Sentinel 节点指定集群中 Master 节点的地址，端口号，还有一个 quorum 值。这个 quorum 值是和 Sentinel 的健康监测，故障自动处理的功能息息相关的，它的值取决于在你的集群中部署了多少个 Sentinel 节点。具体的作用，我们在之后介绍健康监测和故障自动处理时再来说，此时，你只需要知道，当你最少部署了3个 Sentinel 节点的时候，这个 quorum 值应该为2。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;sentinel down-after-milliseconds mymaster 60000&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;你需要告知 Sentinel 节点，多少时间之后，它监控的实例没反应了，才认为这个实例已经 down 掉了。时间单位为毫秒。Sentinel 通过 Redis 中的 PING 命令去探测其他的 Redis 实例是否正常。当在down-after-milliseconds时间内，对方没有回复 PING 命令，或者回复报错，那么都会认为这个实例已经 down 了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个值的设置其实还是很关键的，笔者目前没有找到什么最佳实践。因为这个值直接取决于 Sentinel 对故障的敏感度，如果设置的过大，那么可能一些故障要过很久才会被发现，如果设置的过小，那么可能会出现误报的现象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;sentinel failover-timeout mymaster 180000&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Sentinel 在进行故障自动处理的时候，会设置一个超时时间。也就是说，如果故障自动处理的过程没有在 failover-timeout 规定的时间内完成的话，就认为本次的故障处理已经超时失败了。虽然看起来这是一个全局性的参数，但是它实际上会对 Sentinel 故障转移的各个阶段都会有用。
首先来梳理一下，Sentinel 发起一个故障转移，都有哪些过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;选出合适的从节点&lt;/li&gt;
&lt;li&gt;提升该从节点为主节点&lt;/li&gt;
&lt;li&gt;命令其他从节点与新的主节点进行数据同步&lt;/li&gt;
&lt;li&gt;待旧的主节点重新启动为从节点时，命令其与新的主节点进行数据同步&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;「故障转移超时」参数针对这几个阶段的作用如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果在超时时间内无法选出合适的从节点，则判定本次故障转移失败&lt;/li&gt;
&lt;li&gt;如果在超时时间内没有对选举出来的从节点提升为主节点，则判定本次故障转移失败&lt;/li&gt;
&lt;li&gt;提升从节点为主节点后，Sentinel 还会使用 INFO 命令去确认，它所提升的这个从节点是否真正已经成为了主节点。如果在超时时间内，这个检查没有通过，则判定本次故障转移失败&lt;/li&gt;
&lt;li&gt;如果在超时时间内，其他从节点与主节点的数据同步没有完成，则判定本次故障转移失败&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最重要的一点：当本次故障转移失败之后，下一次 Sentinel 的故障转移超时时间将会是当前的两倍。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;sentinel parallel-syncs mymaster 1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;parallel-syncs 值是同一时刻，向 master 节点进行数据同步的 slave 节点个数。parallel-syncs 值的大小，会直接影响到两个方面：
1. 故障自动处理的时间
2. 主节点机器的资源负载，从节点的可用性
当发生了故障处理的时候，主从切换之后，新的 slave 节点要向新的 master 节点进行数据同步，只要等到所有的slave 节点的数据同步操作完成之后，才认为故障自动处理完成。所以，该值设置的越大，故障处理的时间就会越短，反之，故障处理的时间就会边长。&lt;/p&gt;

&lt;p&gt;如果从数据复制的层面上来考虑，Redis 数据库在做数据同步的时候，采用的是异步的方式。虽然不会阻塞master，但是多个 slave 同时向 master发起数据同步请求，对 master 所在机器的资源开销是非常大的一个压力。同时，slave 在 load 大量数据的时候，可能会停止对正常命令的响应，外部表现会不可用。所以，parallel-syncs我们一般都设置为1。&lt;/p&gt;

&lt;p&gt;最终在启动 Sentinel 的时候，我们使用如下的命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;redis-server /path/to/sentinel.conf --sentinel&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Sentinel 是一套为 Redis 量身定制的「高可用」方案，它采用单独的节点即外部方案来实现，并没有把实现「高可用」的逻辑和主要数据逻辑放在一起。&lt;/li&gt;
&lt;li&gt;从Sentinel 的启动方式上来看，一个 Sentinel 进程只不过是一个用了特殊配置的 Redis-server。它和 master, slave 的 redis-server 没有任何的区别，只不过由于配置文件不同，启用了不同的功能。这样理解，一个一主一从的 redis 集群，是由至少5个 redis-server 构成的。&lt;/li&gt;
&lt;li&gt;Sentinel 判断其他 Redis 实例故障和我们平时开发过程中手动判断的方法一样，都是使用 PING 命令。&lt;/li&gt;
&lt;li&gt;Sentinel 提供了一套服务发现机制，自动的去获取集群中所有实例的情况并加以监控。但是在 docker 以及特殊的网络方案下，这个机制可能会受到影响，使用的过程中需要额外的注意&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>k8s 之 StatefulSets</title>
      <link>http://littledriver.net/post/2018/02/24/k8s-%E4%B9%8B-statefulsets/</link>
      <pubDate>Sat, 24 Feb 2018 17:13:44 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2018/02/24/k8s-%E4%B9%8B-statefulsets/</guid>
      
        <description>&lt;p&gt;Q： 什么是 StatefulSets？&lt;/p&gt;

&lt;p&gt;A:    StatefulSets 是一种 workload。k8s 中的一个 workload 通常由 CRD 和 controller 两部分构成，CRD 交由用户使用，创建资源实例，描述对资源期望的状态。而 controller 主要负责保证资源的状态与用户的期望是一致的。StatefulSets 和 deployment 有着相似的作用，提供了 pod 的部署操作和相应的扩缩容操作。但是与 deployment 不同的是：statefulsets可以保证 pod 的操作顺序，这些操作包括创建，终止，更新。在 StatefulSets 中每一个 Pod 都有一个唯一的标识符，即使内部的容器运行的 app 相同，两个 pod 也是不能够互换的。这也是 StatefulSets 可以保证 pod 启停顺序的一个原因。&lt;/p&gt;

&lt;p&gt;Q: StatefulSets有哪些特性？他们是通过什么来保证这些特性正常的？&lt;/p&gt;

&lt;p&gt;A:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网络方面：通过 headless service来提供 StatefulSets 中 pod 的访问&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;存储方面：通过 PersistentVolume Provisioner 来提供静态存储，最大限度保证 pod 数据的安全，即使 pod 或者 statefulsets 被删除或者更新，其中的数据也并不会丢失&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;业务方面：通过 Ordinal Index + Stable Network ID + Stable Storage 来唯一的标识一个 Pod。 标识一个 Pod 的组成元素，也侧面反映了 StatefulSets 的特性。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Q: 如何使用StatefulSets？它包含哪几部分？&lt;/p&gt;

&lt;p&gt;A:  以 yaml 文件的方式举例，当我们想创建一个 nginx 的 StatefulSets 的时候，需要填充以下几部分信息&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HeadlessService：创建 headless 类型的 Service 进行服务发现, 负责解析请求到具体的 Pod 上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Container Sepc：指定 StatefulSets 内 pod 中容器的相关设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;volumeClaimTemplates：指定用于 StatefulSets 中 pod 的存储设置&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None
  selector:
    app: nginx
---
apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  name: web
spec:
  serviceName: &amp;#34;nginx&amp;#34;
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      terminationGracePeriodSeconds: 10
      containers:
      - name: nginx
        image: gcr.io/google_containers/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ &amp;#34;ReadWriteOnce&amp;#34; ]
      storageClassName: my-storage-class
      resources:
        requests:
          storage: 1Gi&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Q: 在一个 StatefulSets 中，如何按照顺序操作 Pod？&lt;/p&gt;

&lt;p&gt;A: 按顺序操作一系列对象的时候，最直接的办法就是给这些被操作对象加上序号。处理的时候，按照序号的顺序即可。不过在 StatefulSets 中不仅仅只用0， 1， 2这样的序号来标识 Pod。而是通过序号+hostname+pod 所使用的存储路径。为什么要这么麻烦呢？这和上面提到的 StatefulSets 的特性是相关的。首先，StatefulSets 中的 Pod 是不可被随意替换的，即使一个 Pod 发生了终止，更新等对Pod 状态有影响的操作，当 k8s将它恢复的时候，它的标识并没有改变。沿着这个思路接着思考，可以发现，因为 Pod 是不稳定的，随时会发生变化，只要pod 一变化，那么它的 IP 就有可能会变。各个 pod 之前的启停本来就是有顺序的，像 Redis 这种 app，用户可能操作的就必须是主节点，也就是说，操作的 pod 是特定的。基于对这些情况的考虑，我们加入一个 headless service，使用 k8s 中的 dns 相关功能，通过不变的pod 标识符，即可找到对应的 pod。最后一点，StatefulSets 为其内部的 pod 在 node 上提供了稳定的存储，使得数据不会轻易丢失。即使对应的 pod 或者 statefulsets 被删除了，这些存储依然不会被回收。综上所述，通过序号+hostname+存储地址，在 StatefulSets 中表示一个 Pod 是完全可以的。有了可靠的序号生成方式之后，排序和按序处理的问题也就迎刃而解了。&lt;/p&gt;

&lt;p&gt;Q: 在一个 StatefulSets 中, 按照什么顺序操作 Pod?&lt;/p&gt;

&lt;p&gt;A: 操作 Pod 分为以下几种情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;部署：按照[0, N)的顺序进行部署。部署当前一个 Pod 的时候，其所有前序 Pod 必须是部署完成且可用的状态，它才能够被正常部署。如现在部署 C，但是在 B 成功部署之后 A 挂了，这个时候 C 是不能部署的。
终止：按照[N-1, 0]的顺序进行终止。终止和部署的不同之处在于，在终止当前 Pod 的时候，它需要观察前后的 Pod 状态是否都是符合「预期」的。比如现在要终止 B，那么 B 成功被终止的条件就是 C 已经处于终止状态，A 现在是健康的可用状态。A 和 C 有任何一个状态不满足预期，B 都是不能够正常进行被终止的操作的。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Q: 如果 Pod 的配置有变化，StatefulSets 如何更新其包含的 Pod?&lt;/p&gt;

&lt;p&gt;A: StatefulSets中更新 Pod 的策略，大致分为几种类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;全自动： RollingUpdate，当 spec.template 中的配置发生变化，会自动对 pod 进行更新
半自动： Partition，功能上类似 NodeSelector，可以指定一个partition阈值，所有 pod 的序号大于等于这个阈值的都会被自动更新，否则，剩余的 Pod 不但不会被自动处理。手动终止掉某个 Pod，StatefulSets 在重启这个 pod 之后也会维持之前的版本。
手动：OnDelete，在 sepc.template 的配置被修改之后，手动结束掉 pod，StatefulSets 在重启这个 pod 的时候会使用最新的配置&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Kubernetes 之 Operator(一)</title>
      <link>http://littledriver.net/post/2018/01/24/kubernetes-%E4%B9%8B-operator%E4%B8%80/</link>
      <pubDate>Wed, 24 Jan 2018 22:19:11 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2018/01/24/kubernetes-%E4%B9%8B-operator%E4%B8%80/</guid>
      
        <description>

&lt;h4 id=&#34;q-什么是-operator&#34;&gt;Q: 什么是 Operator?&lt;/h4&gt;

&lt;h4 id=&#34;a&#34;&gt;A:&lt;/h4&gt;

&lt;p&gt;Operator 在 k8s 系统中可以认为他是一个集 resource 和 controller 的结合体。他是对 resource 和 controller 的一个高度的抽象。通过扩展 Kubernetes API来达到这一效果。&lt;/p&gt;

&lt;h4 id=&#34;q-operator-是如何工作的&#34;&gt;Q: Operator 是如何工作的？&lt;/h4&gt;

&lt;h4 id=&#34;a-1&#34;&gt;A:&lt;/h4&gt;

&lt;p&gt;在 k8s 组件的架构中，可以将 Operator 理解为用户和 resource 之间的一个桥梁。而用户想对 resource 做什么操作的话，需要先通过调用 API Server，将请求转发到 Operator 的身上（这里可能说的不准确， operator 是通过监听 API Server 上对于其创建的资源所做的操作来进行响应的）。通过这样的理解，我们就可以看出，operator 一方面需要管理部署在集群 node 中的应用，另外一方面需要与 API Server 进行交互，以便响应用户的需求。在 CoreOS 的官网上，同样给出了这样一个文档，里面以 etcd 这个 operator为例，描述了 operator 具体的工作模式。 &lt;a href=&#34;https://coreos.com/operators/&#34;&gt;Kubernetes Operators&lt;/a&gt;，总结下来无非就是三个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;观察资源目前的状态&lt;/li&gt;
&lt;li&gt;对比资源期望的状态&lt;/li&gt;
&lt;li&gt;将资源目前的状态 Fix 到期望的状态&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;q-operator-存在的意义是什么&#34;&gt;Q: Operator 存在的意义是什么？&lt;/h4&gt;

&lt;h4 id=&#34;a-2&#34;&gt;A:&lt;/h4&gt;

&lt;p&gt;笔者认为，从 Operator 的使用角度来讲，它最大的意义就是代替操作手册，代替人工去维护部署在集群上面的多个应用。应用的个数越多，运维这些应用的成本越高(如特定的领域知识)，越能够体现出一个 Operator 的价值。Operator 是基于 controller 的，也就是说，Operator 提供的功能会比 controller 本身更加强大，甚至是融合了一些特定业务场景的知识。&lt;/p&gt;

&lt;h4 id=&#34;q-开发一个-operator-前需要知道什么&#34;&gt;Q: 开发一个 Operator 前需要知道什么？&lt;/h4&gt;

&lt;h4 id=&#34;a-开发一个-operator-需要基于-kubernetes-中的两个概念&#34;&gt;A: 开发一个 Operator 需要基于 Kubernetes 中的两个概念：&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;1. resource
2. controller&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;CoreOs中的文档中简要的概括了一个 Operator 的开发内容：
An Operator builds upon the basic Kubernetes resource and controller concepts and adds a set of knowledge or configuration that allows the Operator to execute common application tasks。&lt;/p&gt;

&lt;h4 id=&#34;q-什么是-kubernetes-object&#34;&gt;Q: 什么是 Kubernetes Object？&lt;/h4&gt;

&lt;h4 id=&#34;a-一个-kubernetes-object-是-k8s-系统中的一个实际存在的对象-它包含了三个部分&#34;&gt;A: 一个 Kubernetes Object 是 k8s 系统中的一个实际存在的对象。它包含了三个部分：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;运行的容器应用是什么&lt;/li&gt;
&lt;li&gt;容器应用运行所需要的资源&lt;/li&gt;
&lt;li&gt;容器应用各种行为的策略，如重启，更新等
在官网的文档中提到，Kubernetes Object 实际上是一种「意图的记录」，这个「意图」就是我们想让这些部署在 k8s 集群中的 app 以一个什么样的状态运行。也就是说，当我们创建了一个 Kubernetes Object 的时候，我们就相当于告诉 k8s system，这些应用在集群当中的期望状态（desired state）是什么。其实在之前学习 k8s 的过程当中，我们就已经接触过 k8s object, 那就是 Pod。那么 k8s objects 对应的就是 Pods。通过 kubectl 命令行工具，我们可以操作 Pods，那同理 k8s objects 也同样可以被操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个 Object 通常具有两个必须的属性：a) object spec b) object status。object spec 就是对这个 object 的一些信息进行描述，比如这个 object 将要运行什么应用，这个应用的镜像是什么等等。object status 一般可以表现为该 object 在实际运行过程中的状态，k8s 系统自有的一些机制会不断的更改这个 actual status，直到它和 object spec 中的 desired state 相等为止。&lt;/p&gt;

&lt;h4 id=&#34;q-什么是-resources-什么是-custom-resources&#34;&gt;Q: 什么是 resources？ 什么是 custom resources&lt;/h4&gt;

&lt;h4 id=&#34;a-3&#34;&gt;A:&lt;/h4&gt;

&lt;p&gt;A resource is an endpoint in the Kubernetes API that stores a collection of API objects of a certain kind. For example, the built-in pods resource contains a collection of Pod objects. 总结下来就是，一个resource 是一堆 kubernetes object 的集合。例如 Pods 和 Pod 的关系。 那么 custom resource 就是自定义的对 kubernetes API 扩展后的 resource。&lt;/p&gt;

&lt;h4 id=&#34;q-什么是-custom-controllers&#34;&gt;Q: 什么是 custom controllers?&lt;/h4&gt;

&lt;h4 id=&#34;a-4&#34;&gt;A:&lt;/h4&gt;

&lt;p&gt;我们都很清楚，在 k8s 中，resource 是要和 controller 一起配合工作的。那么对于 custom controllers 来讲，它可以和任何类型的 resource 一起工作，但是针对 custom resource是尤其高效的。&lt;/p&gt;

&lt;h4 id=&#34;q-什么是-crd&#34;&gt;Q: 什么是 CRD？&lt;/h4&gt;

&lt;h4 id=&#34;a-5&#34;&gt;A:&lt;/h4&gt;

&lt;p&gt;CRD 可以认为是我们对自定义资源的描述，或者可以直接把它当做一个自定义资源的模板。这种描述信息即可以体现在 yaml 文件中通过 Kubectl 命令行工具来创建一个 CR，也可以直接通过 k8s的 client library 在代码中创建。&lt;/p&gt;

&lt;h4 id=&#34;q-开发一个-operator-需要哪些步骤&#34;&gt;Q: 开发一个 Operator 需要哪些步骤？&lt;/h4&gt;

&lt;h4 id=&#34;a-6&#34;&gt;A:&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;    1. 定义一个 CR（可以使用 yaml 文件也可以使用 kubernetes-client-go 的 library）
    2. 向 API Server 注册这个 CR
    3. 提供相应的 handler 用于处理用户对 CR 的 ADU操作
    4. 监听 CR 的的各种事件，并路由至相应的 handler 进行处理&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>TCP/IP 协议--UDP用户数据报协议</title>
      <link>http://littledriver.net/post/2017/11/27/tcp-ip-%E5%8D%8F%E8%AE%AE-udp%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 27 Nov 2017 08:41:36 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/11/27/tcp-ip-%E5%8D%8F%E8%AE%AE-udp%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/</guid>
      
        <description>

&lt;h1 id=&#34;什么是-udp-协议&#34;&gt;什么是 UDP 协议&lt;/h1&gt;

&lt;p&gt;UDP 是一个简单的面向数据报的传输协议，它处于传输层中。无论是 TCP 还是 UDP 都是有端口的概念的，端口一般又和 socket 联系在一起。所以说，基本上一个进程的输出，都会对应一个 UDP 或者 TCP 的数据报。&lt;/p&gt;

&lt;h1 id=&#34;udp-数据报的组成&#34;&gt;UDP 数据报的组成&lt;/h1&gt;

&lt;p&gt;UDP 数据报一共可分为5个部分&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;目的端口号&lt;/li&gt;
&lt;li&gt;源端口号&lt;/li&gt;
&lt;li&gt;UDP 数据报长度(首部+数据部分，最低为8B)&lt;/li&gt;
&lt;li&gt;校验和&lt;/li&gt;
&lt;li&gt;数据部分&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目的端口号和源端口号都可以视作为对应了发送端和接收端的两个进程。UDP 数据报的长度包含了首部和数据部分，并且最小不能低于8，因为前4部分构成了 UDP 数据报的首部。这四个字段的字节数是8B。换句话说，网络中是可以传输数据部分为0字节的 UDP 数据报的。&lt;/p&gt;

&lt;p&gt;关于校验和字段，UDP 和 TCP 数据报都会有。唯一的区别是，UDP 是可选的，TCP 是必须的。UDP 计算校验和的方式和 IP 数据报计算的校验方式一样。除此之外，为了计算校验和，UDP 或者 TCP 数据报还会包含一个伪首部部分。它包含 IP 数据报的某些内容，通过源 IP 和目的 IP，我们可以知道是否这个数据报不应该由我们这台主机来处理，协议字段可以让我们了解到，这个数据报是应该交由 UDP 端口的进程来处理还是 TCP 端口的进程。&lt;/p&gt;

&lt;h1 id=&#34;ip-分片&#34;&gt;IP 分片&lt;/h1&gt;

&lt;p&gt;当 IP 数据报的长度，也就是总长度减去首部长度超过了 MTU 大小的时候，可能就会涉及到分片的操作。分片的标准应该是按照发送端所在网络的 MTU 进行的，但是当数据报流动到了其他的网络，并且两个网络之间的 MTU 是不一样的，很可能再次发生分片操作。因为网络层的 IP 协议并不是可靠的，面向连接的。那么，当接收端的网络层接收到一堆一些被分片了但是又属于同一个数据报的报文的时候，就需要按照一定的规则将他们组装起来，提供给传输层。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;标识字段： 在 IP 数据报的首部，通常有一个16bit 的标识字段。它是内存当中维持的一个计数器。每当网络层发送一个 IP 数据报，那么这个标识字段就会被加1。一个比较大的 IP 数据报在分片的时候，原始数据报中的标识字段会被复制到各个分片的数据报中。&lt;/li&gt;
&lt;li&gt;标志字段：在标识字段的后面紧接着3bit 的位置，有一个标志字段。当 IP 数据报发生分片的时候，除了最后一份分片的数据报之外，其余的每一片数据报都需要将某一位置为1，标识还有“更多”的分片数据报，相当于告诉接收端的网络层，这不是最后一份分片数据报。&lt;/li&gt;
&lt;li&gt;片偏移字段：此字段是紧接着标志字段的，一共有13bit 左右。它标识了分片数据报的起始字节距离原始数据报开始处的位置是多少&lt;/li&gt;
&lt;li&gt;总长度值：数据报被分片之后，相应分片的数据报总长度不再为原始数据报的长度，应为该分片数据报的实际长度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;IP 数据报因大小问题可能会导致分片，并且在分片之后，对于接收端来说也是可以通过 IP 首部字段将这些分片的数据组装在一起的。但是这里有一个非常严重的问题，IP 分片一旦发生，甚至分片的次数越多，数据报在网络传输的过程中丢失的概率也就越大。由于 IP 协议并不为数据传输提供可靠性，当某一分片的数据报丢失，传输层的 TCP 协议很可能会重传整个数据报。如果这种出错的概率较高但是出错的分片数站总分片数的比例比较低，就会对网络造成很大的负担。并且，很多时候，如果是在通信过程中的某个路由发生分片，我们的发送端甚至都是不知情的，因为它没有任何的超时重传和确认的机制。&lt;/p&gt;

&lt;p&gt;如果在传输层使用了 UDP 协议，那么在 IP 数据报数据部分的前8个字节中会存有 UDP的端口号。在 IP 分片的时候，仅仅只有第一片数据会存有 UDP 的端口号。但是所有的分片都会在 IP 数据报首部表明协议字段，代表传输层使用了何种协议。&lt;/p&gt;

&lt;h1 id=&#34;icmp-不可达差错报文&#34;&gt;ICMP 不可达差错报文&lt;/h1&gt;

&lt;p&gt;这里要说的 ICMP 不可达差错报文和 traceroute 程序到达目的主机所发送的不是一回事。traceroute 程序发送的 TTL 值递增的 ICMP 请求报文，当到达目的主机 TTL 值大于等于0时，会向源主机发送一个 ICMP 端口不可达差错报文。告诉源主机，发送这个差错报文的主机就是目的主机了，trace 的过程已经结束了。但是我们现在要说的这个 ICMP 不可达差错报文是和 IP 分片有关系的。&lt;/p&gt;

&lt;p&gt;在 IP 数据报首部有一个标志字段，它一共有三位，目前只有前两位是有意义的。低位为1代表还有更多的分片，中间一位为1代表该数据报不能分片。这个字段和 ICMP 不可达差错报文结合起来，主要用作我们发现通信路径当中最小的 MTU 是多少，即路径 MTU 发现机制。之所以这么办，也是为了能够在网络中尽量减少分片，路径 MTU 其实还是遵循了「木桶原理」，最短的板往往决定了整条链路中实际使用的 MTU 大小。&lt;/p&gt;

&lt;p&gt;这种 ICMP 不可达差错报文，和之前的不同之处在于，在 ICMP 的首部中，存有下一站网络的MTU。也就是说，当我们为 IP 数据报设置了不可分片的标志位，路径中如果发现 MTU 小于 IP 数据报长度的，返回的这个 ICMP 数据报内部的 MTU 值即可作作为下一次 IP 数据报的长度。这样就可以顺利的通过这个发送 ICMP 回显应答的路由器或者主机了。&lt;/p&gt;

&lt;h1 id=&#34;路径-mtu-发现机制&#34;&gt;路径 MTU 发现机制&lt;/h1&gt;

&lt;p&gt;排除以太网内相互通信的机器，大部分主机在进行通信的时候，还是需要跨越多个不同的链路的。我们都知道，不同的链路上有不同的 MTU。整条通信路径上最小的 MTU 被称作是路径 MTU。如果想尽可能的减少在通信过程中进行分片导致传输成功率降低的风险的话，我们需要去确认即将通信的链路上的路径 MTU。使用上面提到的 ICMP 不可达差错报文，即可实现这一点。&lt;/p&gt;

&lt;p&gt;通过改动 traceroute 和 ping，可以指定发送数据报的长度。在发送第一份数据报的时候，长度为当前主机所在链路的 MTU，并且将 IP 数据报的标志位的中间位置为1，代表不可被分片。在到达目的主机的过程中，如果遇到了链路 MTU 比当前数据报长度小的时候，所经过的路由器就会丢弃这份数据报，并且向源主机发送一份 ICMP 不可达差错报文，里面可能会有之前没有通过的那条链路上的MTU 值。&lt;/p&gt;

&lt;p&gt;即使我们通过上述过程获得了当前路径 MTU 进行正常的通讯，但是在观察向目的主机发送数据报分片现象的时候，每隔一段时间，源主机还是会向目的主机发送一份不可分片的数据报，来检测一下路径 MTU 有没有变化。路径 MTU 发现机制其实最重要的意义，笔者觉得还是想把分片这件事尽量控制在发送端上面，甚至是不分片。例如，如果 IP 数据报的首部没有设置不让分片，如果到了一些 MTU 比较小的链路上，还是会被中间的路由器所分片的，只不过这个时候我们是不知道的。并且对数据报进行分片次数太多，确实是一个风险比较高的事情，IP 层是没办法保证数据传输的可靠性的。只能依靠IP 数据报中的标识符，偏移量，标志位等字段来拼接好分片的数据报。&lt;/p&gt;

&lt;h1 id=&#34;udp-和-arp-之间的相互作用&#34;&gt;UDP 和 ARP 之间的相互作用&lt;/h1&gt;

&lt;p&gt;当我们在发送一个很大的 UDP 数据报的时候，在网络层就需要分片。但与此同时目的主机的物理地址我们是不知道的。这个时候，分片和 发送 ARP 请求报文获取目的主机物理地址的两件事情进行的先后顺序会对数据报的发送造成影响。&lt;/p&gt;

&lt;p&gt;UDP 数据报过大到达网络层会进行分片，假设现在分成了8片的 IP 数据报。因为这8份数据报都带有目的 IP 地址。所以，在获取目的主机 ARP 请求报文的数量上也应该和分片数是相等的。在返回第一个ARP应答报文的时候，只会发送最后一个分片的数据给目的端主机，这是和 ARP 协议实现有关的。并且，当目的端接收到第一个数据报分片的时候，会启动一个定时器，一段时间内如果没有收到完成的数据报，就会将已经接收到的内容丢弃，并且尝试发送给源主机一份 ICMP 差错报文。但是，也要看，是否第一个分片的数据报到达了目的端。因为只有第一个分片的数据报内才有源主机的 UDP 端口号，目的主机如果拿不到这个端口号，也是没办法给源主机发送 ICMP 差错报文的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;由于写这篇文章的时候，笔者身边没有多余的电脑，使用手机和本机在局域网内测试的时候，并没有发现 arp 数据报的数量等于分片数。经人提醒，应该是无线网络环境的原因，稍后条件满足会把这部分抓包的实例图补上来。暂时先补一张 TCP/IP 协议卷一书上面的图&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/11fig17.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;最大-udp-数据报长度与-icmp-源站抑制差错报文&#34;&gt;最大 UDP 数据报长度与 ICMP 源站抑制差错报文&lt;/h1&gt;

&lt;p&gt;UDP 数据报也是被封装在 IP 数据报内部传输的，所以 UDP 数据报的长度，理应受到 IP 数据报长度的限制。IP 数据报首部有一个总长度的字段，占16位，也就是说 IP 数据报的最大长度可以达到2的16次幂个字节，也就是65535B。减去 IP 首部字段20B，UDP 数据报头部8B，UDP 数据报可以达到65507B。但是在现实的网络环境中，UDP 数据报的长度是远远小于这个值的。&lt;/p&gt;

&lt;p&gt;首先，UDP 数据报的长度受限于使用 UDP 协议的应用程序对发送和接受缓存大小的限制。比如，我的某个使用 UDP 协议的程序只要求读取最大大小不超过512B 的 UDP 数据报(不包括首部长度)，但是却收到一个长度大于这个阈值的 UDP 数据报，此时根据TCP/IP协议在内核的实现不同，可能会发生不同的行为，最常见的就是截断并且丢弃多余的部分，并且还不会通知接收者。&lt;/p&gt;

&lt;p&gt;在 TCP 协议当中，如果发送端发送数据报的速度过快，接收端可能会使用滑动窗口机制等措施来限制通信的流量。UDP 同样有解决这种问题的措施，但是却不一定会这么做。UDP 协议依赖的是 ICMP 源站抑制差错报文来通知发送端发送数据速度过快。这个 ICMP 数据报是否会发送，一个是和不同系统对 TCP/IP协议的实现有关，另外一个是，可能发送了但是被接收端忽略了，因为这个时候引起源站抑制的进程在发送端已经终止了。通过这个现象，也可以证明了，UDP 是一个不可靠的通信协议。&lt;/p&gt;

&lt;h1 id=&#34;experiment1-udp-输入队列溢出&#34;&gt;Experiment1: UDP 输入队列溢出&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;这里使用 TCP/IP 协议卷一作者提供的 sock 程序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 A 机器启动一个提供 UDP 的服务器，启动 sock 作为服务端进程监听客户端发送的 UDP 数据报&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/send2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 B 机器启动一个客户端 sock 进程，用于发送 UDP 数据报给 A 机器的服务端进程。并且发送一份数据报12345&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/send1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A 机器此时会接收到一个来自 B 的 UDP 数据报，并打印出相关信息。可以同时观察，服务端进程的输出以及 tcpdump 的结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/send2.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/send6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是现在，我们发送一个比较长的 UDP 数据报，411B，就会发现。虽然 A 机器上的 tcpdump 抓取到了发过来的 UDP 数据报，但是 A 上的 sock 进程却没有打印出这份数据报的信息。这说明了什么，说明客户端的 UDP 数据报被发送过来了，但是服务端并没有处理。在启动 A 机器上面的 sock 服务端进程的时候，我们使用-R 参数设置了 UDP 接收缓存为256B，很明显，我们发送的411B已经超出了服务端进程的 UDP 缓存大小，所以被服务端丢弃处理了。通过上面的实验我们就可以看出，在笔者所在的机器以及操作系统上面，服务端接收到了超过其接收缓存大小的 UDP 数据报将会被直接丢弃。&lt;/p&gt;

&lt;h1 id=&#34;experiment2-udp-限制本地-ip-地址和远端-ip-地址&#34;&gt;Experiment2: UDP 限制本地 IP 地址和远端 IP 地址&lt;/h1&gt;

&lt;p&gt;当我们以某一个端口号启动一个提供 UDP 服务的服务器时，通常不会指定本地的 IP 地址。至于为什么需要指定呢？很多人会比较疑惑，因为按照常理来讲一台主机应该只有一个IP。但是事实的情况是，很多服务器或者路由器都会安装多个网卡，每一块网卡都会有一个自己的 IP 地址和物理硬件的地址。因为这台主机所处的网络情况可能比较复杂，他可以同时连接两个不同的网络，这样对于他来说，就相当于有一个出口地址和入口地址。&lt;/p&gt;

&lt;p&gt;首先我们来看一下不指定 IP 地址而启动一个 UDP 服务器的情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/udp2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过这张图我们就可以看出，在本地启动了一个端口为7777的 UDP 服务器。然后通过 netstat 命令可以观察到，在展示结果的第四列 LocalAddress, 看到了我们所启动的 UDP 服务器的端口状态。&lt;code&gt;*.7777&lt;/code&gt;代表了，任何发送到本机的7777端口的 udp 数据报都可以被接收并且处理。这应该是一种比较常见的情况。&lt;/p&gt;

&lt;p&gt;那么，再来看一下指定 IP 地址而启动一个 UDP 的服务器的情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/udp3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;对比上图我们可以看出，唯一的区别是，LocaAddress 一列中的 端口号7777前面变成了我们本机的 IP 地址，而不再是一个星号。那么这就相当于我们对本地 IP 做了限制。因为 UDP 数据报还是放在 IP 数据报内进行传输的，监听7777端口的 UDP 服务器进程也是通过网络层-&amp;gt;运输层-&amp;gt;应用层的顺序逐级将该数据报递交到服务器进程中的。这个时候，如果我们在启动 UDP 服务器的时候限制了本地的 IP 地址，那么，如果发送到我们主机的 UDP 数据报的目的 IP 地址不是我们所制定的 IP，运输层是不会将这个数据报交付给他上层的 UDP 服务端进程的。此时，该主机会向这个报文的发送端返回一个 ICMP 端口不可达的错误。&lt;/p&gt;

&lt;p&gt;当我们在创建 UDP 端点的时候，如果指定了本地 IP，那么对于同一个端口号来讲，如果恰巧此时本地也有多个可绑定的本地 IP，完全可以启动多个 UDP 端点，它们的 本地 IP 不同，但是端口号相同。不过，此时可能需要在创建 socket 的时候要指定一些特殊的参数才可以，如 SO_REUSEADDR 选项。除此之外，还有一个问题就是，当一个数据报到达目的主机的时候，出现了上述多个不同 IP 但是 port 相同的 UDP 端点，此时，匹配的优先级会按照先具体再模糊的原则，也就是说，带有星号的 UDP 端点可能是最后才会匹配到的，这和 IP 选路的机制其实是有些类似的。&lt;/p&gt;

&lt;p&gt;既然可以限制本地 IP 地址（可以理解为接收者的 IP 地址），按道理来说，应该也可以限制远端发送者的 IP 地址和端口号。这个道理就类似，接收者可以通过你的目的地址来过滤我是否要接收这个 UDP 数据报， 也可以通过发送者的 IP 地址和端口号来过滤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/udp4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，我们限制了远端的 IP 地址和端口，再使用 netstat 命令观察的时候，发现第五列 ForeignAddress 也不再是&lt;code&gt;*.*&lt;/code&gt;的形式了。这时，如果再有接收到的 UDP 数据报，就需要同时满足数据报携带的目的 IP 地址和端口号，源 IP 地址和端口号，符合我们制定的规则，才可以被接收并处理，否则，还是会以 ICMP 的形式进行报错。匹配规则和限制本地 IP 时是一样的。&lt;/p&gt;

&lt;h1 id=&#34;最后-与多播和单播的关联&#34;&gt;最后：与多播和单播的关联&lt;/h1&gt;

&lt;p&gt;在一个支持多播的系统上，是允许多个 UDP 服务进程共享一个 UDP 端点的(本地 IP+端口号)。此时，如果该本地 IP 是一个广播地址且规则匹配成功，到达的 UDP 数据报会复制 N 份发送给监听这个端口地址的多个 UDP 服务进程。如果本地 IP 地址是一个单播，那么会依照实现方式的不同，将数据报发送给某一个 UDP 进程。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>TCP/IP 协议动态选路</title>
      <link>http://littledriver.net/post/2017/11/18/tcp-ip-%E5%8D%8F%E8%AE%AE%E5%8A%A8%E6%80%81%E9%80%89%E8%B7%AF/</link>
      <pubDate>Sat, 18 Nov 2017 21:13:49 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/11/18/tcp-ip-%E5%8D%8F%E8%AE%AE%E5%8A%A8%E6%80%81%E9%80%89%E8%B7%AF/</guid>
      
        <description>

&lt;h1 id=&#34;what-is-dynamic-routing&#34;&gt;What is dynamic routing?&lt;/h1&gt;

&lt;p&gt;在之前的文章中，我们已经讲过静态选路的概念以及相应的行为。简单来说，静态选路，主要是路由表内容生成的方式是静态的，也就是选路策略，因为之前我们提到过，选路分为选路机制和选路策略。比如，通过 route 命令添加，通过配置文件添加，抑或是通过 ICMP 重定向报文来学习。这种静态选路适用于不同的网络之间只有单点链接并且网络本身很小的情况。&lt;/p&gt;

&lt;p&gt;当网络的规模变大，不同的网络之间通过多个路由互联，且通信的路径也不唯一的时候，我们很自然的就需要网络之间的路由器也能够进行通信。让我们来看一张网络层的工作示意图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/09fig01.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个图中很多的通信路径以及节点，相信我们都比较熟悉了。现在我们要注意图中左上角的的一个节点：routing daemon。它代表了路由的守护进程。什么是守护进程，可以戳这里了解一下&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B&#34;&gt;守护进程-维基百科&lt;/a&gt;，这里面有一个比较有意思的概念叫「脱壳」。无论是具有路由功能的主机，还是路由器，在他们内部都有一个这样的 routing daemon 程序，来通过 RIP（路由信息协议）来进行通信，RIP 是内部网关协议的一种。通过告知对方路由器或者具有路由器功能的主机，自己所连接的网络情况，从而可以让接收此信息的路由器或者主机更新路由表。既然是通过别人告知信息的方式来更新路由表，那么路由表中的信息就可能会发生变动。这样一来，我们其实也就可以理解，动态选路中的「动态」也是和选路策略相关的。&lt;/p&gt;

&lt;h1 id=&#34;rip-选路信息协议&#34;&gt;RIP 选路信息协议&lt;/h1&gt;

&lt;p&gt;对于 RIP 信息协议，我们首先要了解的是，RIP 数据报的内容是包含在 UDP 数据报中的。它和 ICMP  差错报文被包含在 IP 数据报中是相似的形式。只不过 ICMP差错报文中的 UDP 首部是属于 ICMP 数据报的一部分，但是 RIP 报文显然是 UDP 数据报的一部分。
&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/ripFmt.gif&#34; alt=&#34;&#34; /&gt;
通过 RIP 的报文格式我们可以看出，首部大概有4个字节，其中command 字段是比较有用的，表明了该报文是一个请求报文还是一个应答报文。比较重要的就是图中所标识的20个字节的位置，它代表了要插入到路由表中的某一条记录的目的地址。至于一个 RIP 数据报最多可以携带多少个路由信息，其实TCP/IP 协议这本书上说的25个已经有点过时了。它采用20*25+4=504B 的计算方式，并且假定一个UDP 数据报的大小应该是512B。其实我们在今天我们携带的路由信息条数可以远不止25，但是，由于网络中的环境比较复杂，之所以规定一个标准的 UDP 数据报是512B，还是有道理的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这个MTU指的是链路层的数据区.并不包括链路层的首部和尾部的18个字节.所以,事实上,这个1500字节就是网络层IP数据报的长度限制.因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。:)
当我们发送的UDP数据大于1472的时候会怎样呢？这也就是说IP数据报大于1500字节,大于 MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报。
因此,在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好.
进行Internet编程时则不同,因为Internet上的路由器可能会将MTU设为不同的值.如果我们假定MTU为1500来发送数据的,而途经的某个网络的MTU值小于1500字节,那么系统将会使用一系列的机制来调整MTU值,使数据报能够顺利到达目的地,这样就会做许多不必要的操作.鉴于 Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时.最好将UDP的数据长度控件在548字节 (576-8-20)以内.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的这段对于数据报大小的解释，相信大家可以领会到一点就是，首先，在当今的网络环境下，我们完全可以传输数据大于等于1472B，但是这样首先会造成在网络层进行分片，其次就是即使发送的源主机所在的链路质量较高没有分片，但是通信过程中质量较低的线路往往会遇到这样的瓶颈。并且，还有一点非常重要，就是 UDP 数据报的通信是不可靠的，因为不是面向连接的，只要其中的某一个分片丢失了，那么整个 UDP 数据报都会被接收方丢弃，消耗的网络资源相当于浪费了，如果发送端应用层也会做重试处理，对网络造成的负担应该可想而知。&lt;/p&gt;

&lt;p&gt;另外一个不可忽略的因素就是，RIP 协议在提出来的时候，时间还比较早，使用的网络也都是以低速链路为主，MTU 可能只有500B-600B，所以，去掉各种协议的头部之外，规定一个默认的 RIP 数据报大小，也是合情理的。&lt;/p&gt;

&lt;h1 id=&#34;rip-协议的工作方式&#34;&gt;RIP 协议的工作方式&lt;/h1&gt;

&lt;p&gt;路由器之间使用 RIP 协议在交换路由表信息的时候，通常分为主动和被动两种形式。
其中，主动是指我们向其他路由器发送 RIP 请求报文，其他路由器同样使用 RIP 协议发送给我们一个应答报文。被动则是指，我们在没有发送请求的情况下，接收到的其他在同一网络上的路由器发来的 RIP 报文。RIP 报文内部包含的每一条路由记录信息中，都有一个叫做度量的字段，这个字段表明发送该 RIP 报文的路由器距离这个路由地址有多远，它和 TTL 一样，采用「跳数」来计数。RIP 协议中规定，度量最大为15，也就是说，如果发现RIP 协议的应答报文中有度量超过15的路由记录，则可视为这条路由是无效的。这也是 RIP 的一个重大的缺陷。由于有多个相邻路由发来其路由表的信息，所以在 RIP 响应报文到达的时候，可以根同一目的地址但是度量值小的为优先条件，从而筛选出最优的选路信息。&lt;/p&gt;

&lt;h1 id=&#34;无类型域间选路-cidr&#34;&gt;无类型域间选路(CIDR)&lt;/h1&gt;

&lt;p&gt;无类型域间选路其实是为了解决路由表规模过大的问题而出现的。无类型域间路由选路机制与普通选路机制最大的不同就是，在进行路由匹配的时候，不会再考虑网络地址的类别。如之前在有子网的时候，我们还会先去找目的地址属于哪一类型的，然后先匹配网络号再匹配子网号。CIDR 其实和子网划分的原理是相同的，都是对多个具有共同特征的 IP 地址进行聚合，与此同时，使用 CIDR 选路机制的路由器和选路算法，必须支持根据32bitip 地址和32bit 掩码做出选路决策，路由信息中也不仅仅需要有目的地址了，还需要相应的子网掩码，这个时候上面提到的 RIP 显然就不能用了，可以使用 RIP-2和 OSPF 两种协议来代替。其实到目前为止，笔者理解 CIDR，觉得他就是一个把全世界网络都当成一个巨大的子网在划分的过程，因为没有类别之分，我们可以划分和聚合的空间就更多，进而可以急剧的缩小路由表的规模。&lt;/p&gt;

&lt;p&gt;假设分配给整个欧洲的 C 类地址范围是194.0.0.0~195.255.255.255, 在这个范围内一共有65536个 C 类的网络地址。但是这么多的 C 类网络地址有一个共同的特点，就是他们的网络地址的高7位是相同的。那也就是说，整个欧洲的 C 类网络地址的主机，都可以对欧洲以外的路由器映射为一条统一的路由：网络地址为194.0.0.0, 子网掩码为254.0.0.0。而194之后的比特位，也可以根据这样的方式再做层次的分级。例如，我们现在对欧洲所有的高校网络做一次划分，规定194.1.0.0~194.1.255.255为高校范围的网络地址，该域的子网掩码为255.255.0.0。如果这条路由和欧洲整体的路由同时出现在外部网络的某台主机的路由表中，某分数据报如果要通过该路由发送给欧洲内的某台主机，此时，CIDR 在进行选路决策的时候，会按照路由信息所对应的子网掩码的最大长度来进行优先匹配。根据上面我们所提到的两种域的划分，肯定会优先匹配学校的网络地址。&lt;/p&gt;

&lt;p&gt;遗憾的是，CIDR 这种好东西，对于之前已经存在的 IP 地址是没有任何用途的，如果依据这个选路机制对全球所有的 IP 地址进行重新划分，会很大程序上缩小路由表的规模。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>TCP/IP 协议 IP 选路</title>
      <link>http://littledriver.net/post/2017/11/09/tcp-ip-%E5%8D%8F%E8%AE%AE-ip-%E9%80%89%E8%B7%AF/</link>
      <pubDate>Thu, 09 Nov 2017 22:41:48 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/11/09/tcp-ip-%E5%8D%8F%E8%AE%AE-ip-%E9%80%89%E8%B7%AF/</guid>
      
        <description>

&lt;p&gt;IP 选路通常包含两个部分：选路策略和选路机制。我们平时常说的 IP 选路，大都都指的是一个 IP 数据报如何从路由表中找到一个合适的下一跳机器的 Ip 地址，这属于选路机制的内容，即决定一个 IP 数据报向哪个接口来发送分组。另外一部分是选路策略，策略么，顾名思义就是一些规则，这些规则也就是指的路由表中的条目，即把哪些映射条目放入路由表中。&lt;/p&gt;

&lt;p&gt;在 IP 选路的过程当中，肯定少不了要搜索路由表，它按照以下顺序进行搜索：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;搜索主机地址严格匹配的路由记录&lt;/li&gt;
&lt;li&gt;搜索网络地址匹配的路由记录（网络号和子网号）&lt;/li&gt;
&lt;li&gt;搜索路由表中的默认路由记录&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;从一个简单的路由表说起&#34;&gt;从一个简单的路由表说起&lt;/h1&gt;

&lt;p&gt;通过 &lt;code&gt;netstat -r&lt;/code&gt; 我们可以查看本机的路由表&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/WX20171114-220525@2x.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;路由表的第一列表明目的地址，乍一看目的地址为&lt;code&gt;47.94.38.154/32&lt;/code&gt;的这一条可能觉得比较困惑，这是因为我们的路由表中采取 CIDR 的形式来表示 IP 地址。&lt;code&gt;47.94.38.154/32&lt;/code&gt; 斜线的前半部分表明一个 IP 地址，后面的32表明了这个地址的前缀长度，它的前缀和它的 IP 地址长度是相同的，主机号和网络号之前的间距为0。也就是说，这一个目的地址记录的是一个主机地址。第二列表明数据报下一跳的地址。&lt;/p&gt;

&lt;p&gt;Flags 这一列的值，大致有以下几种（仅列出与 UNIX 系统重合的部分）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;U: 表示可用的路由&lt;/li&gt;
&lt;li&gt;G：表示gateway 的路由是一个网关，如果不标识 G，那么说明这个路由是和本机相连在一个网络中的&lt;/li&gt;
&lt;li&gt;H：标识该路由是一个主机&lt;/li&gt;
&lt;li&gt;S: 表明这条路由记录是通过 route 命令加到路由表中的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在上面的4个标志中，G 是最重要的，它区分了直接路由和间接路由。当 G 出现的时候，说明发送数据报的主机并没有和目的主机直接相连，gateway 列对应的值表明其是一个间接路由。否则，认为发送数据报的主机是和目的主机直接相连的，gateway 列对应的值表明这是一个直接路由。
那么对于目的地址为&lt;code&gt;47.94.38.154/32&lt;/code&gt;这条记录来说，它的下一跳地址是一个可用的间接s路由，并且这条路由记录是通过 route 命令条件进来的。所以在向目的主机发送数据报的时候，IP 数据报目的地址为&lt;code&gt;47.94.38.154/32&lt;/code&gt;, 而以太网帧中的物理目的地址为192.168.2.1这个路由器的硬件地址。&lt;/p&gt;

&lt;p&gt;通常情况下 H 标志如果被设置，那么对应记录中的目的地址是一个完整的主机地址。否则目的地址是一个网络地址，主机号部分应该为为0. 但是我们可以看到，目的地址为&lt;code&gt;47.94.38.154/32&lt;/code&gt;这条记录，其 Flags 列中并没有 H标志，所以在 IP 选路进行路由表匹配的时候，就会匹配网络号和子网号，如果带有 H 标志，那么肯定会优先匹配完整的主机地址。值得注意的是，这条记录的即使是通过匹配网络号和子网号，事实上也会对整个目的地址进行匹配，因为目的地址 CIDR 表示形式的前缀为32，就说明目的地址所对应的子网掩码是255.255.255.255, 证明这个目的地址是一个主机地址。&lt;/p&gt;

&lt;p&gt;Refs列表明使用这条路由目前活动的进程数。一般面向连接的协议在建立链接并通信的过程当中都会固定某个路由。如两台主机之间通过 telnet 来远程登录，相应的路由表项的引用计数就会增加&lt;/p&gt;

&lt;p&gt;Use列表明通过该条路由发送的数据报分组的数量。&lt;/p&gt;

&lt;p&gt;整个路由表中还有一个 default 的路由表项，当 IP 数据报进行选路的时候，如果数据报中的目的地址没有和任何一项匹配上的时候，就使用 default 表项所对应的路由器做下一跳的地址。在作者的机器中，当然就只有一个路由器了。&lt;/p&gt;

&lt;h1 id=&#34;当没有达到目的地的路由&#34;&gt;当没有达到目的地的路由&lt;/h1&gt;

&lt;p&gt;IP 选路的大致过程我们在第一段以及之前的讲 IP 网际协议的文章中已经都说过了。如果能够找到匹配的项目，那么数据报就会继续呗传递下去。但是当一个路由表中既没有默认路由也没有匹配的项目的时候，会发生什么呢？&lt;/p&gt;

&lt;p&gt;我们知道，Ping 程序是通过对某个主机发送一份 ICMP 回显请求报文，然后通过收到的 ICMP 回显应答报文来判断主机是否可达的。因为 ICMP 报文是被包裹在 IP 报文内部被传输的，所以ping 程序发送的报文也是需要进行 IP 选路的。当我们 Ping 一个不可达，或者不存在的主机的时候, 会出现如下的情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/1222.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中我们ping 了一个77.21.2.222这样的一个主机地址，发现从88.134.186.186这个地址的路由那里收到一个 ICMP 目的主机不可达的差错报文。让我们来抓下包，看看整个 IP 寻路的过程是怎样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/traceroute11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过上图我们可以看出，traceroute 程序一共发了31*3个数据报。其中 TTL 在20-29之间，所发送的数据报均为得到回复。很有可能是这些 ICMP 超时数据报在回来的路上出了什么问题，导致没有到达我们的主机。但是当发送 TTL 为31的数据报时，到达了一个Ip 地址为88.134.186.186的主机或者路由，发送的三个数据报中有一个没有收到应答，就是最后面标星号的那个。其余两个在 RTT 时间的后面带了一个!H的标志，它表明我们的目的主机是不可达的。也就是说，当报文到达88.134.186.186主机的时候，IP 选路失败了，在这台主机的路由表中，我们没有找到任何匹配的记录，包括默认路由。此时，我们将返回源主机一个 ICMP 主机不可达报文。可见，当我们 ping 一个不存在，或者不可达的主机的时候，我们经过了很多的中间站，大部分原因是由于默认路由的存在，但是最终，还是返回的应有的「错误」。&lt;/p&gt;

&lt;h1 id=&#34;当发生了一次多余的路由&#34;&gt;当发生了一次多余的路由&lt;/h1&gt;

&lt;p&gt;什么是一次多余的路由呢？想象一下这样的场景，a,b,c 三台机器在同一个子网上，a 机器中只有 b 机器的默认路由，但是 c 机器才是这个子网链接 Internet 的 gateway，此时，a 机器要给 Internet 上面的某台主机发送数据，此时根据 IP 选路，数据报先到达了 b 机器，b 机器然后再转给 c 机器。很明显，经过 b 的中转其实是没有必要的，a 应该直接发送给 c 才对。当 b 检测到，其收到报文的接口，也就是a 发送报文的接口和 b 要发送报文到达的接口在同一个LAN上，此时，b 机器就会给 a 机器发送一份 ICMP 重定向差错报文。a 机器也就根据这份 ICMP 重定向差错报文来完善自己的路由表，下一次的数据发送会直接路由到 c 机器。当一个 LAN 上有很多机器的时候，如果其中的某个主机只有一个默认路由，那么它完全可以通过 ICMP 重定向差错报文来学习，从而完善路由表。&lt;/p&gt;

&lt;p&gt;在这里需要注意的是，如果一个主机是通过ICMP 重定向报文为自己的路由表添加了一条记录，那么这条记录的 flags 字段是多了一个 D 标志的，它就表明该条记录是被重定向报文创建的。并且，ICMP 重定向报文所生成的路由都是和主机相关的，也就是说，当我们去尝试以某种形式访问某台主机的时候，如果发生了 ICMP 重定向报文的发送，那么此时生成的路由记录是带有 H 标志的，也就是说，路由记录中的目的地址是一个明确的主机地址，那么，当下一次在发送数据报给另外一台主机的时候，这条路由记录显然是不会被命中的。所以说，是会发生一次新的路由重定向行为的。&lt;/p&gt;

&lt;p&gt;ICMP 重定向报文与主机相关的另外一个原因就是，网络地址，或者说被划分了子网的网络地址，类似网络号+子网号的组合，都是可能随时会变的，但是主机地址基本不会。&lt;/p&gt;

&lt;h1 id=&#34;如何发现路由&#34;&gt;如何发现路由&lt;/h1&gt;

&lt;p&gt;通过之前的学习，我们可以知道，如果想写入路由表，有几种已知的形式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;route 命令&lt;/li&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;li&gt;ICMP 重定向报文&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除此之外，还有一种机制就是通过 ICMP 路由器发现报文。某台主机在成功隐刀之后，会使用多播或者广播发送 ICMP 路由器发现报文。其他的收到这份报文的机器就会回复一份ICMP 路由器通告报文。通告报文中通常含有很多的发送路由器地址，与其配对的还有一个优先级的字段，标明了它作为默认路由的优先等级。路由发送的 ICMP 路由器通告报文的时间间隔一般要比该报文内容的过期时间要短，这样就可以实现，接受通告报文的主机的默认路由，基本是永远不会过期的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>TCP/IP 协议 traceroute 程序(1)</title>
      <link>http://littledriver.net/post/2017/11/07/tcp-ip-%E5%8D%8F%E8%AE%AE-traceroute-%E7%A8%8B%E5%BA%8F1/</link>
      <pubDate>Tue, 07 Nov 2017 23:04:36 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/11/07/tcp-ip-%E5%8D%8F%E8%AE%AE-traceroute-%E7%A8%8B%E5%BA%8F1/</guid>
      
        <description>

&lt;h1 id=&#34;什么是-traceroute-程序&#34;&gt;什么是 traceroute 程序&lt;/h1&gt;

&lt;p&gt;traceroute从字面意思上来看，他是一个有着追踪功能，并且可以查看具体追踪路径的这么一个程序。实际上它的功能的确也很类似，它为我们提供了一个仔细观察 IP 数据报从一台主机到达另外一台主机所经过的所有路由。对于网络层而言，这就是一次通信的整体的路径。&lt;/p&gt;

&lt;p&gt;其实早在了解 IP 协议的时候，IP 数据报首部字段中，有一个选项字段，这个选项字段大概有40个字节长（IP 固定首部长度为20个字节，最大60个字节），选项字段里面其实是是可以存储 IP 数据报所经过的路由信息的。比如使用&lt;code&gt;ping -r 1.1.1.1&lt;/code&gt; 就可以开启这个功能。但是由于 IP 数据报首部选项字段长度有限，因此如果一个 IP 数据报经过的路径太长，是没办法全部存储起来的。并且，RR 选项是单向的一个功能，发送端至接收端通信路径上面的路由信息，最后都需要接收端发给发送端一个数据报携带上这些信息。这样一来一回，IP 首部的选项字段所能够存储的有效路由信息就更少了。&lt;/p&gt;

&lt;h1 id=&#34;traceroute-程序核心武器&#34;&gt;traceroute 程序核心武器&lt;/h1&gt;

&lt;p&gt;traceroute 程序功能的实现依赖于以下几个元素：
1. ICMP 超时报文
2. ICMP端口不可达差错报文
3. IP 数据报首部的 TTL 字段&lt;/p&gt;

&lt;h1 id=&#34;traceroute-工作原理&#34;&gt;traceroute 工作原理&lt;/h1&gt;

&lt;p&gt;当 traceroute 为了探测其运行的主机与目的主机之间的路由情况时，通常会发送一个数据报，初始的情况下，这个数据报在网络层被包装之后 TTL 值是被设为1的，那此时当到达第一个路由的时候（如果源主机没有和目的主机在同一个以太网内），TTL 值变为0，该数据报被丢弃，路由器会发送给源主机一份 ICMP 超时报文，报文中 IP 首部字段里源主机的 IP 地址就是该路由的地址。因此，traceroute 也就知道了通往目的主机路径上面的第一个路由的信息。&lt;/p&gt;

&lt;p&gt;以此类推，IP 数据报首部的 TTL 时间逐渐增大，当到达目的主机的时候，并不会再向源主机发送 ICMP 超时报文，而是发送一个 ICMP 端口不可达报文来通知源主机，现在已经到达目的主机了。&lt;/p&gt;

&lt;p&gt;看完 traceroute 程序大致的工作原理，相信大家是有一些疑惑的，比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;traceroute 在发送数据报的时候，为什么使用了 UDP 协议而不是 TCP 协议&lt;/li&gt;
&lt;li&gt;端口不可达的 ICMP 报文究竟是怎么产生的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先我们来说第一个, 其实在使用 traceroute 程序的时候，我们是可以指定传输层的协议的，通过-P的参数就可以指定 TCP 协议，traceroute 默认使用 UDP 协议。使用 TCP 协议通常主要想去诊断，源主机和目的主机上的某一个具体的服务连接是否有问题。因为如果你指定了—P 参数去运行 traceroute 的时候，还是会通过 TCP 三次握手建立连接的。Tranceroute 程序最主要的作用是观察源主机与目的主机之间的路由路径，应该尽可能的把数据发送出去，因为数据报本身也是探测性质的，TCP 的性能也相对来说比较差，如果没有特殊的需求，UDP 确实是一个比较好的选择&lt;/p&gt;

&lt;p&gt;第二个和 Tranceroute 本身的发送的数据报是有关的，默认情况下使用 UDP 协议，会指定一个介于33434 to 33534之间的端口号。这个端口号通常是不可用的，或者不会使用的。这样一来目的主机才可以返回一个差错报文以不影响其他任何环节的方式来通知源主机。&lt;/p&gt;

&lt;h1 id=&#34;traceroute-在局域网内的工作过程&#34;&gt;traceroute 在局域网内的工作过程&lt;/h1&gt;

&lt;p&gt;笔者在自己家里面的局域网中以 mbp 和手机作为两台主机对 traceroute 的功能进行测试，由于环境限制，traceroute 工作过程中的超时 ICMP 报文可能看不到，因为在同一个没有物理隔离的局域网中，是不需要经过任何路由器的。但是 ICMP 的端口不可达的差错报文还是可以看出来的。&lt;/p&gt;

&lt;p&gt;首先，我们把 ARP 缓存通过 &lt;code&gt;sudo arp -ad&lt;/code&gt; 来清理掉。手机在局域网的 IP 地址是&lt;code&gt;192.168.2.100&lt;/code&gt; ,mbp最后一个字节是102。现在从 mbp 上运行&lt;code&gt;traceroute 192.168.2.100&lt;/code&gt;,通过抓包工具，我们可以看到这一次的网络通信过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/hehe.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先，如果要发送数据报给目的主机，那么需要获得目的主机的 IP 地址。这个时候以广播的形式发送 ARP 数据包，可以得到目的主机(手机)的 ARP 应答报文，通知源主机(mbp)其 IP 地址是什么.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/udp.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/Ip.png&#34; alt=&#34;&#34; /&gt;
其次，从上图中可以看出，应用层上发送的数据报内容为24B。然后再传输层进行包装，源端口为63236，目的端口是33437，使用的是 UDP 协议。到了网络层，数据报被再次包装，首先指定了源地址和目的地址。然后指定整个 IP 数据报总长度为52B，其中首部长度为20B，最重要的一个信息是，TTL 字段被指定为1.之后再通过链路层，最终被包装为一个以太网帧，发送到物理链路上。&lt;/p&gt;

&lt;p&gt;在这个场景下，当数据报发送给了目的主机并且 TTL 值为0的时候，目的主机会回应给源主机一个 ICMP 端口不可达的差错报文。
&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/icmp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ICMP 报文通常分为三个部分：
1. ICMP 首部
2. 引起这个 ICMP 报文的 IP 数据报首部
3. UDP 首部&lt;/p&gt;

&lt;p&gt;让我们来仔细的观察一下 ICMP 报文的内部结构
&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/icmp1.png&#34; alt=&#34;&#34; /&gt;
首先我们可以看到的是，ICMP 报文的代码和类型两个字段，这两个字段联合在一起可以唯一的确定一个报文的类型。从图中可以看出这是一个目的端口不可达的差错报文。接下来我们可以看到的是， 占了20个字节大小的引起 ICMP 报文的 IP 数据报首部，这个数据报首部很显然就是刚刚源主机发送给目的主机的那一个。
最后是一个 UDP 数据报的首部。看到这里大家可能会为，为啥要加这么一个 UDP 数据报的首部啊？如果你有这个异或，那么得先想清楚 UDP 数据报中有什么内容如此的重要。答案是源端口号和目的端口号。目的端口号就是引起这个 ICMP 报文的不可达的端口号。而源端口号的作用在于，当这个 ICMP 报文被源主机接收之后，我们以什么来识别这个 ICMP 报文该交由谁处理了，答案就是端口号，因为 traceroute 程序说白了也是一个用户进程，这个进程想要在传输层使用 UDP 协议通信的时候，就必须要有 socket，那么也就必须要有 IP 地址和端口号，所以这个端口号可以唯一的标识一个通信的进程，以便我们可以将这个 ICMP 数据报交由对应的用户进程来处理。
ICMP 数据报显然是存储在 IP 数据报中的数据部分的。那么接下来我们看到的就是一个 IP 数据报的头部，源 IP 地址和目的 IP 地址对比我们之前的数据报已经反转了过来。最后通过链路层被包装成以太网帧，进入物理链路传输。&lt;/p&gt;

&lt;p&gt;通过抓包观察 tranceroute 在局域网内工作的过程，我们可以真正的了解到，以这种办法来去探测源主机与目的主机之前的路由路径是可行的。下一篇文章，我们会尝试在广域网中运行 tranceroute 来观察超时 ICMP 报文的传输情况。&lt;/p&gt;

&lt;h1 id=&#34;traceroute-的注意事项&#34;&gt;traceroute 的注意事项&lt;/h1&gt;

&lt;p&gt;traceroute既然记录的是通信过程中的路由记录，那么不可避免的它的运行结果会收到 IP 选路策略的影响。很有可能发生以下两种情况
1. 两次运行 tranceroute 的路由记录不同
2. 正向 UDP数据传输经过的路由和 ICMP 端口不可达差错报文传输经过的路由可能是不一样的
3. 同一个路由器或者主机，可能有多个 IP 地址&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>TCP/IP 协议卷一之 IP 网际协议初探</title>
      <link>http://littledriver.net/post/2017/10/30/tcp-ip-%E5%8D%8F%E8%AE%AE%E5%8D%B7%E4%B8%80%E4%B9%8B-ip-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Mon, 30 Oct 2017 22:09:54 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/10/30/tcp-ip-%E5%8D%8F%E8%AE%AE%E5%8D%B7%E4%B8%80%E4%B9%8B-ip-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2/</guid>
      
        <description>

&lt;h2 id=&#34;ip-数据报字段&#34;&gt;IP 数据报字段&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;IP 数据报长度（首部长度+数据长度)用一个16位的字段进行标识，最大数据报长度为65535，但是链路层都会对数据报进行分片处理。数据报总长度字段是需要的，链路层会读取这个字段的值，来判断是否数据报的长度达到了链路层封装数据包的最小长度，如果没有达到的话，还需要填充一些字节来保证链路层的传输效&lt;/li&gt;
&lt;li&gt;TTL 值标识了数据报可以经过的最大路由个数，也就是这个数据报的生存时间。当 TTL 到达0的时候，该数据报被丢弃，并且向源主机发送 ICMP 报文。&lt;/li&gt;
&lt;li&gt;IP 数据报内的首部校验和字段是对首部字段进行计算得到的一个数值。发送方对首部字段每16位进行计算，反码求和，存在校验和字段中。接收方以同样的形式进行计算，最终应该得到的值为1。如果最后值不唯1，那么由上层进行重新发送，不会使用 ICMP 报文进行报错处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ip-路由选择&#34;&gt;IP 路由选择&lt;/h2&gt;

&lt;p&gt;IP 层在内存当中有一个路由表，路由表项基本上是源 IP 到下一跳 IP 映射的一条记录。一台pc 可以作为主机来使用，也可以作为路由器来使用。路由器和主机在功能上最大的区别就是，主机在收到一个 ip 数据报的时候，如果发现目的 ip 不是自己或者广播地址，那么就会直接丢弃。但是路由器会对这个数据报继续进行转发操作。所以说，一般路由器的网络模型都是只有网络层和链路层。&lt;/p&gt;

&lt;p&gt;进行路由选择的时候，大致会遵循以下的顺序
1. 路由表中是否有与目的主机 IP 严格匹配的表项，如果有，直接使用其表项中的目的 IP 进行继续转发
2. 路由表中是否有与目的主机网络号相匹配的表项。这一般出现在有局域的时候，某一个局域网内的所有主机都可以使用某一个网络号来进行标识。这一类特性也极大的缩减了路由表的规模。
3. 路由表中是否有默认跳转的 IP 地址&lt;/p&gt;

&lt;p&gt;IP 数据报在传输的时候，如果接收数据报的机器不是目的主机，那么数据报就不会再向上层传输，也就是说不会经过传输层。并且还有一个需要特别注意的是，在转发的过程中，链路层的硬件地址是一直在变的，唯独IP 数据报内的目的 IP 地址不会变。这一个特性其实也可以反证我们刚说的，在 IP 数据报进行路由的时候，是不会经过上层的。&lt;/p&gt;

&lt;h2 id=&#34;带有子网划分的路由选择过程&#34;&gt;带有子网划分的路由选择过程&lt;/h2&gt;

&lt;p&gt;为了减少内存当中路由表的规模，我们一般都会通过划分子网的方式来解决这个问题。当我们拿到本机(所经过路由) IP，目的主机 IP，以及我们所处的子网掩码的时候，我们的比较过程会按照如下的大致顺序。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;目的主机的网络号是否与本机的网络号相同（知道 IP 地址就知道了哪一类的 IP，从而也就知道了网络号的位数）&lt;/li&gt;
&lt;li&gt;网络号相同则根据子网掩码分别对本机 IP 和目的 IP 进行与运算，得出的子网号看是否相同，如果相同，那么就证明目的主机就处在本机所在的子网&lt;/li&gt;
&lt;li&gt;如果子网号不相同，说明还需要在继续查找路由表
上述过程发生在 IP 路由选择的第二步，也就说在没有找到与目的 IP 严格符合的路由表项的时候。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Python 的函数与作用域</title>
      <link>http://littledriver.net/post/2017/10/08/python-%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Sun, 08 Oct 2017 22:24:17 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/10/08/python-%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      
        <description>

&lt;h1 id=&#34;def-是什么&#34;&gt;def 是什么&lt;/h1&gt;

&lt;p&gt;python 中实现一个自定义的函数，以 def 开头。类比 c，golang 这种静态类型的语言，有的是以 func 开头，有的直接省略类似的「关键字」，直接写函数签名。学习Python 的一个很大的误区，就是我们认为 def 也是Python 中定义函数的一个关键字。在Python 中，def 不是一个关键字，而是一个可执行的语句。如果不考虑类，一般来说，函数都实现在某一个模块中，那么当这个模块被导入的时候，def 语句就会自动执行，创建一个函数对象，并且把这个对象赋值给对应的函数名。也就是说，函数的定义和普通变量的定义是没有区别的，函数名仅仅是 def 语句创建出来的函数对象的一个引用而已。&lt;/p&gt;

&lt;p&gt;python 中使用 def 语句创建的函数对象，并不要求每一个都要有返回值或者显式的 return 调用。仅当你需要这个函数的返回值的时候，才使用 return 进行返回，否则，函数默认返回一个 None 对象。既然Python 是一个动态类型的语言且没有所谓的「编译」，「链接」阶段，那么也就是说在一个模块被执行之前，某一个函数变量名具体引用了哪一个函数对象我们是不清楚的，这个关系是在模块运行的时候才能够确定的。并且，如果函数内部有一些明显的运行时的 Bug，在 def 语句执行的时候也不会去检测，只有在调用者调用这个函数发生错误的时候才能够清楚。
å
所以，在Python 中，函数变量和其他任何变量没有区别。def 是一个可执行语句，并不是一个关键字。&lt;/p&gt;

&lt;h1 id=&#34;函数中的多态思想&#34;&gt;函数中的多态思想&lt;/h1&gt;

&lt;p&gt;如果是有编程基础的人，对多态这个词应该不难理解。我是这样理解的&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;多态，就是某一个操作的意义取决于被操作的对象类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个最直接的例子就是，C++中，子类和父类有一个函数签名相同的方法。定义一个父类类型的指针，当这个指针指向父类对象或者子类对象的时候，执行的同名方法是两个不同类中所分别定义的；或者在 Java 中，「+」这个操作既可以用于字符串的链接，也可以用于数字的四则运算。python 则比 java 还要方便，因为它是一种动态类型的语言，python 的世界中只有对象和引用的区别，没有数据类型之分，一切事物都是对象，被某个变量引用。所以在编写Python 的函数中，尽量不要去用类似「type」等方法检测参数的类型，这其实就是一种典型的用静态语言的思维在使用动态语言。仔细想想Python 的一个便捷之处就是在编程的时候不需要考虑数据类型，一旦某个函数内的某个操作是传递进来的参数所不具有的，让其抛出一个异常也是正确的选择。&lt;/p&gt;

&lt;p&gt;所以，只要是在函数内部对参数做的操作，被传递进来的对象都支持，这个函数就能够正常工作，这和参数的数据类型是没关系的。&lt;/p&gt;

&lt;h1 id=&#34;作用域&#34;&gt;作用域&lt;/h1&gt;

&lt;p&gt;作用域这个词，从字面意思上来理解，就是某个事物起作用的区域。在编程语言中，通常指某个变量的生存周期。某个变量的作用域和它第一次被赋值的位置是相关的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非嵌套函数内部：本地作用域&lt;/li&gt;
&lt;li&gt;嵌套函数内部：非本地作用域&lt;/li&gt;
&lt;li&gt;模块内部（文件内部，函数外部，包括Python 内置模块）：全局作用域&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;本地作用域与全局作用域&#34;&gt;本地作用域与全局作用域&lt;/h2&gt;

&lt;p&gt;python 中的全局作用域都是要和模块一起提出才是有意义的，这里的「全局」是指模块内全局，模块和模块之间，也就是文件和文件之间是完全隔离开的。一个我们在开发过程中所常见的现象就是某个模块的全局变量对外是作为这个模块的某个属性被使用的。本地作用域一般指调用函数所构造的一个作用域，本地作用域一般和函数调用相关。从操作系统的层面上来讲，每一个函数的调用都会开辟一块栈的空间用来存放函数调用的上下文或者一些本地变量，再结合我们一般说作用域都是和变量的生命周期联系在一起，就不难发现，每一次对函数调用，都会创建一个新的本地作用域。&lt;/p&gt;

&lt;p&gt;各个作用域之前可能会存在一个作用域屏蔽的问题，比如在某一个函数内定义的某一个变量和函数外部的某一个变量同名，那么在函数内部对这个变量的更改将不会影响到函数外部的变量。这个现象看起来很像是一个「屏蔽」的效果，函数内的变量屏蔽的外部的。但其实这和解析变量的规则是有关的，后面的段落将会介绍相关的细节。&lt;/p&gt;

&lt;p&gt;另外，要谨记的一点就是，只有在发生变量赋值的时候，才会涉及到作用域变化的问题。原地对一个对象的修改是不涉及到任何作用域变更的问题的。原因有以下几点：&lt;/p&gt;

&lt;p&gt;1.Python 中，变量和对象是不同的两个概念。变量通常指的是引用变量，指向内存中实际存在的一个对象
2. 作用域这一概念是针对变量的，而不是针对对象的&lt;/p&gt;

&lt;p&gt;举一个简单的例子，函数外定义一个 list 对象并且赋值给一个变量 x。那么在函数中，如果执行 x.append 操作，影响的是全局作用域中的变量 x 所指向的list对象。x 这个变量并没有发生「更改」类型的操作。但是如果在函数内部执行了 x=y 这种操作，那么就视为在函数的本地作用域内定义了一个新的变量 x，它屏蔽了全局作用域中的同名变量。&lt;/p&gt;

&lt;h2 id=&#34;legb-变量解析原则&#34;&gt;LEGB 变量解析原则&lt;/h2&gt;

&lt;p&gt;当我们使用一个变量的时候，自然得找到它出现并且被赋值的位置。然而，可以使用的有效的变量一般都是在其有效的作用域内。所以，变量的查找和解析与作用域是分不开的。Python 中解析变量的规则称作为「LEGB」原则。&lt;/p&gt;

&lt;p&gt;「LEGB」是四个作用域简称的组合，在解析变量的时候也会依次按照顺序进行查找，只要查找到一处就停下来&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L：本地作用域&lt;/li&gt;
&lt;li&gt;E：非本地作用域&lt;/li&gt;
&lt;li&gt;G：全局作用域&lt;/li&gt;
&lt;li&gt;B：内置作用域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述四个作用域，应该有两个是大家比较迷惑的地方。非本地作用域和内置作用域。&lt;/p&gt;

&lt;h3 id=&#34;非本地作用域&#34;&gt;非本地作用域&lt;/h3&gt;

&lt;p&gt;非本地作用域出现的场景是发生有函数嵌套的时候。「非本地」是对于被嵌套的函数而言。一个被嵌套函数的内部可以被称作是本地作用域，但是在这个函数和嵌套他的函数之间这一块区域被称作是非本地作用域。非本地作用域除了必须要发生函数嵌套行为之外，嵌套的层次也会影响到非本地作用域的大小，python 在进行变量解析的时候，会追踪到任意的嵌套层次。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def foo():
...     x = 1
...     def foo2():
...         def foo3():
...             nonlocal x
...             x = 3
...             return x
...         return foo3
...     return foo2
...
&amp;gt;&amp;gt;&amp;gt; a = foo()()()
&amp;gt;&amp;gt;&amp;gt; a
3&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如上面的代码所示，foo3在解析 x 这个变量的时候，一直查找到了嵌套的第二层。也就是说，对于foo3的非本地作用域有foo2和foo1两层这么大，尤其是我们使用了 nonlocal 这个关键字，让上面这段实例更加有说服力，因为 nonlocal 关键字的出现，证明我们不但要对非本地作用域的变量进行读取，还会有修改操作。&lt;/p&gt;

&lt;h3 id=&#34;内置作用域&#34;&gt;内置作用域&lt;/h3&gt;

&lt;p&gt;内置作用域其实本质上来说就是全局作用域。之前已经说过，python 当中的全局作用域是和文件（模块）相关的。那么内置作用域，很显然是和Python 的内置模块相关。python 2.x 版本中内置模块的名字是 &lt;em&gt;&lt;strong&gt;buildin&lt;/strong&gt;&lt;/em&gt;,Python 3.x 版本中内置模块的名字是*builtins*。说白了，这两个内置模块也是两个不同的文件，比如一些我们常用的Python 的内置函数，有可能就是这个模块当中的一个全局作用域当中的一个变量。那么也就是说，当我们想引用Python 给我们提供的某些内置功能的时候，除了可以依赖「LEGB」原则，还可以直接通过 import 内置的模块进行显示调用。&lt;/p&gt;

&lt;h1 id=&#34;修改外部作用域的变量&#34;&gt;修改外部作用域的变量&lt;/h1&gt;

&lt;p&gt;既然作用域会被氛围很多种，尤其是对本地作用域和全局作用域来讲，因为有了变量隔离机制，所在在本地作用域中对同名变量的读取和修改并不会影响到全局变量。那么，如果我们现在在本地作用域中，不但要读取全局作用域中的变量，还要修改它，这个时候就需要 global 这个关键字了。&lt;/p&gt;

&lt;h2 id=&#34;global-语句&#34;&gt;global 语句&lt;/h2&gt;

&lt;p&gt;global 这个语句一般后面会带着一个变量名。它是目前为止，我们所见到的第一个Python 当中具有声明作用的语句。global声明的是一个命名空间，或者说是作用域也可以。例如，global a，声明了 a 这个变量的作用域或者说是命名空间是全局的。一般来说，如果本地作用域和全局作用域没有重名的变量且不会对全局变量做修改的话，任何一个本地作用域内都是可以直接读取本模块内的全局变量的。但是如果是有重名的情况，为了确保我们在本地能够读取和修改的是全局变量，就需要在使用之前用 global 语句来声明这个变量的命名空间。&lt;/p&gt;

&lt;p&gt;这里需要注意的是，global 语句只是起到了一个声明的作用，如果 global 后面跟着一个并不存在的变量名，在函数定义的时候，并不会发生报错, 只有当函数被调用的时候，执行逻辑到了 global 语句所在位置的时候，才会抛出异常。包括在定义函数的时候使用了一个不存在的变量也会有相同的结果, 但是这一切的前提都是在 global 语句出现之后，本地作用域内没有对这个全局变量进行赋值操作。一旦有赋值操作，将会自动创建这个变量。&lt;/p&gt;

&lt;p&gt;这应该是算作Python 这类动态语言一个「不好」的地方，由于在运行之前并不会做一些常规的语法上的检查就导致了很多错误只有在运行的时候才会暴露出来。不过这也恰恰印证了一点，我们在学Python 的时候，还是需要摒弃一些使用静态语言时的一些习惯。前面也说到了，python 是有意不做一些校验的，猜测它这么做是因为做多了这种校验会让代码变的复杂，灵活性降低。有的时候，直接抛出异常，也未尝不是一个好的错误处理方式。学习和使用动态语言的时候，思维还是要有所转变。&lt;/p&gt;

&lt;h2 id=&#34;嵌套函数&#34;&gt;嵌套函数&lt;/h2&gt;

&lt;p&gt;嵌套函数从字面意思上来讲就是一个函数套着一个函数，这种形式在各个语言的「闭包」中出现的最多。伴随着嵌套函数的一个比较重要的概念是嵌套作用域，也就是我们之前说的「LEGB」原则中的 E。如果在一个被嵌套的函数中，想要读取并且修改上层函数的某一个变量，则需要在自己的函数体内声明这个变量为「nonlocal」，python 会自动寻找到离他最近嵌套层次中的同名变量。&lt;/p&gt;

&lt;h3 id=&#34;工厂函数-闭包-or-装饰器&#34;&gt;工厂函数(闭包 or 装饰器)&lt;/h3&gt;

&lt;p&gt;工厂函数其实也就是我们常说的的闭包函数，闭包的概念之前是有讲过的，它是一个能够保存嵌套作用域变量的函数。也就是说，即使最后闭包函数的外层嵌套作用域都不存在了，但是在它的内部还是能够访问到之前的变量，这是目前为止我们遇到的，除了类的属性之外能够保存状态的最好的办法。之所以不提全局变量，是因为这个东西使用起来还是有很多坑的，需要考虑很多东西，一旦有了并发等场景就更加复杂，当然，还有默认的可变参数也可以实现这个功能，但是都不推荐使用。闭包函数在 python 中一个典型的应用就是装饰器，但是除了代码编写上还没有发现有什么特别的好处。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ps: 这里有一个比较小的 tips 需要提到：在 python 中一个函数体中可以调用一个在它之后才定义的函数。但是在这个函数调用之前，它所使用的函数都必须已经定义。由此我们可以知道，在 python 中 def 语句只是把函数体中的东西统一的构造除了一个对象然后让一个变量去引用它，至于这个函数体本身有没有问题，还是得执行起来才能够知道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h3&gt;

&lt;p&gt;lambda 看起来好像是一个匿名的函数，但本质上它仍然只是一个表达式，一个可以构造函数的表达式。如果这个表达式出现在 def 定义的函数中，无意中就创造了一个嵌套函数模型。在之前没有嵌套作用域概念的时候，想让 lambda 表达式生成的函数访问所在嵌套层次函数内的变量，只能通过默认参数传递的方式进行，但是现在，可以不用多写任何一行代码依赖 python 本身所提供的对嵌套作用域的支持就可以实现这个效果。&lt;/p&gt;

&lt;h3 id=&#34;嵌套函数的陷阱&#34;&gt;嵌套函数的陷阱&lt;/h3&gt;

&lt;p&gt;嵌套函数一个最容易被忽略的陷阱就是在函数被嵌套在了一个循环中，并且嵌套函数中还使用了循环变量。如在生成一个函数列表的情况下，这个陷阱导致的直接后果就是，函数列表中的函数内所保存的循环变量的值都是循环范围中最后的那一个值，为什么呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;循环变量也是一个引用，在循环范围内每次引用一个不同的值&lt;/li&gt;
&lt;li&gt;函数体中的逻辑只有在函数执行的时候才执行，def 语句并不会执行内部逻辑&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;出现这种情况，最直接的解决问题的思想就是将每一次的循环变量所引用的值都分别保存在嵌套函数的内部，每一个函数都会创建一个自己的本地作用域，所以将循环变量赋值给嵌套函数的参数，即可实现我们所期望的效果。&lt;/p&gt;

&lt;h3 id=&#34;nonlocal&#34;&gt;nonlocal&lt;/h3&gt;

&lt;p&gt;nonlocal 关键字从 Python3.x 开始提供，它允许在嵌套函数中读取和修改嵌套作用域中的变量。nonlocal 的出现，在变量解析的过程中直接跳过了本地作用域这一阶段，从嵌套作用域开始。它与「global」相同，「global」是在整个模块中寻找想要操作的变量，而「nonlocal」是在本地作用域与全局作用域之前的嵌套作用域中进行查找。但是，「global」所声明的变量如果在全局作用域内找不到，还可以去内置作用域找，但是「nonlocal」不行，它只能在嵌套作用域内进行查找。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Data Structure Review - Circular Queue</title>
      <link>http://littledriver.net/post/2017/09/28/data-structure-review-circular-queue/</link>
      <pubDate>Thu, 28 Sep 2017 16:39:57 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/09/28/data-structure-review-circular-queue/</guid>
      
        <description>

&lt;h1 id=&#34;0x01-为什么需要循环队列&#34;&gt;0x01 为什么需要循环队列&lt;/h1&gt;

&lt;p&gt;普通的队列结构无论在逻辑上还是在物理存储上，都是一个连续的线性结构。队列的插入和弹出操作符合「FIFO」原则。我们一般在操作队列的时候，都会有两个指针，一个指向队列头部，另外一个指向队列尾部。当我们想弹出一个元素的时候，可以清空队列头部指针所指向的元素，然后将指针向队列尾部移动一个元素的长度。当我们想插入一个元素的时候，可以在队尾指针所指向的位置放入我们想要插入的元素，然后队尾指针向后移动一个元素的长度。&lt;/p&gt;

&lt;p&gt;一个队列初始的时候，队头和队尾指针都是指向同一个位置的，一般来说就是底层线性结构的第一个元素的位置(如数组)。如果现在只有十个元素的空间可以用于实现队列，但是我们却要求插入20个元素，中间会不定的弹出元素，这样是否可以实现呢？&lt;/p&gt;

&lt;p&gt;乍一看10个位置想要插入20个元素是不现实的，不过中间会不定的弹出一些元素，只要是在插入一个元素之前，有一个或一个以上的元素被弹出了，就是有可能实现的。那么问题来了，插入元素的位置和弹出元素的位置是由两个不同的指针来控制的，队尾指针如果移动到了底层线性结构的边界应该怎么办？队头指针同样也会遇到这个问题。答案是要使用循环队列。&lt;/p&gt;

&lt;h1 id=&#34;0x02-循环队列长什么样&#34;&gt;0x02 循环队列长什么样&lt;/h1&gt;

&lt;p&gt;循环队列是一个在逻辑上成环，但是物理上还是线性的一种数据结构。底层存储队列元素的结构没有变，只不过在使用这些空间上面使用了一些小的技巧。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Circular Queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/Circular%20Q.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;0x03-循环队列的实现&#34;&gt;0x03 循环队列的实现&lt;/h1&gt;

&lt;h1 id=&#34;0x031-enqueue&#34;&gt;0x031 enqueue&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;enqueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;# queue 为空/一直插入元素到没有可用空间/循环插入后没有可用空间&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)):&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;           &lt;span class=&#34;k&#34;&gt;raise&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;No has a avalible space&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;# 发生循环插入&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;# 插入第一个元素，改变 front 的值&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;0x032-dequeue&#34;&gt;0x032 dequeue&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;97&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dequeue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;global&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;  &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;raise&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;queue is null&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;front&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;# 弹出的元素为队列中最后一个&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;# 循环弹出&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对于「出队」和「入队」两个操作的实现，其实最重要的只有一点：如何在一个线性结构已经被循环利用的情况下判断出它的状态是满还是空。从上面的实现中我们可以看到，当判断一个队列是满状态的时候有以下两个条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;未循环使用的情况下, rear == len(queue) - 1, front == 0&lt;/li&gt;
&lt;li&gt;循环使用的情况下, rear + 1 == front&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;未循环使用肯定是一个指向队头，另外一个指向队尾。循环使用的情况下，front 和 rear 之间应该是差值为1的关系，但是 rear 的位置比 front 靠前。之所以这么判定，也是因为一个比较自然的原因，无论是插入元素还是弹出元素，顺序都是从左向右的。&lt;/p&gt;

&lt;p&gt;当判断一个队列是空的状态的时候，只需要判断 front, rear 是否同时等于-1即可。因为弹出元素和插入元素都是从左向右进行的，当 front 大于 rear 的时候，就证明 rear 之前插入的元素，front 都已经遍历过了，也就是弹出过了，这个时候会将两个指针同时置为 -1。如果上述情况没有出现，而只是 front 到了边界，那么就会进行循环的弹出。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Python中的引用与拷贝</title>
      <link>http://littledriver.net/post/2017/08/20/python%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Sun, 20 Aug 2017 16:48:31 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/08/20/python%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8B%B7%E8%B4%9D/</guid>
      
        <description>

&lt;h1 id=&#34;从赋值说起&#34;&gt;从赋值说起&lt;/h1&gt;

&lt;p&gt;之前在 python 变量相关的文章中，提到过赋值行为在 python 中和其他语言有何异同。说白了，其实就是默认传递引用，而不会拷贝整个对象。这种做法一个比较好的地方就是避免的在使用大型对象的时候，由于一些使用上的不规范而造成巨大的开销。但是凡事都有两面性，方便的同时，带来的坏处就是，同一个对象的引用可以有多个，那么只要这个对象的数据发生了变化，受影响的将是指向他的所有的引用。这种行为通常是我们不想看到的。&lt;/p&gt;

&lt;p&gt;其实，这种行为，和 c++中的浅拷贝的行为是一直的。c++中也有引用的概念。浅拷贝通常也只是拷贝引用or 指针，而不会真正的拷贝整个对象。依稀记得，如果要在 C++中的自定义类型实现深拷贝，还需要自己实现拷贝构造函数。在 python 中，对于 list，dict 等数据结构，有一些现成的方法可以调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deep&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;object&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deep&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cool&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;!&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;需要注意的是：&lt;/code&gt;列表和字典上面所提到的深拷贝方法，都无法拷贝嵌套结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10000000&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中， a 中的列表，及时通过&lt;code&gt;[:]&lt;/code&gt;形式进行拷贝，仍然无法对其中嵌套的列表进行深拷贝操作。这个时候，可以使用 copy 标准库内的 deepcopy 方法，来达到嵌套深拷贝的目的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;copy&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deepcopy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;19&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;19&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;21&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;fdsfsdsf&amp;#34;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;23&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;23&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;fdsfsdsf&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;从比较说起&#34;&gt;从比较说起&lt;/h1&gt;

&lt;p&gt;python 中比较两个对象的是否相等，通常有两种形式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;is&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种形式，就是按照深拷贝的思想，测试两个引用所指的对象是否是相同，这里的相同是引用指向的内存地址相同，也就是判断两者是否是同一个对象
第二种形式，仅仅比较两个引用指向对象的值是否相等。并且，无论是第一种还是第二种，python 中的比较都会递归的进行，不会仅仅只比较顶层的元素。&lt;/p&gt;

&lt;h1 id=&#34;重复赋值&#34;&gt;重复赋值&lt;/h1&gt;

&lt;p&gt;这里说重复赋值不是指对某一个变量赋值多次，而指的是对某一个变量赋值多个重复的元素。当重复的这个元素是嵌套或者非嵌套的时候，都会有着截然不同的结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;49&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;50&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;51&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;51&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;52&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;53&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;53&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;54&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;44444&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;55&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;55&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;44444&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;56&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;56&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;57&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;57&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;44444&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;44444&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;44444&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;44444&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;利用 &lt;code&gt;id&lt;/code&gt; 分别查看一下 a，b，c 三个变量的地址就可以很容易的解释因重复嵌套元素所造成的这种问题&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4329904392&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;61&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;61&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4328297536&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;62&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;62&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4329904392&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;b 在赋值的时候，对 a 做了4次的重复，我们都知道，序列的重复，分片，合并都会生成一个新的对象而不会改动原来的引用。所以 b 中的12个元素都是仅属于 b 的。由于对 c 赋值的时候，语义表现的是重复4个元素为 a 的嵌套列表给 c，重复的操作看起来只对顶层元素生效了，因为顶层元素是 a，是一个列表，也可以称作是一个引用，所以 c 这个列表中的四个元素，都是 a 列表单位引用。此时，a 和 c 存在共享引用的现象，自然在更改 a 的时候。就改动了 c。所以说，一个嵌套的形式，无形中在重复元素赋值的时候，加深了深度，与序列的重复只对顶层元素生效一起，导致了上面的现象。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Python迭代器与解析（1）</title>
      <link>http://littledriver.net/post/2017/07/30/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E8%A7%A3%E6%9E%901/</link>
      <pubDate>Sun, 30 Jul 2017 15:33:45 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/07/30/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E8%A7%A3%E6%9E%901/</guid>
      
        <description>

&lt;h1 id=&#34;迭代&#34;&gt;迭代&lt;/h1&gt;

&lt;p&gt;迭代这个概念，在很多编程语言当中都是存在的。说白了，就是对一个『可迭代对象』进行遍历的过程。如 for 循环，while 循环等等，都是对一个对象进行迭代操作。那么这个『可迭代对象』到底是什么呢？&lt;/p&gt;

&lt;h1 id=&#34;可迭代对象&#34;&gt;可迭代对象&lt;/h1&gt;

&lt;p&gt;简单来说，可迭代对象就是一个具有 &lt;code&gt;__next__&lt;/code&gt;方法的对象。当这个对象被用在 for 循环等一系列迭代的场景的时候，这个方法就会起到相应的作用。如，python 当中的文件对象想按照逐行的顺序来进行迭代的话，有以下几种方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;# 1&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;test.py&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;upper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		
	&lt;span class=&#34;c1&#34;&gt;# 2&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;test.py&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readlines&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;upper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		
	&lt;span class=&#34;c1&#34;&gt;# 3&lt;/span&gt;
	
	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;line&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readLine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;beak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;upper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;首先第一种方式，应该是迭代一个文件对象的最优选择：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;该对象在循环中自动调用&lt;code&gt;__next__&lt;/code&gt;方法，逐行读取文件，不会浪费内存&lt;/li&gt;
&lt;li&gt;调用迭代器，在 python 中几乎是以 C 语言的速度在执行的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第二种方式，一个明显的缺点，就是 readlines 方法将文件中所有的内存一次性都加载到了内存中，形成了一个以每一行内容为一个元素的字符串列表。如果文本内容过大超过了机身内存的大小，很可能会出现意想不到的问题。&lt;/p&gt;

&lt;p&gt;第三种，虽然没有内存方面的问题，但是比起在 for 循环使用迭代器进行处理，while 循环是在python 虚拟机当中运行 python 的字节码，所以在速度上，相较第一种中方式，还是差了一些。&lt;/p&gt;

&lt;h1 id=&#34;迭代器&#34;&gt;迭代器&lt;/h1&gt;

&lt;p&gt;关于迭代的第三个概念，我们之前说过，迭代是一种行为，可迭代对象是可以在其上进行迭代行为的一个对象，也就是一个具有&lt;code&gt;__next__&lt;/code&gt;方法的对象。之所以对于可迭代对象有这样的一个定义，是因为之前讨论的文件对象比较特殊，文件对象本身是自己的一个迭代器。也就是说，真正具有&lt;code&gt;__next__&lt;/code&gt;方法的对象应该是迭代器，而不是我们之前所谓的可迭代对象。可迭代对象的范围应该比迭代器更大，以列表举例，它本身是没有迭代器的，但是列表依然是 python 当中可迭代的对象之一，那么列表这个对象的&lt;code&gt;__next__&lt;/code&gt;方法从何而来呢？是通过一个叫做 iter 的方法得到的，该方法接受一个对象，返回一个具有&lt;code&gt;next&lt;/code&gt;方法的迭代器，&lt;code&gt;next&lt;/code&gt;方法在内部会调用迭代器的&lt;code&gt;__next__&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;所以，for 循环在处理列表这类可以迭代但是本身不是迭代器的对象时，都会将列表这个对象传递给内置函数 iter，得到一个具有 next 方法的迭代器，然后每次循环调用&lt;code&gt;next&lt;/code&gt;方法来迭代对象。&lt;/p&gt;

&lt;p&gt;除了之前说的列表和文件对象之外，在遍历一个字典的 key 的集合时，也可以使用迭代器来进行操作。之前的 python 版本中，在遍历字典键的时候都会使用&lt;code&gt;keys()&lt;/code&gt;方法来获取一个字典键的列表，使用 for 循环迭代。目前，可以直接使用&lt;code&gt;for key in dict&lt;/code&gt;的形式来进行迭代。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于可迭代对象，需要提及一点，python2.x 和 python3.x版本中，对于 zip 和 range 两个函数生成的结果是有很大不同的。2.x 版本中 zip 和 range 生成的都是一个 list，但是在3.x 版本中生成的则是一个可迭代的对象。也就是说在3.x 版本中，如果你想得到 zip 和 range 两个函数调用结果内的元素的话，都需要额外的迭代操作，而不能一次性直接得到最终结果。这种惰性求值的理念，非常适合当 zip 和 range 生成的结果数据量都比较大的时候。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了上面说到的，range，zip 等内置函数生成的可迭代对象在不同版本有一些不同之处之外。range 生成的可迭代对象和 zip, filter 等函数生成的可迭代对象也有不小的差异。对于 zip, filter, map等内置函数生成的可迭代对象，他们都是自带迭代器的，和上面我们说到的文件对象是一样的。他们返回的结果，在一些迭代的场景下，如 for 循环中，可以直接进行迭代行为，而不需要把他们调用的结果传递给他 iter 函数获取迭代器之后再进行迭代。这就引发了一个问题，zip 等函数生成的迭代器只能够使用一次，也就是说，必须从头迭代到尾，没有其他机会在可迭代对象的基础上，生成多个不同位置的迭代器，进行迭代。说起来可能比较抽象，看一下例程应该会清楚很多&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# running in python3.x&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;zip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;zip&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; ita1 = iter(a)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; ita2 = iter(a)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; type(ita1)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;lt;class &amp;#39;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;zip&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; ita1.__next__()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;(1, 3)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; ita2.__next__()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;(2, 4)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; b = range(1, 4)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; type(b)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;lt;class &amp;#39;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; itb1 = iter(b)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; itb2 = iter(b)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; itb1.__next__()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; itb1.__next__()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; itb2.__next__()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt; itb2.__next__()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;例程当中对于 zip 和 range 生成的可迭代对象分别创建了两个迭代器，zip 返回的可迭代对象本身就是一个迭代器，所以在整个迭代范围内，即使创建了两个，但是看起来行为使用的确是同一个迭代器。因为例程的本意是想两个迭代器的迭代步调不一致的。对于 range 返回的可迭代对象就比较符合我们预期的行为，range 调用返回的对象并不是一个迭代器，所以需要通过 iter 函数来构建，在这种情形下，每个迭代器都是独立的，所以可以有属于自己的迭代位置。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Python 中的变量、对象、引用</title>
      <link>http://littledriver.net/post/2017/07/30/python-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sun, 30 Jul 2017 15:31:38 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/07/30/python-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</guid>
      
        <description>&lt;p&gt;很多编程语言都有所谓的引用，对象，变量等概念。这些概念在强类型的语言中貌似并不是那么的重要，但是在动态类型的语言中，还是值得去仔细思考一下的&lt;/p&gt;

&lt;h1 id=&#34;什么是变量&#34;&gt;什么是变量&lt;/h1&gt;

&lt;p&gt;对于变量，在数学中我们已经了解过，就是一个值可能会改变的量。在C++中，我们对变量的认识应该相当于一个标识符，创建一个变量，即开辟一块内存然后给这块内存起个名字，那么这个名字就是“变量”，当然，这个变量的含义和内存地址以及指针都是不相同的。&lt;/p&gt;

&lt;p&gt;那么在Python中，变量意味着什么呢？按照我的理解，一言蔽之，就是一个指针。这确实和之前学过的强类型语言是有不同的。为什么这么说呢？首先，python中的变量是没有类型的，有类型的是“对象”，而不是变量。变量没有类型，那么就意味着它可以随意指向任何对象。在强类型语言中，变量其实都是有具体的类型来限制的，规定一个类型的变量只能被赋值与该类型相同或兼容的值。但是在python中，显然变量的自由度更大。其次，之前学过体系结构的同学都应该了解，指针的内存空间大小是与类型无关的，其内存空间只是保存了所指向数据的内存地址。之所以说指针也有类型，是因为在计算偏移量的时候，确实需要类型相关的信息。所以，从深层次的含以上来理解，python中的变量与强类型语言中的指针非常相似。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;In [1]: a = 3

In [2]: a = &amp;#34;abc&amp;#34;

In [3]: a
Out[3]: &amp;#39;abc&amp;#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上述代码中也可以明显的印证我们上面对python中变量行为的总结是正确的，与指针的行为非常相似。&lt;/p&gt;

&lt;h1 id=&#34;什么是对象&#34;&gt;什么是对象&lt;/h1&gt;

&lt;p&gt;我的理解是：对象=确定内存空间+存储在这块内存空间中的值。这一点其实和java有些相似。&amp;lt;&lt;java编程思想&gt;&amp;gt;这本书前面第一章，就对对象和引用这两个概念做了很清晰的区分。Java中，对象是分配在堆上的，存储真正的数据，而引用是在堆栈中开辟的内存空间用于引用某一个对象。抛开java中引用的概念不谈，两种语言对于对象这个概念的理解，我认为还是可以等价的，都是数据+内存空间感觉。Python中，对象才有类型，不同的对象可以拥有不同类型的数据。&lt;/p&gt;

&lt;h1 id=&#34;什么是引用&#34;&gt;什么是引用&lt;/h1&gt;

&lt;p&gt;引用在Python中的语义应该是一种关系，即变量和对象之间的关系，其实也就是指针指向某一块内存空间的关系。既然是变量和对象之间的关系，那么其实就意味着，对于一个对象来说，和不同的变量可能存在着多个“引用”关系。因为变量是无类型的，他想关联谁就可以指向谁，这也就牵扯到了一个“引用计数”的概念，python中的gc大体上就是使用这种原理在做的。&lt;/p&gt;

&lt;p&gt;既然说到多个变量可以引用同一个对象，那么就不得不说一下，如果其中一个引用改变了值，会影响到其他指向这个对象的变量么？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;In [4]: a = 2

In [5]: b = a

In [6]: a
Out[6]: 2

In [7]: b
Out[7]: 2

In [8]: b =3

In [9]: a
Out[9]: 2

In [10]: b
Out[10]: 3&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上面的代码结果来看，答案应该是否定的。如果了解清楚变量和对象的语义就能对这个问题很容易做出判断，变量值的改变，就相当于指针变量内存空间内值的改变，也就是指向的对象换了一个，但其实之前所指向对象的内容是并没有收到影响的。&lt;/p&gt;

&lt;p&gt;但是也有特例，比如列表，指向列表的变量通过索引访问的方式，可以直接改动列表在该索引处存储的值。这个时候，如果有两个变量同时引用一个列表对象，那么其中任何一个变量利用这种方式对列表的修改，都会影响到另外一个。&lt;/p&gt;

&lt;p&gt;为了能够避免这种情况，可以对列表单独拷贝一份。两个变量互不干涉，而拷贝列表最直接的方式，莫过于“切片”操作了。&lt;/p&gt;

&lt;h1 id=&#34;变量的比较&#34;&gt;变量的比较&lt;/h1&gt;

&lt;p&gt;对于变量的比较，见得最多的，莫过于“==”和“is”。前者比较的是对象所存储的数据的值是否相等，后者则比较的是两个变量是否都引用了同一个对象。这些显而易见的东西，很多人应该不以为然，但是一些因语言内部优化的小细节，可能会打破你之前的认识。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;In [12]: a = 3

In [13]: b = 3

In [14]: a == b
Out[14]: True

In [15]: a is b
Out[15]: True&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;按照我们之前所讲的，a和b两个变量应该是引用了两个不同的对象，但是这两个对象内存中的值都是3。但是，a is b得到的结果却是True。原因有如下两点：&lt;/p&gt;

&lt;p&gt;Python在底层做了一定的优化，对于使用过整数以及字符串都会被缓存起来。所以上述b引用的应该是被缓存过的3
之所以采用这种优化的方式，是因为python中数字和字符串一经创建都是不可修改的。所以不会出现，因使用了缓存的对象值造成“脏读”的问题&lt;/p&gt;

&lt;h1 id=&#34;结尾&#34;&gt;结尾&lt;/h1&gt;

&lt;p&gt;任何一种语言或是一种知识，表面上看起来都是有很多相似的地方的。这也是计算机相关知识的一个比较大的特点。但是很多东西，稍微的往底层走一点，其实还是差别很大的。接触了c++, golang, java, python这几种语言，仅仅是在对象，变量，引用这种最基本的概念上还是有挺多细节上的不同的，这也恰恰能够体现了每种编程语言的设计哲学。所以现在想想，多接触几门语言，并不是一件坏事。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Learning for APUE(4)</title>
      <link>http://littledriver.net/post/2017/06/27/learning-for-apue4/</link>
      <pubDate>Tue, 27 Jun 2017 11:05:53 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/06/27/learning-for-apue4/</guid>
      
        <description>

&lt;h1 id=&#34;刷新缓存&#34;&gt;刷新缓存&lt;/h1&gt;

&lt;p&gt;操作系统内核在写入和读取数据的时候，从cpu到硬盘，还有很长的一段路。这段路上，为了减少数据传输的延迟，操作系统采取的很多的措施。如：就近原则的读取，内存，寄存器的使用，甚至是高速缓存，多级cache。这些办法都能够有效的提高数据传输的速率。当内核想向一个文件写入数据的时候，它并不会直接将数据写入文件所在的硬盘块，而是先将数据写入高速缓存当中，当高速缓存满了，或者说需要重用高速缓存的时候，就将高速缓存的数据写入到磁盘中。但是这个动作也不是立即发生的，写入磁盘的任务会进入一个队列中进行排队，等待处理。&lt;/p&gt;

&lt;p&gt;为了保持高速缓存和硬盘上面的数据的一致性，就需要提供一定的接口，使得用户可以主动的发起写入数据到磁盘的这种行为。为此，linux上面提供了三个api可以实现这种效果：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;sync&lt;/li&gt;
&lt;li&gt;fsync&lt;/li&gt;
&lt;li&gt;fdatasync&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三个系统调用均可以实现上面所说的功能，但是fsync是对特定的文件起作用，而fdatasync只会将文件的“数据”部分写入至磁盘，文件类型等信息是不会写入的。相反，其他两个方法是会把文件所有的信息以及数据都会写入。&lt;/p&gt;

&lt;h1 id=&#34;操纵文件描述符-fcntl&#34;&gt;操纵文件描述符&amp;ndash;fcntl&lt;/h1&gt;

&lt;p&gt;fcntl这个函数的作用，就是通过参数中传递进来的文件描述符来修改文件相关的描述符标志和状态标志信息。不过一般修改标志位的方式，都是先获取目前的标志位，然后根据位或运算增加新的标志位。&lt;/p&gt;

&lt;p&gt;首先是对于文件描述符标志位的设定，其中有一个标志位在介绍dup函数的时候也出现过，就是FD_CLOSEXEC。这个标志位设定的效果在于，此文件描述符所在进程，如果通过execl函数执行了另外一个子进程的话，那么在execl执行的这个进程中，此文件描述符即使被传递过去也无法使用了，但是如果是使用fork的话，那么在子进程中还是可以使用的。相关的一个例子，可以看看这篇文章&lt;a href=&#34;http://blog.csdn.net/ustc_dylan/article/details/6930189&#34;&gt;http://blog.csdn.net/ustc_dylan/article/details/6930189&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;按照之前说明的设置文件描述符标志位的规则，首先可以调用fcntl函数，使用F_GETFD命令来获取相应的标志位，使用位或运算计算之后，再使用F_SETFD命令来设置新的标志位即可。&lt;/p&gt;

&lt;p&gt;文件描述符的信息应该是属于某一个进程的，所以它应该存在于进程表项中。除了文件描述符之外，还和进程打开文件相关的一个指标就是文件的状态标志。内核为操作系统中打开的文件维护了一张表，这张表内就存储着被打开文件的状态标志信息。之前在讨论文件共享的时候就说过，文件状态标志信息应该是和文件描述符绑定的。也就是说，进程，文件描述符，文件状态标识三者是1对多，1对1的关系。一个进程可以同时打开很多文件，所以是一对多。但是每打开一个文件，获得一个文件描述符，都和唯一的一个文件状态标识所绑定，所以是1对1的关系。&lt;/p&gt;

&lt;p&gt;文件状态标志之前在open函数中有过说明，其中一个很重要的标志就是访问方式标志。如只读，只写，读写等等。访问方式标志的取值为0-5，每一个值代表了一种访问方式。但是他们并不是按位来排列的。所以在确定一个文件描述符对应的文件状态标识中到底是使用了何种访问标志，需要使用一个屏蔽字通过按位与的方式来取出访问标志的值到底是多少。&lt;/p&gt;

&lt;p&gt;除了文件访问标志之外，另外一个重要且常见的标志就是O_SYNC，同步标志。这个标志可以在调用open函数的时候对文件进行设置，也可以通过fcntl函数来进行设置。但是后者在某些操作系统上面设置之后也并不会生效，所以一般都是在open函数的时候就设置好。该标志被设置之后，在想文件写入数据的时候，就不会采用系统原有的，先写入缓存，然后进队列，适当的时候再写入磁盘这套机制。而是直接采用同步I/O的形式，直到写入的数据已经落在磁盘上了，那么这次写入的操作才会返回。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Thinking in Java-1</title>
      <link>http://littledriver.net/post/2017/06/25/thinking-in-java-1/</link>
      <pubDate>Sun, 25 Jun 2017 17:13:19 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/06/25/thinking-in-java-1/</guid>
      
        <description>&lt;h1 id=&#34;一切皆是对象&#34;&gt;一切皆是对象&lt;/h1&gt;

&lt;p&gt;Java编程中，最重要的不是语法，感觉是一种oop的思想。最近刚刚开始学java，但是还是感觉java这门语言在被设计的时候，还是站在解决问题的 这个角度去考虑的，并且对oop思想贯彻的非常好。相比C艹来说，java更关注解决问题，而不是效率等一些高级的问题。&lt;/p&gt;

&lt;p&gt;Java中其实有对象和引用这两个概念，说白了，对象就是内存中的内容，而引用则可以认为是和指针一样的东西，用来标识这块内存。这样一来，在想操作这个对象的时候，我们就可以通过操作这个引用来实现。因为对象和引用两个概念是分开的，所以在Java中，引用是可以脱离对象独立存在的。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;String s;
String a = &amp;#34;xuran&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;s就是一个还没有和特定String类型对象关联起来的一个引用，a也是一个引用，但是已经和“xuran&amp;rdquo;这个字符串对象关联起来了。
除了上述a这个引用和对象关联起来的方式之外，还可以用一种更加通用的方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;String a = new String(&amp;#34;xuran&amp;#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;new这个关键字的作用就在于创建一个新的对象。将这个对象赋值给a，就相当于将a这个引用和新建的对象关联起来。因Java对象的生存周期是其内部的GC机制来控制的，所以Java通过new关键字创建的对象，都存储于堆上。引用和对象不同，在Java语言中，一个引用变量的生命周期通常都是在程序运行前就已经确定的，这也就是为什么有了作用域这一概念的原因（我理解是这样),所以Java当中的对象引用一般都是创建在堆栈上面的。堆栈上面的创建和回收操作要比堆上面的效率更高，因为堆栈中的每一项大小都是固定的，在分配和回收的时候，只需要移动栈顶指针即可。但是堆不同，它的创建和回收都比堆栈要复杂的多。&lt;/p&gt;

&lt;p&gt;Java中对于一些基本的数据类型的存储方式上面也比较特殊，比如int类型，是一种基本的整数类型。但是在Java中同时还提供了一种Integer的类型。前者在创建的时候，采用直接声明的方式int a = 3;这种形式的创建并非创建了一个引用变量a，而是创建了一种”自动“变量，这个变量存储于堆栈中，里面存放的是赋值给他的值。而Integer a = new Integer(3);这种形式，就和上面所说的一样，是创建了一个引用变量，并且把引用和具体的对象建立了联系。并且在Java中，基本数据类型的种类要比C艹少了很多，比如没有无符号数，也没有int8，int16这种，java中所有基本的数据类型的大小都是固定的。&lt;/p&gt;

&lt;p&gt;Java中的引用和对象由于存储位置的不同，自然会引起一个问题，那就是当引用变量脱离它的作用域的时候，这个引用变量就是不可见的，在堆栈中就已经被回收了。但是对象是存储于堆中的，这样就会造成了内存泄漏，因为创建的对象没人用，但是还没有被回收。所以Java中有一套垃圾回收的机制来处理这些问题。&lt;/p&gt;

&lt;p&gt;Java在自定义类型中，对于一个类中的字段，可以是基本数据类型，也可以是一个对象的引用。对于一个特定类的对象在定义之后，它所具有的字段的默认值是不同的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果是引用的话，那么Java将不会对它赋值一个准确的值，需要自己在构造函数中准确的初始化&lt;/li&gt;
&lt;li&gt;如果是基本数据类型，Java会将他们赋值一个默认的0值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是这种默认复制的行为只发生在类的成员中，在Java中，局部变量在定义的时候，如果没有赋值直接使用，也是会报错的。这一点和golang就有很大的不同，golang在这中默认赋值的行为上面是统一的。&lt;/p&gt;

&lt;h1 id=&#34;初始化&#34;&gt;初始化&lt;/h1&gt;

&lt;p&gt;Java中用于初始化类对象成员的方式和C艹中是一样的，默认提供了一个构造函数，但是自己可以指定带参数的，或者是重写不带参数的构造函数。一旦自定义了一种形式的构造函数之后，那么在构造这个类型的对象的时候，就必须按照这种构造函数的形式进行调用，否则会编译错误。如，你定义了带参数的构造函数，此时再想调用默认的就不行了。&lt;/p&gt;

&lt;p&gt;对于使用构造函数来初始化类内成员的方式，需要注意一点的就是，Java对于类成员默认的初始化行为是一直存在的，即使你自己定义了构造器。举例来讲，基本数据类型的成员会变成类型对应的0值，而引用类型会被初始化为NULL。当默认的初始化行为结束之后，才会自动调用类的构造器对类成员进行第二次初始化。&lt;/p&gt;

&lt;p&gt;除了使用构造函数可以初始化类内成员，还可以直接在类中进行初始化。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Class Test {&#34; data-lang=&#34;Class Test {&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Class Test {&#34; data-lang=&#34;Class Test {&#34;&gt;int a = 3;
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;静态成员的初始化比较特殊，有以下几点需要注意：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;静态成员只有在需要的时候才会被初始化，”需要“的时候包括创建了类内有静态成员的对象实例，以及使用某个静态成员的时候&lt;/li&gt;
&lt;li&gt;静态成员初始化优先于非静态成员&lt;/li&gt;
&lt;li&gt;一个类中的静态成员，只在这个类第一个对象被创建的时候，才会被初始化。静态成员在整个程序的生命周期只初始化一次&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么这里就涉及到一个初始化顺序的问题。类内成员的初始化顺序，遵循在类中定义的顺序，但是却会在任何方法被调用之前初始化，这里是包括构造函数的。也就是说，如果类中直接初始化某几个变量，那么这些变量在构造函数调用之前就会执行它们预定的初始化操作。&lt;/p&gt;

&lt;p&gt;在初始化一个数组的时候，如果事先知道一个数组内部的元素，我们可以直接在创建数组的时候，利用大括号初始化一个数组。这种存储的分配方式和直接使用new关键字是一样的。直接定义一个数组的引用，但是没有跟它初始化一个真正的数组对象的时候，它的值应为NULL。Java中允许数组之间的赋值行为，直接使用赋值号和C++中的浅拷贝的行为是一样的，只不过是多了一个引用指向了同一个数组对象上，所以他们的更改会相互影响。&lt;/p&gt;

&lt;p&gt;在使用new创建一个基本数据类型的数组的时候，会自动创建一系列的基本数据类型变量，直接在堆上为其开辟了空间。但是如果是创建非基本数据类型的数组的时候，我们实际上是创建了一个引用数组，在未给这些引用链接到真是存在的对象之前，如果擅自使用数组元素，是会抛出异常的。所以，往往在创建一个非基本类型的数组之后，在使用之前还要为每一个引用都链接一个真实的对象。&lt;/p&gt;

&lt;h1 id=&#34;方法重载&#34;&gt;方法重载&lt;/h1&gt;

&lt;p&gt;重载这个概念，在C艹里面也是存在的。简单来说，就是对名字相同的函数，赋予不同的形参列表，即形成了函数重载。在执行的时候，会根据传递参数的不同而调用不同的方法。甚至在java中，还参数顺序的不同，也可以作为一种重载的形式，这也侧面说明了，重载概念中形参列表的不同，不仅仅是在于形参的类型和个数，顺序也是衡量的目标之一。&lt;/p&gt;

&lt;p&gt;在对方法传递基本类型参数的时候，如果目标参数的类型窄于要传递的参数，此时必须进行强制类型转换才可以进行传递。如果反过来，相当于数据类型的一个提升，是没问题的。&lt;/p&gt;

&lt;h1 id=&#34;this-static&#34;&gt;this &amp;amp;&amp;amp; static&lt;/h1&gt;

&lt;p&gt;Java中对于成员方法的调用一般来讲，都是默认的将调用对象的引用作为第一参数传递给了该成员方法，方法内部一般如果想使用它的话，直接用this这个关键字即可。并且还可以通过this在一个构造器中调用另外一个构造器，但是这种用法需要注意的是，调用语句必须放在开头且只能嵌套一个。如果出现了形参名字和成员字段名相同的时候，为了消除歧义，就使用this来表明成员字段名。&lt;/p&gt;

&lt;p&gt;static和this在语义上是相反的，this标明的调用当前方法的一个对象，也就是说，有this出现的方法一般是和特定对象绑定的。但是static是和具体对象无关的，它属于整个类，比较像一个类内的全局方法，任何一个对象都可以调用它，也可以通过类名直接调用。但是在static的函数内，是不能够调用非static方法的，反过来是可以的。&lt;/p&gt;

&lt;p&gt;除了static的方法之外，还有就是static的成员字段值。一般非static的成员字段值都是跟对象绑定的，不同的对象，对于同一个类成员的字段可以有不同的值，但是static是属于整个类的，所以，任何一个对象对static成员字段值的修改，都会影响其他的对象。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Learning-Process-In-Modern-Operating-System(4)</title>
      <link>http://littledriver.net/post/2017/05/30/learning-process-in-modern-operating-system4/</link>
      <pubDate>Tue, 30 May 2017 11:10:32 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/05/30/learning-process-in-modern-operating-system4/</guid>
      
        <description>&lt;h1 id=&#34;进程间通信-ipc&#34;&gt;进程间通信(IPC)&lt;/h1&gt;

&lt;h2 id=&#34;竞争条件&#34;&gt;竞争条件&lt;/h2&gt;

&lt;p&gt;在多个进程同时运行的情况下，如果他们都需要使用某一块共享内存中的数据，那么最后的结果取决于这些进程精确的执行顺序。这种情况就叫做竞争条件。日常开发中，这类的情况也是非常常见的。如两个进程都会使用某一个存储于共享内存中的变量，A进程先读到这个值，但是由于时间片用完等原因被切换到另一个进程B运行，B在运行期间改变了共享内存中那个变量的值。此时A再被调度执行的时候，显然它读到的变量的值就是不对的。尤其是算数操作，对这个变量做+1操作，那么这种情况将会导致错误的结果。&lt;/p&gt;

&lt;h2 id=&#34;临界区&#34;&gt;临界区&lt;/h2&gt;

&lt;p&gt;产生上述所说的竞争条件的原因是因为多个进程能够同时读取共享的资源，并且没有一定的先后顺序。为了阻止这种情况，就需要在一个进程访问共享资源的同时，另外一个进程在一旁等候。也就是说，同一时间只能有一个进程来访问某一块共享的资源。
进程中，访问这种共享资源的代码被称为临界区。在这里需要特别注意的是，临界区指的是代码而不是某个共享资源。要保证同一时间某个共享资源只能被一个进程访问，就需要调整多个进程不能在同一之间执行临界区内的代码。&lt;/p&gt;

&lt;h2 id=&#34;忙等待的互斥&#34;&gt;忙等待的互斥&lt;/h2&gt;

&lt;p&gt;要实现进程之间临界区的互斥，有以下几种方式：&lt;/p&gt;

&lt;h3 id=&#34;屏蔽中断&#34;&gt;屏蔽中断&lt;/h3&gt;

&lt;p&gt;这种做法是很暴力的。即在进程进入临界区之后，立刻屏蔽来自外界的所有中断。这样一来，cpu就无法依靠中断来切换进程的执行了。除非进入临界区进程自己打开中断或者主动退出。但是，这种情况只能是在单cpu下才能够成立的。因为多cpu的情况下，即使是屏蔽中断也只是屏蔽了执行diable指令的那个cpu，其他的cpu并不知道该进程屏蔽中断的事实，因此他们所调度的进程仍然可以访问共享内存。其次，就算是在单核下面这种办法是有效的，但是它的危险性也会很高。如果一个进程屏蔽中断但是恶意的不打开中断，那么这个进程就会一直执行，操作系统有可能因为这种原因被卡死。&lt;/p&gt;

&lt;h3 id=&#34;锁变量&#34;&gt;锁变量&lt;/h3&gt;

&lt;p&gt;这里所说的锁变量和我们之前在写程序的时候说的锁变量是不一致的。日常开发中所说的互斥锁，用于同一个进程中的不同的线程上面。锁住的也是进程内的共享资源。但是这里说的锁变量是进程级别的，因为进程之间本身就是独立的，所以要想所有的进程都能够访问一个变量，那么这个变量就是共享的。既然是共享的，那么该锁变量本身的互斥性又有谁来保证呢？显然是没办法的，这么想的话，就进入了无限递归了。&lt;/p&gt;

&lt;h3 id=&#34;严格轮换法&#34;&gt;严格轮换法&lt;/h3&gt;

&lt;p&gt;严格轮换法也是依靠某一个共享变量，这个共享变量有一个初始值。多个不同的进程在可以进入临界区之前都会读取这个共享变量，如果这个共享变量的值指示当前进程可以进入临界区，那么该进程就可以正常访问，并且在离开临界区之前将此共享变量置为另外一个值。想用这种办法的一个前提就是，共享变量的取值集合数对应了共享它的进程数。每一个进程在想进入临界区之前都要忙等待轮训这个变量的值是否属于自己的那个。当离开临界区之前也要把响应的共享变量置为其他进程所需要的值才行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;//process 0

enter_region{
	while(1){
	while(turn != 0) continue;
	...
	turn = 1;
	break;
	}
}

//process 1
enter_region{
	while(1){
		while(turn != 1) continue;
		...
		turn = 0;
		break;
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如上面的伪代码所示，如果现在有两个进程需要进入同一块临界区。共享变量初始值为0，那么0号进程将首先获得该临界区的访问权限，1号进程由于检查turn的值并不是属于自己可以获取权限的值，就进入循环，使用忙等待的方式，不断的访问turn变量。当0号进程执行完毕，离开临界区的时候，会将turn置为1，此时将锁的使用权限给了process1，process1得到锁之后便可以访问临界区。&lt;/p&gt;

&lt;p&gt;目前还只有两个进程，使用起来还不是特别的麻烦。但是如果有多个进程的时候，其中一个进程执行完毕，接下来这个锁的权限给谁，看起来是依靠当前的这个进程来决定的。那么这就有一定的几率是会成环的。&lt;/p&gt;

&lt;p&gt;另外一个缺点就是，如果0号进程把锁的权限给了1号，但是1号还没有进入临界区。那么0号就得一直等到1号进入临界区并执行完毕，然后再把锁的权限给0号。此时0号将会经历相当长一段忙等待的时间。忙等待是非常消耗cpu资源的，它也被成为是自旋锁。如果两个多个进程之间不是严格的轮换，那么这种效率是非常低的。解决临界区互斥方案的一个重要的原则，就是保证处于临界区外部的进程不应该阻止想要进入临界区执行的进程。轮换法的方案，显然在多个进程执行步调不一致的时候，违反了这一原则。并且，多个线程的情况下，锁权限传递成环也违反了不能使某些进程无限期等待进入临界区的原则。&lt;/p&gt;

&lt;h3 id=&#34;tsl指令&#34;&gt;TSL指令&lt;/h3&gt;

&lt;p&gt;TSL指令已经属于硬件层面上的互斥措施了。该指令首先将内存中的一个字lock读入到寄存器内，并且在该内存地址上插入一个非零值。读和写的操作保证是原子性的，指令结束之前，都会锁住内存总线，以此来避免其他cpu来访问这块内存。锁住内存总线和屏蔽cpu中断不同，屏蔽cpu中断只是针对执行disable指令的那个cpu而言，但是对于其他的cpu并没有影响。但是锁住内存总线就不一样了。&lt;/p&gt;

&lt;p&gt;tsl指令在用于解决竞争条件的问题上，有以下处理方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将内存中的lock的值复制到寄存器中并且将内存中的lock值置为非零值&lt;/li&gt;
&lt;li&gt;将寄存器中的lock值与0进行对比，如果相等则证明临界区可以进入。否则继续第一步，直到寄存器中的lock值为0&lt;/li&gt;
&lt;li&gt;退出临界区的时候，将内存中lock的值用move指令变为0即可释放临界区的访问权限。&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>Learning-Process-In-Modern-Operating-System(3)</title>
      <link>http://littledriver.net/post/2017/05/30/learning-process-in-modern-operating-system3/</link>
      <pubDate>Tue, 30 May 2017 09:08:08 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/05/30/learning-process-in-modern-operating-system3/</guid>
      
        <description>&lt;h1 id=&#34;经典线程模型&#34;&gt;经典线程模型&lt;/h1&gt;

&lt;p&gt;对于进程来讲，它将进程本身运行所需要的众多资源都包含在了进程的地址空间中，对他们加以管理，来保证进程的正常运行。而在进程中，真正被调度并执行一定逻辑的却是线程。一个进程被创建之后，至少有一个线程，这个线程叫做主线程。其实，借用上一篇文章讨论进程和线程的观点，线程确实可以被当做一个迷你版的进程。试想一下，多个进程运行在操作系统内，共享的资源是硬盘，cpu时间，内存等。那么多个线程在进程的地址空间内，共享的资源是操作系统分配给他们所属进程的资源。唯一一点不同的就是，进程和进程之间是相互独立的，但是多个线程之间确是在同一个进程的地址空间内的。&lt;/p&gt;

&lt;p&gt;既然多个线程在同一个地址空间内，那么对共享的资源进行读写的时候，肯定会涉及到互斥的问题。但是操作系统给出的答案是不可能+不需要。操作系统认为，同一个进程中的多个线程为的是合作，而不是竞争。如果明确的存在竞争关系，那么还是应该借用多进程的处理模式，而不是多线程。但是在实际的开发过程中，我们知道，线程安全是你代码鲁棒性的一个重要因素，我想，操作系统的设计也是想让这部分我们自己来管理，而不是在底层就做好，假想用户的需求。&lt;/p&gt;

&lt;h1 id=&#34;如何实现线程&#34;&gt;如何实现线程&lt;/h1&gt;

&lt;h2 id=&#34;用户态&#34;&gt;用户态&lt;/h2&gt;

&lt;h3 id=&#34;优势&#34;&gt;优势&lt;/h3&gt;

&lt;p&gt;在用户态中实现线程以及相关的操作，一个最大的好处就是，这种方式可以在很多系统层面上不支持线程的操作系统中运行起来。在用户态中实现线程，通常有一个概念叫做runtime system。runtime管理着进程中线程的各种行为，如创建，销毁，调度等。runtime system还负责维护一张线程表，它和操作系统级别的进程表是一样的，保存了线程的各种信息。并且他还包含了一系列管理线程操作的集合，如：pthread_create, pthread_exit等。&lt;/p&gt;

&lt;p&gt;另外一个优点就是，线程的很多操作，都可以在本地完成，不需要内核额外的支持，频繁的使用系统调用效率肯定会降低。所以在线程的操作都可以在runtime系统中进行管理的前提下，彼此之间的工作效率会比较高。并且，在用户态中实现线程，如果有一些想要扩展的功能，在用户空间扩张一些信息表以及堆栈是很方便的。相对内核来讲，由于线程的数量众多，一旦堆栈数量一多事非常麻烦的。&lt;/p&gt;

&lt;h3 id=&#34;劣势&#34;&gt;劣势&lt;/h3&gt;

&lt;p&gt;在用户空间实现线程的劣势，其中一个就是使用阻塞类的系统调用。线程概念的出现，就是让多个不同的线程可以配合起来一起工作。其中一个线程因为一些原因不能运行的话，runtime system就会调度另外一个线程执行。但是如果一个线程使用了一个阻塞的系统调用，那么结果将是灾难性的。这次的调用不仅仅阻塞了使用这个系统调用的线程，它是阻塞了整个进程的，也就是说阻塞了这个进程中的所有线程。这样一来就违背了线程带给我们的好处。其中一个解决办法就是将所有的阻塞系统调用改成非阻塞的，这是比较暴力的一种方法，需要改进操作系统。另外一个就是将阻塞的系统调用换成select系统调用+原始阻塞调用的集合。先通过select来判断预期的阻塞调用是否真的因为条件不满足而会被阻塞住，如果会，那么就通知runtime system来调用另外一个线程执行。等到下一次轮到那个线程的时候，再去使用select来进行检验即可。但是这样一来，一个简单的系统调用的问题就会涉及到很多复杂的更改，而且效率也很低。&lt;/p&gt;

&lt;p&gt;另外一个劣势，是由缺页中断引起的。其实缺页中断并不能算是一个劣势，只不过在用户态实现线程的时候，如果某一个线程引起的缺页中断，但是系统却只认识其所在的进程，那么很自然，系统会阻塞整个进程，直到i/o结束，缺失内存页中的内容从硬盘中加载进来。&lt;/p&gt;

&lt;p&gt;第三个要说明的劣势，是由runtime system包含的对线程处理的过程集合引起的。因为操作系统不认识多线程，只认识多进程。那么在线程的调度上面就没办法借助操作系统进行时间片轮转的处理方式。用户态中，线程之间的调度，如果不是从线程内部发出一个信号，如thread_yield或者thread_join等，从外部是没办法来直接从一个线程切换到另外一个线程上的。
}}&lt;/p&gt;

&lt;h2 id=&#34;内核态&#34;&gt;内核态&lt;/h2&gt;

&lt;h3 id=&#34;劣势-1&#34;&gt;劣势&lt;/h3&gt;

&lt;p&gt;在内核态实现线程最大的劣势，就是开销大。内核在处理进程的调度以及创建和销毁的时候，开销其实就是不小的。加之线程的数量远远超过进程的数量，一方面是切换，创建，销毁这类的操作比较耗费资源，还有一方面就是，之前在用户空间中维护的线程相关的信息，如线程表等将都会由内核来维护。&lt;/p&gt;

&lt;h3 id=&#34;优势-1&#34;&gt;优势&lt;/h3&gt;

&lt;p&gt;优势也很明显，无论一个线程是因为阻塞的系统调用，还是因为缺页中断等原因。内核都会检查其所在进程以及其他进程中的线程有无可以调度运行的，如果有的话，那么就可以进行调度，而不会影响整个进程的运行。&lt;/p&gt;

&lt;h2 id=&#34;混合实现&#34;&gt;混合实现&lt;/h2&gt;

&lt;p&gt;其实不光是操作系统，很多现实生活中的事情也是一样。两种方法各有优劣，那么就将二者的优点结合起来，但是将缺点减半。混合实现的方式便是内核线程和用户线程两者结合起来使用。一个内核线程对应一个用户线程的集合。内核线程通过操作系统来调度处理，但是用户线程通过用户空间本身来进行调度处理。这样一来，既降低了系统资源的开销，也解决了用户态实现线程出现的一些问题。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>nginx Learning notes(2)</title>
      <link>http://littledriver.net/post/2017/05/03/nginx-learning-notes2/</link>
      <pubDate>Wed, 03 May 2017 17:50:55 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/05/03/nginx-learning-notes2/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;本博文是春哥nginx教程的读书笔记，博文内容如有侵权可以私信我删除。 hnustphoenix@gmail.com。春哥的nginx教程地址 &lt;a href=&#34;https://openresty.org/cn/ebooks.html&#34;&gt;https://openresty.org/cn/ebooks.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;nginx请求过程&#34;&gt;Nginx请求过程&lt;/h1&gt;

&lt;p&gt;rewrite，access, content应该是nginx中对一个请求处理的最核心的三个阶段。但是，当我们想对一个请求做更多的控制的时候，nginx也为我们提供了更多的阶段。&lt;/p&gt;

&lt;h2 id=&#34;post-read&#34;&gt;post_read&lt;/h2&gt;

&lt;p&gt;post_read是nginx处理用户请求进行的第一个阶段，这个阶段的指令在nginx解析完请求的头部之后就立即开始运行了。其中ngx_realip模块就是这个阶段中比较常用的，它的作用是可以通过特定的指令修改请求头的来源地址。如下面的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;server{
	set_real_ip_from 127.0.0.1
	real_ip_header X-LOCAL-IP
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这两条来自ngx_realip模块的指令，在处理请求的时候，会把来自本地的请求中的来源地址设置成X-LOCAL-IP这个头部字段所制定的ip。如果该字段的值是空或者不是一个合法的ip格式，那么是不会更改的。nginx中对于请求来源地址有一个相关的内建变量可以直接访问：$remote_addr。如果nginx配置文件中配置了上面在post_read阶段执行的指令并且在rewrite阶段中我们要使用remote_addr这个变量，此时它就是被上面的指令改过的版本。&lt;/p&gt;

&lt;p&gt;之所以需要改动请求来源地址，是因为，如果在nginx前面还有一层代理的话，那么按照原始的方式获取来源ip地址肯定是不准确的，代理服务器一般会在代理的过程中将用户请求的来源地址写入到一个特定的http头部字段中，这样nginx在收到这个请求的时候，就可以做一个翻译，以便后续的阶段使用。post_read阶段是在nginx读取到请求的头部就开始运行的，改写请求来源地址的这类事情还是越早做越好。&lt;/p&gt;

&lt;h2 id=&#34;server-rewrite和rewrite&#34;&gt;server-rewrite和rewrite&lt;/h2&gt;

&lt;p&gt;以我目前所学的Nginx的知识来讲，rewrite阶段一般分为两类，一类是server之内，一类是location之内。location虽说是被包含在server内的，但是location外server内还是可以算作一种特殊的rewrite阶段&amp;mdash;-server-rewrite阶段。server-write阶段的执行顺序仅次于post-read，在rewrite之前运行。&lt;/p&gt;

&lt;h2 id=&#34;find-config&#34;&gt;find_config&lt;/h2&gt;

&lt;p&gt;find_config阶段内，不支持其他nginx模块注册处理程序，这阶段内主要的作用就是将请求和location进行配对。配对成功之后，就会进入和请求对应的location配置块中，location中第一个经历的阶段就是rewrite阶段。&lt;/p&gt;

&lt;h2 id=&#34;post-rewrite&#34;&gt;post_rewrite&lt;/h2&gt;

&lt;p&gt;post_rewrite阶段和find_config阶段一样，不支持nginx模块在此阶段注册处理程序。这一阶段的主要工作是根据rewrite阶段的指令看是否要执行内部跳转操作。上一篇文章中说过rewrite指令是可以实现内部跳转的。rewrite实现内部跳转的原理实际上就是通过改写请求的url，然后使请求的处理阶段倒回find_config阶段。重新将请求的url和location块进行匹配。这个&amp;rdquo;回退&amp;rdquo;的操作之所以没有在rewrite阶段中完成的原因是，rewrite阶段可以执行多个rewrite指令，但是后面的rewrite指令的结果是会覆盖前面的。对于内部跳转这个动作来讲，rewrite阶段的rewrite指令相当于做了一次记录，记录了内部跳转的目的地，最后真正实施内部跳转操作的，实际上是在post_rewrite阶段。&lt;/p&gt;

&lt;p&gt;之前说过，rewrite指令不仅仅可以用来Location内部，还可以用在server内Location外。这个时候进行的请求重写并没有发生在post_rewrite阶段，而是发生在server_rewrite阶段，这个阶段还没有执行find_config阶段内的配对操作，所以不能算是内部跳转，可以算作是内部重定向把，毕竟真正第一次配对的find_config阶段还没有执行。&lt;/p&gt;

&lt;h2 id=&#34;preaccess&#34;&gt;preaccess&lt;/h2&gt;

&lt;p&gt;通过这个阶段的名字我们就可以看出来，此阶段是在access阶段前运行的。ngx_req_limit和ngx_req_zone两个模块分别控制请求的频度和并发度，他们都是运行在preaccess这个阶段中的。前面提到的可以修改请求源地址的ngx_realip模块也在这个阶段注册了处理程序，按道理来说，ngx_realip在post-read阶段来做是最合适的，post-read阶段和任何的location块都是无关的。但是如果我们想在post-head以后的处理阶段中进行需改请求源地址操作的话，就要依赖于ngx_realip在preaccess阶段注册的处理程序。修改请求源站地址的指令可以写在location中，这样在preaccess阶段中就可以执行相关的指令了。&lt;/p&gt;

&lt;h2 id=&#34;access&#34;&gt;access&lt;/h2&gt;

&lt;p&gt;这个阶段在上一篇文章中已经有所提及，是负责对请求做一些访问性的控制操作。除了ngx_access标准模块，ngx_lua中的access_by_lua指令也运行在这个阶段。&lt;/p&gt;

&lt;h2 id=&#34;post-access&#34;&gt;post_access&lt;/h2&gt;

&lt;p&gt;post_access和post_rewrite一样，后者是运行在rewrite之后，前者则是运行在access阶段之后。post_rewrite会将rewrite阶段中的内部跳转指令综合起来，最终在该阶段只跳转一次。post_access会将access阶段中注册的多种访问控制相关处理程序综合起来，根据satisfy指令给出一个逻辑或关系的表达式，任意一个请求在access阶段有satisfy指令的情况下，最终都会根据post_access阶段给出的逻辑表达式来计算其是否能够继续被处理。虽然post_access阶段是在access阶段之后被处理，但是实际上这两个阶段是相互配合的，rewrite和post_rewrite是一样的。&lt;/p&gt;

&lt;h2 id=&#34;try-files&#34;&gt;try_files&lt;/h2&gt;

&lt;p&gt;try_files阶段不支持其他nginx模块注册处理程序。try_files指令接受N个参数，在try_files阶段，该指令会依次检查前N-1个参数对应的文件系统的位置是否存在一个明确的文件对象。如果存在，那么就改写请求uri的值为对应的参数值，否则直接执行一个内部跳转，跳转到第N个参数所制定的url中。&lt;/p&gt;

&lt;p&gt;try_files指令在从左向右匹配的时候，只要是有一个参数被验证在文件系统中有明确的文件对象，那么他就不继续向下匹配了，改写完请求uri之后，就直接进行后面的请求处理阶段。这么说来，在try_files匹配的过程中，对于前N-1个参数来讲都是一个或的关系。&lt;/p&gt;

&lt;p&gt;并且，在第N个参数上，也就是前n-1个参数都没匹配到，无条件内部跳转过去的位置，除了可以指定一个uri来跳转到具体的一个location块，还可以用等号加状态码的形式(=404)，让内部跳转到这个位置的时候，直接根据状态码返回一个响应。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Learning-Process-In-Modern-Operating-System(2)</title>
      <link>http://littledriver.net/post/2017/04/27/learning-process-in-modern-operating-system2/</link>
      <pubDate>Thu, 27 Apr 2017 22:49:25 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/04/27/learning-process-in-modern-operating-system2/</guid>
      
        <description>&lt;h1 id=&#34;有了进程为啥还要线程&#34;&gt;有了进程为啥还要线程&lt;/h1&gt;

&lt;p&gt;上一篇和进程相关的文章讲过为啥操作系统需要进程这个概念，其实说白了，就是操作系统要干太多的事了，一个人搞不定，得让多个人一起来搞，多个人的职责不同，需要耗费的时间和资源也就不同，为了把他们的工作时间重叠起来，让他们好好的配合，提升操作系统整体的工作效率，才有了进程这个概念。这么一说，有了进程就万事大吉了啊，为何还需要线程这个概念呢？&lt;/p&gt;

&lt;p&gt;线程，是一个轻量级的进程。其实看线程的概念就知道了，明显和进程是一回事，只不过线程本身更加轻量级。操作系统本身看做是一个整体的话，那么他有很多事需要处理，自然要分配给不同的进程。那么对于一个进程来说，它要做的事情也绝对不仅仅是很单一的，同样，在进程这个范围内，也需要有很多的工作一起进行。那么套用上面讲过的概念，一个进程自然也需要很多人帮它来完成一件很大的任务，通过内部的调度让多个人的工作可以准并行的执行，那么整个进程的效率就会非常高。这里的“很多人”指的就是线程，一种轻量级的进程。&lt;/p&gt;

&lt;p&gt;线程的优势有以下三点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个进程当中可能需要同时做很多事情才能够满足用户对系统工作效率的要求。所以需要一种轻量级进程的概念&lt;/li&gt;
&lt;li&gt;线程比进程更加轻量级，创建，销毁以及频繁的调度在效率上都比进程进行相关的操作高出不少&lt;/li&gt;
&lt;li&gt;在非cpu密集型的进程中，如果有了多线程的帮助，进程整体的效率会有非常大的提升。对i/o密集型的效果尤其明显&lt;/li&gt;
&lt;li&gt;不同进程之间的地址空间是独立的，互不干扰。但是同一个进程里面的不同线程，他们是共享同一块内存地址空间的，在操作同一个文件或者资源的时候，数据一致性的问题很好处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般的进程如果不刻意创建子线程的话，只有一个主线程，也成为控制线程，整个程序也被称作是单线程的程序。举一个例子来说明，多线程工作方式的好处：假设你现在想做饭，这顿饭里面包含一个汤，一碗米饭以及一个炒菜。如果你是一个人来做这些事情的话，假设每一件事情在做的过程当中都要求你全程看护，阻塞了你这个人不能做其他的事情。那么你就必须将这三件事情按照顺序一件一件的完成。其中炒菜是最慢的，不仅要摘菜，洗菜，还要切菜，最后还要炒熟。这浪费了大量的时间。菜做好了发现还有两件事丝毫还没有进展。这个时候你就会想，要是有另外两个人，在我做菜的同时帮我煲汤和做米饭就好了。于是乎，在多个人参与到这件事中之后，每个人有不同的职责。如果厨房可以支持三个人同时使用的话，那么做出这一顿饭就会非常的快。即使同一时间只允许一个人使用，那么也能够保证，在等米饭煮熟的过程当中可以把做菜和煲汤的人换进来做他们应该做的事情，这样一来，同一段时间可以做多件事情，效率也肯定比最原始的方式要高了。&lt;/p&gt;

&lt;p&gt;通过上面的例子我们可以知道，做饭就是进程，炒菜，米饭，煲汤就是线程。允许多个人同时使用厨房就是多cpu并行，不允许就是单cpu通过调度线程。&lt;/p&gt;

&lt;h2 id=&#34;隐藏的boss-有限状态机&#34;&gt;隐藏的boss&amp;mdash;有限状态机&lt;/h2&gt;

&lt;p&gt;前面说的单线程和多线程的设计模型，其实都基于一点：我们在做一件事情的过程中。无论大小都有可能会被一些系统调用给阻塞住。如果是单线程的设计模型，那么整个cpu就一直处于空转状态，直到这个阻塞的系统调用结束。而多线程设计模型在保证了仍然使用阻塞系统调用的前提下还能够提高整件事情的效率。但是有没有另外一种方案，可以使用非阻塞的系统调用呢？&lt;/p&gt;

&lt;p&gt;既然是非阻塞的，那说白了就是异步的，异步的你就肯定的保存上下文，保存状态。一个线程的执行情况会在多种状态下切换，那么我们就必须要把他们保存起来才行。每执行一个线程调用了非阻塞系统调用之后就可以保存下来当前状态，然后去接收新的请求。新进来的请求可能是一个全新的线程，也可能是上一个线程非阻塞系统调用的返回值。无形中，我们就为系统中多线程的执行情况维护了一套堆栈信息。同一个线程在有限的几个状态下切换，直到完成。这一套模型就被称为是有限状态机。&lt;/p&gt;

&lt;p&gt;其实说到底，多线程的设计模型在多cpu的系统内才能够发挥出最大的优势,但是也有前提，就是这个线程所在的进程，需要做的i/o密集型的任务占比比较大。单cpu多线程虽然调度线程的开销较小，但是总之还是不能实现真正的并行。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Lua Learning notes(1)</title>
      <link>http://littledriver.net/post/2017/04/24/lua-learning-notes1/</link>
      <pubDate>Mon, 24 Apr 2017 18:30:28 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/04/24/lua-learning-notes1/</guid>
      
        <description>&lt;h1 id=&#34;chunks&#34;&gt;Chunks&lt;/h1&gt;

&lt;p&gt;在Lua中，chunk是lua一系列语句的集合。Lua的语句结尾加分号分割，虽然语言上没有强制要求，但是每一个语句后面都加上分号会让程序的逻辑更加清晰。Lua的命令行终端为我们提供了组合运行多个chunk的方式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;lua -la -lb 这个命令会搜索a文件和b文件，并且分别运行这两个文件中的chunk&lt;/li&gt;
&lt;li&gt;交互模式下调用dofile函数，可以把一个lua脚本文件中包含的chunk加载进来，然后无缝的调用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;全局变量&#34;&gt;全局变量&lt;/h1&gt;

&lt;p&gt;Lua中全局变量的行为和python中的普通变量是一样的，我们可以在任何需要某个全局变量的地方直接使用它。如果该全局变量之前没有被初始化，那么这个变量的值就是nil，证明这个变量是不存在的。要删除这个变量的时候也是直接给这个变量赋值为nil即可。只要我们给某个全局变量赋值了，那么就算是创建了这个全局变量。在Lua中，创建全局变量是不要事先声明的，直接赋值即可。&lt;/p&gt;

&lt;h1 id=&#34;命令行参数&#34;&gt;命令行参数&lt;/h1&gt;

&lt;p&gt;Lua脚本在解析命令行参数的时候，以脚本名这个参数为起点，下标为0，右侧以此递增，左侧以此递减。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;lua -e &amp;#34;sin=math.sin&amp;#34; script a b&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;构造一个命令行参数列表的时候，argv[1]为a，argv[-1]为sin=math.sin。其余的以此类推。&lt;/p&gt;

&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;

&lt;p&gt;Lua的数据类型和Python一样，都是动态的，不需要事先定义好某一个变量的数据类型，这点和go是不同的。Lua中也有一种预定义的数据类型叫function,那也就是说，在lua中也可以像在go中那样，把一个函数赋值给某一个变量，之后就可以像使用这个函数一样使用这个变量。&lt;/p&gt;

&lt;h2 id=&#34;nil&#34;&gt;Nil&lt;/h2&gt;

&lt;p&gt;一个没有经过赋值的全局变量，他的值就是nil，类型为Nil。如果想回收或者删除某个全局变量，那么直接将这个全局变量设置为nil即可。&lt;/p&gt;

&lt;h2 id=&#34;booleans&#34;&gt;Booleans&lt;/h2&gt;

&lt;p&gt;Lua中的布尔类型和golang中的含义有所不同。golang中的布尔类型只有true和false两种，其余的整数或者是非零值等都不会自动被转换成相对应的布尔值，但是Lua中是这样的。Lua中除了false和nil为假之外，其他值都为真，这其中包括0或者空字符串。&lt;/p&gt;

&lt;h2 id=&#34;strings&#34;&gt;Strings&lt;/h2&gt;

&lt;p&gt;Lua的字符串和golang中的一样，都是一经定义不允许修改。并且在Lua中，字符串可以使用单双引号来分割，特殊情况下可以使用[[&amp;hellip;]]来表示字符串，它类似python中的三引号，支持多行扩展，且不会翻译字符串中的转移序列，如果第一个字符是换行符还会被忽略掉。&lt;/p&gt;

&lt;p&gt;Lua中当一个字符串参与算数操作的时候，会将其转换为数字，执行相应的计算。如果字符串不能成功转换成数字，那么会报错。Lua中的字符串连接符不是+，而是*..*两个点号。所以，如果你想通过链接的方式将一个数字和字符串链接成一个字符串的时候，就可以使用它。虽然Lua中字符串可以在进行算数操作的时候转换为数字，但是将一个字符串和数字进行比较是错误的，应该使用tonumber函数将一个字符串转换为数字。如果转换失败，tonumber会返回一个nil值。&lt;/p&gt;

&lt;h1 id=&#34;表达式&#34;&gt;表达式&lt;/h1&gt;

&lt;h2 id=&#34;关系运算&#34;&gt;关系运算&lt;/h2&gt;

&lt;p&gt;lua中的==和~=分别用于比较两个操作数相等还是不相等。==在比较同类型数据的时候会比较他们的值，比较不同类型的数据的时候会直接返回false。Lua在比较引用类型对象的时候会检查他们所引用的对象是否是同一个。nil值只会和自己相等。&lt;/p&gt;

&lt;h2 id=&#34;逻辑运算&#34;&gt;逻辑运算&lt;/h2&gt;

&lt;p&gt;Lua中的逻辑运算和其他一些语言中的逻辑运算的结果是不一样的,逻辑运算符认为 false 和 nil 是假(false)，其他为真，0 也是 true。python中的and和or运算符最后计算的结果都是True或者False。但是在Lua中有一套特殊的规则：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;a and b -- 如果 a 为 false，则返回 a，否则返回 b
a or b -- 如果a为true，则返回a，否则返回b&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;一个很实用的技巧:如果 x 为 false 或者 nil 则给 x 赋初始值 v&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;x = x or v&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;但是在Lua中，not 的结果只返回 false 或者 true&lt;/p&gt;

&lt;h2 id=&#34;表的构造&#34;&gt;表的构造&lt;/h2&gt;

&lt;p&gt;Lua中有一个数据类型是table。最简单的构造一个table的形式就是{}。Lua中的表更像是一个大集合，它里面可以存储一切Lua支持的数据类型的数据。表中的成员可以按照key-value的形式存储（record-style），也可以使用索引(list-style)的方式。在读取表中数据的时候，即可以按照key来获取对应的元素，也可以使用索引的方式去获取之前存储在table中的list内的元素。recore_style和list-style是可以混用的。&lt;/p&gt;

&lt;h1 id=&#34;语句&#34;&gt;语句&lt;/h1&gt;

&lt;h2 id=&#34;赋值语句&#34;&gt;赋值语句&lt;/h2&gt;

&lt;p&gt;Lua的赋值语句有几处比较特殊的地方：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Lua的赋值语句支持多个值一起赋值，赋值语句会先将等号右边的所有的值计算出来，然后一次性赋值给左边的变量。&lt;/li&gt;
&lt;li&gt;等号左边的变量数量和等号右边值的数量可以不用一一对应。如果待赋值变量数量大于值的数量，那么没有对应的变量的值是nil。如果值的数量大于等号左边变量的数量，那么多出来的值将会被直接忽略。&lt;/li&gt;
&lt;li&gt;与golang不同，当我们想给多个变量赋值同一个值的时候，golang中: a,b,c=10，lua中: a,b,c=10, 10, 10&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;局部变量&#34;&gt;局部变量&lt;/h2&gt;

&lt;p&gt;在Lua中，默认直接赋值创建的变量都是全局变量。全局变量在整个代码文件的作用域中都是有效的。局部变量的定义方式和全局变量不同，变量名前要加local关键字，并且一个局部变量可能仅仅只是在某个代码块中是有效的。&lt;/p&gt;

&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;

&lt;p&gt;lua中常见的控制结构有几种：if-else, while, for, repeat。这几种控制结构在开头和结尾的地方都有明显的标识，起点是do，终点是end。其中repeat比较特殊，像c语言中的do/while结构是执行body一次，如果condition为true则继续执行，而Lua中的repeat是只要condition为false就继续执行body，直到condition为true。&lt;/p&gt;

&lt;h2 id=&#34;循环语句&#34;&gt;循环语句&lt;/h2&gt;

&lt;p&gt;Lua中提供了四种形式的循环语句&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;while&lt;/li&gt;
&lt;li&gt;repeat&lt;/li&gt;
&lt;li&gt;numeric for&lt;/li&gt;
&lt;li&gt;generic for&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中while和其他语言中的语义是相同的，repeat在上面也介绍过了。下面主要来讲一下两种形式的for语句的使用方法和区别。&lt;/p&gt;

&lt;h3 id=&#34;numeric-for&#34;&gt;numeric for&lt;/h3&gt;

&lt;p&gt;numeric for循环是符合一般编程语言中的for循环形式的，它也是有三个表达式，第一个是初始化，第二个是判定条件，第三个是迭代的步长。第三项是可以忽略的，默认迭代的步长是1。与一般语言中的for循环不同之处是，判定条件的表达式的结果必须是number类型，而不能是布尔类型。如果想要用numeric for来实现一个死循环的话，可以使用math.huge作为循环的判定条件。&lt;/p&gt;

&lt;p&gt;使用的numeric for循环语句的注意事项有一下三点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;for循环中的三个表达式，都是在循环开始之前仅计算一次&lt;/li&gt;
&lt;li&gt;for循环中的变量是局部变量，进入循环之后自动创建的，其作用于只限于这个循环，如果在后面的逻辑中想使用这个变量的值需要在循环退出之前将它保存起来。&lt;/li&gt;
&lt;li&gt;退出循环的时候，不要通过改变循环变量的方式，应该使用break&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;generic-for&#34;&gt;generic for&lt;/h3&gt;

&lt;p&gt;generic for循环类似于python中的in-range形式，golang中的value-range形式，总的来说就是迭代某一个集合中的所有元素。这种类型的循环依赖于一个迭代器的实现，这个迭代器在lua的标准库中有一些已有的实现，如按行读取一个文件，按记录读取一个table，按单词读取一个字符串等。&lt;/p&gt;

&lt;p&gt;generic for循环和numeric for循环有两处在使用上都需要注意的地方&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;循环当中使用的迭代变量是局部的，作用于仅限于这个循环&lt;/li&gt;
&lt;li&gt;不要在循环中改动迭代变量&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;break-return-and-goto&#34;&gt;break, return and goto&lt;/h2&gt;

&lt;p&gt;break语句用于在循环中中断循环的执行，不能够在循环外使用。Lua中的函数在函数尾部默认会有一个隐式的return语句，我们不需要特意的写一个。&lt;/p&gt;

&lt;p&gt;Lua中的return语句和其他语言中的有所不同，比如在golang中或者python中，return语句是可以出现在任何地方的，但是在Lua中return语句只能出现在某一段代码块的末尾或者在end,else,util之前。所以，在debug过程中如果想测试一个函数是否被调用，但是不想测试它的内部逻辑，可以在函数体的开头处加上。即想在任意一个位置执行return的时候，都需要把它包含在do..end里面。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;do
	return
end&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;

&lt;p&gt;函数在接受参数的时候，按正常来讲，传递进来的参数和函数想要接收的参数数量应该是相同的。但是在Lua中，允许二者的数量是不同的。如果传递进来的参数多余函数的形参列表，那么从左到右按照顺序匹配，多余的自动丢弃。如果传递进来的参数小于函数接收的参数数量，从左到右进行匹配，未经赋值的参数的值为nil。虽然我们应该尽量避免实际参数和形式参数数量不同的问题，但是正是由于lua这种机制，以及之前提到的or逻辑运算，可以实现默认参数的功能。&lt;/p&gt;

&lt;h2 id=&#34;多重返回值&#34;&gt;多重返回值&lt;/h2&gt;

&lt;p&gt;Lua中的函数可以一次性返回多个返回值。但是调用lua中的函数在不同的地方，返回值的数量也是不一样的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在多重赋值的过程当中，如果函数的调用是等号右边唯一的一个表达式，那么此时，函数将返回它所有数量的返回值，对应等号左边的变量会接受赋值，多余的丢弃。&lt;/li&gt;
&lt;li&gt;如果函数的调用不是等号右边的唯一一个表达式的话，仅会返回多个返回值中的第一个&lt;/li&gt;
&lt;li&gt;当返回多个返回值的函数在某个函数调用传递参数的时候被调用，如果它是唯一一个函数参数，那么其所有的返回值都会被当做是函数的参数。但是，如果函数的调用处于一个表达式中的话，那么还是只会用该函数返回值的第一个。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Lua中返回值还有一个比较特殊的地方，就是当我们对一个返回多值的函数调用外面再加上一个括号的时候，它就只返回多个返回值中的第一个。&lt;/p&gt;

&lt;p&gt;Lua中的函数在接收可变参数列表之后，如果需要迭代这个列表的话，可以把这个列表里的参数放在一个table当中。如果直接使用{&amp;hellip;}的形式来构造一个table的话，那么如果可变参数列表中有nil值的出现，这个nil值就会被自动的过滤掉，最后的table当中是没有这个nil值的。但是使用table.pack函数的话，就可以无损的把可变参数列表转换到table当中。&lt;/p&gt;

&lt;h2 id=&#34;命名参数&#34;&gt;命名参数&lt;/h2&gt;

&lt;p&gt;给调用的函数传递参数的过程当中是按照位置来匹配的，如果被调用函数参数过多的话，我们又没办法记住他们的先后顺序，python当中就会提供一种可指定函数参数名赋值的机制。但是在Lua中并没有明确提供这种机制，但是使用table我们可以实现差不多的效果。将我们要传递的参数按照key-value的形式存放在一个table当中，然后我们自己对一些标准库需要多个参数的函数进行封装，封装的函数只接受一个参数，就是我们要传递进来的table，这样一来，我们只需要明确的指定一次参数的传递顺序，以后再使用某个标准库函数的时候，就可以直接调用我们封装好的，而不必在意参数的传递顺序。&lt;/p&gt;

&lt;h2 id=&#34;函数值&#34;&gt;函数值&lt;/h2&gt;

&lt;p&gt;lua中的函数是具有一定作用域的一类值。它和其他类型的值一样，可以赋值给变量，并且函数值本身是匿名的，我们之前所看到的function关键字后面所谓的函数名实际上是一个变量，它指向的内存位置中存储了一个函数值。由此可见，在代码中我们可以给同一个&amp;rdquo;函数变量&amp;rdquo;赋值多个“函数值”。如可以给print赋值一个新的函数值。&lt;/p&gt;

&lt;p&gt;实际上lua中的定义一个函数的时候，是创建了一个function类型的数据并把它赋值给了一个变量。&lt;/p&gt;

&lt;h2 id=&#34;非全局函数&#34;&gt;非全局函数&lt;/h2&gt;

&lt;p&gt;非全局函数即为局部函数，局部函数的定义和全局函数的定义无太大差别，在function前面加上local关键字即可。还可以先定义一个local变脸，然后用匿名的函数去初始化它。&lt;/p&gt;

&lt;p&gt;先定义一个local变量然后用一个匿名函数初始化，这样虽然可以定义一个局部函数，但是如果局部函数内涉及到对自己的地柜调用，此时编译时不通过的。因为在定义的过程当中，函数逻辑中对本身的调用失去找的同名的全局变量。改进这种问题的办法也很简单，可以先定义一个local变量，然后把匿名函数赋值给他，而不是初始化。另外一种办法是按照上面说的第一种形式来定义一个局部函数。&lt;/p&gt;

&lt;h2 id=&#34;尾递归&#34;&gt;尾递归&lt;/h2&gt;

&lt;p&gt;Lua中对尾递归的支持很好，它在执行函数内尾递归调用的时候，会自动清除调用者在栈中的所有信息。当被调用者计算完毕的时候，它的结果会直接被返回到当时它的调用者被调用的位置。因为lua语言实现尾递归的时候，是不需要额外的栈空间的，所以lua语言中的尾递归调用理论上是可以无线递归下去的。&lt;/p&gt;

&lt;p&gt;除了了解尾递归在lua语言中的行为，还有一个值得我们注意的就是到底什么样的递归调用才算做是尾递归。我觉得总结起来就是一句话：return语句后面只能接收一个单独的函数调用，且对这个函数调用的结果不能进行任何形式的计算，即使在函数调用的外部加一层括号也是不行的。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>nginx Learning notes(1)</title>
      <link>http://littledriver.net/post/2017/04/24/nginx-learning-notes1/</link>
      <pubDate>Mon, 24 Apr 2017 18:30:13 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/04/24/nginx-learning-notes1/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;本博文是春哥nginx教程的读书笔记，博文内容如有侵权可以私信我删除。 hnustphoenix@gmail.com。春哥的nginx教程地址 &lt;a href=&#34;https://openresty.org/cn/ebooks.html&#34;&gt;https://openresty.org/cn/ebooks.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;变量插值&#34;&gt;变量插值&lt;/h1&gt;

&lt;p&gt;变量插值可以在不使用明确的字符串连接符的情况下，将字符串中的变量替换成相应的字符串，并将它和剩余的字符链接在一起。nginx中没有转义功能，也就是说必须通过不支持变量插值功能的模块将一个变量赋值为$符号，这样在其他输出语句中使用的时候，才能够正常的输出$这个值。如果在变量插值中，变量后面紧接着普通的字符，这个时候为了能够不产生歧义，将使用{}将变量括起来。&lt;/p&gt;

&lt;p&gt;set和geo指令，除了给变量赋值的功能之外，还有创建变量的功效。如果将某个值赋值给一个之前不存在的变量，那么将会自动创建该变量。但是如果，实现没有创建就直接读取这个变量的值，那么就会报错。nginx中，创建变量和给量赋值发生在不同时期内。变量在nginx配置加载的时候就已经创建的。但是并没有做赋值。只有在使用这个变量真正需要使用的时候，才会发生相应的赋值操作。这也就随之带来了两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;运行过程中不能够创建新的变量&lt;/li&gt;
&lt;li&gt;变量如果没有定义就开始使用，那么nginx服务器可能启动失败&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;nginx配置中的变量一经定义其作用范围就是整个配置，所以在不同的server模块下也是可以共享同一个变量的定义的。但是这里要注意的是， 虽然不同server模块之间可以共享变量的定义，但是变量的赋值行为却是无法共享的。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;server{
	location / {
		echo &amp;#34;$foo&amp;#34;
	}
	
	location /test {
		set $foo hahah
		echo &amp;#34;$foo&amp;#34;
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种nginx配置文件，是可以成功启动的。因为nginx中允许共享变量的定义。 但是当我们使用curl来访问/和/test的时候，得到的结果可以证明，$foo这个变量的在每一个location都有一个独立的副本。其实想想，前面说的共享变量定义实际上应该被认为是共享变量的声明，不同的location模块都能够成功识别$foo这个变量。但是，这个变量的值，抑或说这个变量的内存在不同的location下是相互独立的。&lt;/p&gt;

&lt;p&gt;看到上面这个例子，可能会觉得，变量的在内存中的值是和location绑定的，不同的变量在不同的location中会有一份独立的副本存放它的值。但是事实上，一个变量在内存中的副本是和请求绑定的。如从/test运行echo_exec跳转到/，此时在/这个location块下输出foo的值，仍然是hahah。也就是说，在内部跳转的过程当中，它对一个变量使用了同一份内存副本。这就证明了，某个location中使用的变量在内存中的副本并不是和location本身强绑定的，而是和请求绑定的。&lt;/p&gt;

&lt;h1 id=&#34;内建变量&#34;&gt;内建变量&lt;/h1&gt;

&lt;p&gt;nginx中的变量基本可以分为两类，一类是被索引的，另外一类是未被索引的。其实说白了，就是一类是可寻址的，另外一类是不可寻址的。&lt;/p&gt;

&lt;p&gt;可寻址的变量在内存中有一个确定的位置来保存这个变量的值，我们所定义的变量都是这样的。但是一些内建变量，也就是nginx预定义的变量是没有和特定的内存位置来绑定的，对未被索引的内建变量进行读写的时候，实际上都是nginx的存取处理程序在起作用。&lt;/p&gt;

&lt;p&gt;nginx中的存取处理程序类似于面向对象当中的get和set方法。这两个方法将读写操作都封装了起来。你不知道它在内部做了什么操作，只知道他会返回给你想要的数据。一些未被索引的内建变量在读写的时候就依赖的这种机制。如$arg_xxx这个内建变量，它就是未被索引。每次当我们想要读取$arg_变量内保存的参数值的时候，实际上都是由它的存处理程序完成的，它会动态的去解析url的参数串在我们需要的时候，而不是在一开始就把url参数串的参数都解析好了放在那里等我们取用。&lt;/p&gt;

&lt;h1 id=&#34;nginx中的请求&#34;&gt;Nginx中的请求&lt;/h1&gt;

&lt;p&gt;nginx中的请求分为两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主请求：此类请求是由http客户端从nginx外部发起的，通过echo_exec和rewrite发起的请求也属于主请求。&lt;/li&gt;
&lt;li&gt;子请求：此类请求和http没有任何关系，属于在Nginx内部将一个请求划分为多个子请求进行处理，是一种抽象的概念。这些子请求既可以串行的进行，也可以并行的进行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前面说过，nginx中的变量的内存分配情况是和请求相关的。对于同名的变量，每一个请求都对这个变量有一份唯一的内存拷贝，保证了多个请求之间对同名变量的操作是独立的。这一特性不仅仅体现在主请求中，在父子请求的逻辑关系中对待同名变量也是一样的。但是这种行为是有特殊情况的，比如在ngx_auth_request模块中的auth_request指令，此时它所执行的子请求就和父请求是共享同名变量的内存的。&lt;/p&gt;

&lt;p&gt;上面所说的受主，子请求影响的变量是用户自定义的。那么nginx内建的变量会受什么影响呢？
如果是通过nginx的存取处理程序来处理的内建变量，在主，子请求上，大部分的内建变量都是基于当前请求的，主请求和子请求在访问这种内建变量的时候都会重新去计算内建变量的数据。但是也有少数内建变量只作用于主请求，如$request_method内建变量。&lt;/p&gt;

&lt;h1 id=&#34;变量类型&#34;&gt;变量类型&lt;/h1&gt;

&lt;p&gt;nginx中正常的变量只有一种类型：字符串。但是同时也有两种比较特殊的类型：invalid和notfound。但定义了一个变量但是没有给他赋值的时候，那么这个变量的值就是不合法的。当一个变量不存在的时候，你直接去引用它，这个变量就是不存在的。&lt;/p&gt;

&lt;p&gt;在使用set指令创建一个变量的时候，在某个请求中，如果此变量还没有被初始化，按理来说，此时使用这个变量的时候它保存值的类型是invalid。那么为什么在使用的时候没有报错呢？是因为set指令在创建一个变量的时候自动为这个变量创建了一个取处理程序，如果在使用这个具有明确内存空间的变量但是里面没有被初始化值的时候，nginx就会调用这个取处理程序，生成一个空值，并且缓存在这个变量对应的内存空间中。一些支持缓存机制的内建变量也是用的这样的一套机制，只不过这种内建变量，在生存周期内只会运行一次取处理程序。&lt;/p&gt;

&lt;h1 id=&#34;nginx指令执行顺序&#34;&gt;nginx指令执行顺序&lt;/h1&gt;

&lt;p&gt;经过这几天对nginx的了解，我觉得nginx和我们本身在写的服务端是没有什么区别的，只不过不同服务的职责是不同的。nginx这种服务主要是处理请求的负载均衡，在请求还没有正式进入我们后面的负责业务逻辑的服务中，先做一层代理，以便我们可以从容的控制用户的请求，防止被被攻击，为后端核心服务提供稳定运行的保证。通过前面的学习，我们知道，在nginx的配置文件中，可以通过制定Location来自定义服务器的路由。那么在一个Location块中，处理这个请求的众多nginx指令是按照什么顺序执行的？一定是按照书写的顺序执行的么？&lt;/p&gt;

&lt;p&gt;nginx在处理一个用户请求的时候，只按照不同的阶段依次处理的。nginx中请求的处理阶段一共有11个，常见的有三个。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;rewrite&lt;/li&gt;
&lt;li&gt;access&lt;/li&gt;
&lt;li&gt;content&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这三个阶段的处理的先后顺序从上到下。其中我们之前看到的set指令就是在rewrite阶段运行的，而echo指令是在content阶段运行。对于多条set指令而言，他们的执行顺序是按照ngx_rewrite模块来保证和书写顺序一致的,同理多条echo指令也是一样的。&lt;/p&gt;

&lt;h2 id=&#34;rewrite&#34;&gt;rewrite&lt;/h2&gt;

&lt;p&gt;ngx_rewrite模块中所包含的指令基本都运行在请求处理的rewrite阶段。如果该模块中的指令是在server配置模块中，那么这一系列的指令将会运行在一个更早的阶段，叫做server_rewrite。一些第三方的模块如果也是在rewrite阶段执行的， 并且其指令已经嵌入到了ngx_rewrite指令序列中，那么第三方模块的指令和ngx_rewrite会按照我们书写的顺序进行执行。否则，他们之间的执行顺序是不能保证的。在nginx当中，可能会有多个模块的只能共同运行在同一阶段中，但是运行在同一阶段中的指令执行顺序并没有一个明确的规定，所以应该避免写这种依赖执行顺序的代码。&lt;/p&gt;

&lt;p&gt;rewrite是对请求较早的处理阶段，一般在这个阶段里会对请求做一些定制化的操作，如改写头部等&lt;/p&gt;

&lt;h2 id=&#34;access&#34;&gt;access&lt;/h2&gt;

&lt;p&gt;在此阶段执行的指令，大多数都是对请求的访问性进行一些控制，如黑白名单，访问权限等等。ngx_access模块内的指令如果有多条出现在access阶段中，那么他们会顺序执行。与access相关的指令也都在ngx_access这个模块内。无论是在rewrite还是access阶段，想要插入我们自定义的lua脚本代码，都需要用到ngx_x模块中的xxx_by_lua指令。这条指令一般在rewrite和access阶段的末尾执行，也就是说ngx_x模块的指令都执行完了，最后在执行xxx_by_lua。&lt;/p&gt;

&lt;h2 id=&#34;content&#34;&gt;content&lt;/h2&gt;

&lt;p&gt;content阶段的指令主要负责生成Http中的response并返回给外部请求的客户端。在rewrite阶段和access阶段中，只要是该阶段的指令，那么多个模块的指令是可以配合起来用的。比如在access阶段中的ngx_access和ngx_lua两个模块中的指令可以共存于access阶段，并且按照一定的顺序运行。但是对于content来说，这是不可行的。&lt;/p&gt;

&lt;p&gt;在一个location块中，只能有一个所谓的&amp;rdquo;内容处理程序&amp;rdquo;。如果我们写入了多个内容处理程序，那么究竟谁会执行是无法确定的。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;worker_processes  1;
events {
        worker_connections 1024;
}
error_log logs/error.log debug;
http {
    server {
	listen 8080;
        location /test {
	    echo &amp;#34;fuck you&amp;#34;;
	    content_by_lua &amp;#39;ngx.say(&amp;#34;hello world&amp;#34;)&amp;#39;;
	}
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在location部分中有两个所谓的内容处理程序，他们来自不同的包，但是最后只输出了helloworld。当你将echo和content_by_lua交换位置之后，最后会输出fuckyou。对于某些指令来说，如果在一个location的范围内，有多个同一个模块下的指令被用作内容处理程序的时候会按照一定的顺序都执行一遍。而有的模块则不行。比如多个echo在同一个location中就可以按照一定的顺序都执行一遍，但是content_by_lua就只会执行一次。&lt;/p&gt;

&lt;p&gt;在content阶段中，如果我们实现没有注册一个“内容处理程序”，那么nginx会把这个请求映射到几个文件系统静态资源服务模块上。默认情况下，nginx会为我们安排三个静态资源服务模块，ngx_index, ngx_autoindex, ngx_static。前面两个模块都作用于以／结尾的请求，static模块作用于不以／结尾的请求。&lt;/p&gt;

&lt;p&gt;ngx_index模块中的index指令会在nginx所在的文件系统中查找指定的文件。如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	location / {
	    root /var/www/;
	    index index.html;
	    autoindex on;
	}
	
	location /index.html {
	    echo &amp;#34;fuck&amp;#34;;
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当请求是直接访问根目录的时候，首先通过root指令指定后面指令所运行的目录。index指令将会在root指令所指示的目录下查找index.html这个文件，如果找到了，那么内部跳转到/index.html的location块中进行请求的处理。如果不存在，那么直接放弃这个请求的处理。也就是说，根据上面的配置，如果/var/www/这个目录下有index.html这个文件，那么访问根目录的时候就会条换到/index.html这个location中，输出fuck。否则将会返回错误信息。&lt;/p&gt;

&lt;p&gt;当nginx保持上面的配置文件不变，删除/var/www目录下的index.html文件之后，会发现并没有和预期中的一样报错。而是访问到了一个目录索引的html页面，这个页面就是autoindex指令为我们生成的。如果此时你将autoindex指令去掉，那么就会因为没有找到这个index.html文件而报错403。&lt;/p&gt;

&lt;p&gt;之前说过，ngx_index和ngx_autoindex都是处理以/结尾的请求，但是ngx_static模块正好相反。ngx_static作为content阶段最后一个执行的模块，主要负责将文件系统中的一些静态资源作为响应返回给客户端。假设现在在/var/www/目录下创建两个html文件分别是1.html和2.html。在location /中只留下root /var/www/这一条指令。那么在访问&lt;a href=&#34;http://localhost:8080/1.html的时候，ngx_static模块就会为我们在目录下找到相应的文件并且返回给我们。&#34;&gt;http://localhost:8080/1.html的时候，ngx_static模块就会为我们在目录下找到相应的文件并且返回给我们。&lt;/a&gt; ngx_static模块默认是一直开启的，但是是否会运行该模块相关的指令就看它之前的模块是否运行了。上面的nginx的配置中，我们是在location内部制定了文档的根目录，如果没有制定的话，那么默认它就是nginx安装的根目录。如果在启动nginx的时候使用了-p这个参数，那么-p这个参数所制定的路径就是文档根目录。在ngx_static模块生效的时候，如果没指定文档根目录，那么它就会去默认的目录下的/html子目录下查找相应的静态资源。&lt;/p&gt;

&lt;p&gt;content阶段中默认的静态资源服务可能在一般情况下并不是我们想要的，所以在写nginx配置文件的时候，如果明确的不想使用默认的静态资源服务，一定不要忘记注册相应的&amp;rdquo;内容处理程序&amp;rdquo;。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>golang-net-http-package源码分析-4</title>
      <link>http://littledriver.net/post/2017/04/24/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4/</link>
      <pubDate>Mon, 24 Apr 2017 10:34:39 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/04/24/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4/</guid>
      
        <description>&lt;h1 id=&#34;transport&#34;&gt;Transport&lt;/h1&gt;

&lt;h2 id=&#34;field&#34;&gt;Field&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; Proxy func(*Request) (*url.URL, error)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Proxy接受一个request，返回一个url.URL的对象。Proxy和ProxyEnvironment的函数签名是一样的，他们有着同样的类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;DialContext func(ctx context.Context, network, addr string) (net.Conn, error)
Dial func(network, addr string) (net.Conn, error)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面两个Field都是函数类型的对象，调用之后可以生成一个未加密的tcp链接。但是文档中明确提示我们，应该使用DialContext来代替Dail，因为前者可以在我们不需要这个链接的时候主动将它结束。如果一个Transport类型对象中这两个属性都赋值了，那么DialContext的优先级是要比Dial高的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;DialTLS func(network, addr string) (net.Conn, error)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;DialTLS的调用将会建立一个TLS的链接。如果DialTLS成员被初始化，那么对于https的request就会被DialTLS成员给Hook住，否则就由Dial和TLSClientConfig两个成员配合起来做这件事。DialTLS调用之后返回的链接默认是Tls握手已经完成的状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;TLSClientConfig *tls.Config
TLSHandshakeTimeout time.Duration&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;客户端上https的相关配置以及https握手的超时时间。但是在DialTLS成员被赋值了之后，这两个成员的值就将会被忽略了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;DisableKeepAlives bool&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果这个属性被置为true,那么在两次不同的请求之间就不会对同一条tcp链接进行重用了，即关闭了Keep-Alive功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;MaxIdleConns int
MaxIdleConnsPerHost int
IdleConnTimeout time.Duration&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;MaxIdleConns属性为一个Transport对所有的host开启的最大空闲连接数，是一个总量，MaxIdleConnsPerHost为对每一个host所能开启的最大空闲连接数。IdleConnTimeout为空闲链接保持多久将会关闭它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;ResponseHeaderTimeout time.Duration&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ResponseHeaderTimeout指定了一个从发送了所有的request到得到服务端发送的response的Header的超时时间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;MaxResponseHeaderBytes int64&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;MaxResponseHeaderBytes指定了客户端所能接受服务端发送response的最大字节数。&lt;/p&gt;

&lt;h2 id=&#34;method&#34;&gt;Method&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (t *Transport) CancelRequest(req *Request) {
	t.cancelRequest(req, errRequestCanceled)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;cancelRequest函数内部读取了一个map[*Request]func(error)类型的map，key为request，value是request对应的cancel方法。先把request对应的cancel method拷贝出来，然后从map中删除这一条记录，最后调用这个cancel方法，关闭连接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (t *Transport) CloseIdleConnections() {
	t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)
	t.idleMu.Lock()
	m := t.idleConn
	t.idleConn = nil
	t.idleConnCh = nil
	t.wantIdle = true
	t.idleLRU = connLRU{}
	t.idleMu.Unlock()
	for _, conns := range m {
		for _, pconn := range conns {
			pconn.close(errCloseIdleConns)
		}
	}
	if t2 := t.h2transport; t2 != nil {
		t2.CloseIdleConnections()
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;CloseIdleConnections函数主要用来关闭因之前的请求建立并且其目前处于空闲的链接。Transport内部有一个idleConn成员，他是一个map类型的变量，其value是persistConn类型，表示了一个已经建立的链接。CloseIdleConnections刚一执行，就将Transport内和空闲链接相关的field都清空，并且将idleConn成员copy了一份。之后它就遍历这个存有很多空闲链接的map，将他们一一关闭。在关闭每一个空闲链接的时候，最终调用了persistConn类型的closeLocked方法，在其内部调用了net包内Conn类型的close方法以真正关闭这条tcp链接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper) {
	t.altMu.Lock()
	defer t.altMu.Unlock()
	oldMap, _ := t.altProto.Load().(map[string]RoundTripper)
	if _, exists := oldMap[scheme]; exists {
		panic(&amp;#34;protocol &amp;#34; + scheme + &amp;#34; already registered&amp;#34;)
	}
	newMap := make(map[string]RoundTripper)
	for k, v := range oldMap {
		newMap[k] = v
	}
	newMap[scheme] = rt
	t.altProto.Store(newMap)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;RegisterProtocol函数将会注册一个scheme和处理使用这个scheme请求的RoundTripper方法到map中。在处理请求的时候，会根据请求使用的scheme对map中的roundtripe方法进行匹配。如果没有根据scheme注册特殊的RoundTripper方法，那么会调用默认的RoundTripper&lt;/p&gt;

&lt;h3 id=&#34;roundtrip&#34;&gt;RoundTrip&lt;/h3&gt;

&lt;p&gt;RoundTrip其实是RoundTriper这个Interface的一个方法，你给它一个请求，它吐给你一个响应。在golang的http框架中，Client发送请求接受响应的逻辑主要就是依赖于对RoundTrip函数的实现，Client定义中有一个名为Transport的成员，它的类型是RoundTripper，一般来说都是调用这个成员的RoundTrip方法。在我们创建一个Client对象的时候，如果没为其特意指定一个实现了RoundTrip方法的对象，那么Client会使用一个预定义的Transport类型的变量。所以说，Transport应该才是Client的核心实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)
	ctx := req.Context()
	trace := httptrace.ContextClientTrace(ctx)

	if req.URL == nil {
		req.closeBody()
		return nil, errors.New(&amp;#34;http: nil Request.URL&amp;#34;)
	}
	if req.Header == nil {
		req.closeBody()
		return nil, errors.New(&amp;#34;http: nil Request.Header&amp;#34;)
	}
	scheme := req.URL.Scheme
	isHTTP := scheme == &amp;#34;http&amp;#34; || scheme == &amp;#34;https&amp;#34;
	if isHTTP {
		for k, vv := range req.Header {
			if !httplex.ValidHeaderFieldName(k) {
				return nil, fmt.Errorf(&amp;#34;net/http: invalid header field name %q&amp;#34;, k)
			}
			for _, v := range vv {
				if !httplex.ValidHeaderFieldValue(v) {
					return nil, fmt.Errorf(&amp;#34;net/http: invalid header field value %q for key %v&amp;#34;, v, k)
				}
			}
		}
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在RoundTrip前半部分的代码中我们可以看到，它主要做了了些参数检查工作，如url，header等字段值的合法性。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	altProto, _ := t.altProto.Load().(map[string]RoundTripper)
	if altRT := altProto[scheme]; altRT != nil {
		if resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol {
			return resp, err
		}
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接下来RoundTrip方法将在altProto这个atmoic.Value类型的变量中取出一个值，并且将它转换为一个map。其中这个map的value就是一个实现了RoundTrip方法的对象。altProto看起来是Transport这个类型对象中的一个成员，它是atomic.Value类型，里面存储了一个map，注册和请求协议相对应的RoundTrip方法。如果之前已经对某个协议指定了处理使用该协议发送请求的方法，那么在这里就会直接调用RoundTrip方法进行处理。&lt;/p&gt;

&lt;p&gt;如果没有已经事先准备好的RoundTrip方法，那么就需要客户端先与服务端建立tcp连接，以便之后的通信。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;		// Get the cached or newly-created connection to either the
		// host (for http or https), the http proxy, or the http proxy
		// pre-CONNECTed to https server. In any case, we&amp;#39;ll be ready
		// to send it requests.
		pconn, err := t.getConn(treq, cm)
		if err != nil {
			t.setReqCanceler(req, nil)
			req.closeBody()
			return nil, err
		}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;RoundTrip方法中，transport对象调用了getConn方法，这个方法获取一条连接，这条连接可能是之前请求处理完空闲等待使用的，也有可能是新建立的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (*persistConn, error) {
	req := treq.Request
	trace := treq.trace
	ctx := req.Context()
	if trace != nil &amp;amp;&amp;amp; trace.GetConn != nil {
		trace.GetConn(cm.addr())
	}
	if pc, idleSince := t.getIdleConn(cm); pc != nil {
		if trace != nil &amp;amp;&amp;amp; trace.GotConn != nil {
			trace.GotConn(pc.gotIdleConnTrace(idleSince))
		}
		// set request canceler to some non-nil function so we
		// can detect whether it was cleared between now and when
		// we enter roundTrip
		}
		t.setReqCanceler(req, func(error) {})
		return pc, nil
	}
	
	...
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;getConn函数一进来就先调用getIdleConn去获取已经建立但是目前闲置的链接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (t *Transport) getIdleConn(cm connectMethod) (pconn *persistConn, idleSince time.Time) {
	key := cm.key()
	t.idleMu.Lock()
	defer t.idleMu.Unlock()
	for {
		pconns, ok := t.idleConn[key]
		if !ok {
			return nil, time.Time{}
		}
		if len(pconns) == 1 {
			pconn = pconns[0]
			delete(t.idleConn, key)
		} else {
			// 2 or more cached connections; use the most
			// recently used one at the end.
			pconn = pconns[len(pconns)-1]
			t.idleConn[key] = pconns[:len(pconns)-1]
		}
		t.idleLRU.remove(pconn)
		if pconn.isBroken() {
			// There is a tiny window where this is
			// possible, between the connecting dying and
			// the persistConn readLoop calling
			// Transport.removeIdleConn. Just skip it and
			// carry on.
			continue
		}
		if pconn.idleTimer != nil &amp;amp;&amp;amp; !pconn.idleTimer.Stop() {
			// We picked this conn at the ~same time it
			// was expiring and it&amp;#39;s trying to close
			// itself in another goroutine. Don&amp;#39;t use it.
			continue
		}
		return pconn, pconn.idleAt
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在getIdleConn函数内将运行一个死循环，循环内部会在idleConn这个map内根据connectMethod类型内的一些和请求有关的信息，找到一条满足条件的链接返回给外部使用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在只有一条空闲链接的时候没有选择，只有使用这条&lt;/li&gt;
&lt;li&gt;超过2条及以上的空闲链接，选取最近最久未使用的那一条&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在选到链接的之后，在返回给外面使用之前还要检查这个链接是否已经中断了以及这条空闲链接是否已经超时了，如果已经超时了，那么很有可能在别的地方就会被关闭了。不管是中断还是超时，都应该执行continue逻辑重新再空闲连接池内再找一条。&lt;/p&gt;

&lt;p&gt;无论是在调用getIdleConn之前还是之后，都会看到一个ClientTrace类型的变量trace来调用GetConn和GotConn。其实ClientTrace这个类型里面的成员以及方法都是对一个请求具有钩子功能的，其内部的成员和方法可以用来时刻跟踪一个请求在真正发送给服务端之前的各种情况。如果成功获取到空闲的网络连接之后，还将调用setReqCanceler函数，它将设置和本次请求有关的一个取消函数以便在之后可以有效检查一个req是否已经被取消处理。&lt;/p&gt;

&lt;p&gt;如果getIdleConn函数成功获取到一个空闲链接，那么getConn函数将返回这个链接以供外面使用。如果没有获取到合适的空闲链接，那么接下来的逻辑将会创建一条新的链接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	cancelc := make(chan error, 1)
	t.setReqCanceler(req, func(err error) { cancelc &amp;lt;- err })

	go func() {
		pc, err := t.dialConn(ctx, cm)
		dialc &amp;lt;- dialRes{pc, err}
	}()

	idleConnCh := t.getIdleConnCh(cm)
	select {
	case v := &amp;lt;-dialc:
		// Our dial finished.
		if v.pc != nil {
			if trace != nil &amp;amp;&amp;amp; trace.GotConn != nil &amp;amp;&amp;amp; v.pc.alt == nil {
				trace.GotConn(httptrace.GotConnInfo{Conn: v.pc.conn})
			}
			return v.pc, nil
		}
		// Our dial failed. See why to return a nicer error
		// value.
		select {
		case &amp;lt;-req.Cancel:
			// It was an error due to cancelation, so prioritize that
			// error value. (Issue 16049)
			return nil, errRequestCanceledConn
		case &amp;lt;-req.Context().Done():
			return nil, req.Context().Err()
		case err := &amp;lt;-cancelc:
			if err == errRequestCanceled {
				err = errRequestCanceledConn
			}
			return nil, err
		default:
			// It wasn&amp;#39;t an error due to cancelation, so
			// return the original error message:
			return nil, v.err
		}
	case pc := &amp;lt;-idleConnCh:
		// Another request finished first and its net.Conn
		// became available before our dial. Or somebody
		// else&amp;#39;s dial that they didn&amp;#39;t use.
		// But our dial is still going, so give it away
		// when it finishes:
		handlePendingDial()
		if trace != nil &amp;amp;&amp;amp; trace.GotConn != nil {
			trace.GotConn(httptrace.GotConnInfo{Conn: pc.conn, Reused: pc.isReused()})
		}
		return pc, nil
	case &amp;lt;-req.Cancel:
		handlePendingDial()
		return nil, errRequestCanceledConn
	case &amp;lt;-req.Context().Done():
		handlePendingDial()
		return nil, req.Context().Err()
	case err := &amp;lt;-cancelc:
		handlePendingDial()
		if err == errRequestCanceled {
			err = errRequestCanceledConn
		}
		return nil, err
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看出，再创建新的链接时候，主要是靠dialConn这个函数，在一个goroutine里面调用它之后，利用select语句来等待处理建立链接过程当中的各种情况。这里是阻塞的，因为select的case都是阻塞的channel在等待接受到来的值。当链接顺利建立完成的之后，dialc这个channel将会接收到一个值，因此将会命中select的第一个case。如果其接收到的值当中的persistConn类型的成员部位nil那么就应该返回它，一个新的网络链接就已经建立好了。&lt;/p&gt;

&lt;p&gt;那么接下来，我们就来看一下dialConn函数都做了些什么：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;pconn := &amp;amp;persistConn{
		t:             t,
		cacheKey:      cm.key(),
		reqch:         make(chan requestAndChan, 1),
		writech:       make(chan writeRequest, 1),
		closech:       make(chan struct{}),
		writeErrCh:    make(chan error, 1),
		writeLoopDone: make(chan struct{}),
	}
	trace := httptrace.ContextClientTrace(ctx)
	tlsDial := t.DialTLS != nil &amp;amp;&amp;amp; cm.targetScheme == &amp;#34;https&amp;#34; &amp;amp;&amp;amp; cm.proxyURL == nil
	if tlsDial {
		...
	} else {
		conn, err := t.dial(ctx, &amp;#34;tcp&amp;#34;, cm.addr())
		if err != nil {
			if cm.proxyURL != nil {
				// Return a typed error, per Issue 16997:
				err = &amp;amp;net.OpError{Op: &amp;#34;proxyconnect&amp;#34;, Net: &amp;#34;tcp&amp;#34;, Err: err}
			}
			return nil, err
		}
		pconn.conn = conn
	}

	...
	
	pconn.br = bufio.NewReader(pconn)
	pconn.bw = bufio.NewWriter(persistConnWriter{pconn})
	go pconn.readLoop()
	go pconn.writeLoop()
	return pconn, nil&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在不考虑https和代理的情况下，dialConn函数首先会通过t.dial函数建立一个网络链接。之后，通过bufio.NewReader和bufio.NewWriter分别初始化了persistConn类型对象内的br和bw成员。这两个成员一个负责从连接中读取数据，另外一个负责向链接中写入数据。接下来启动两个goroutine，运行读循环和写循环。&lt;/p&gt;

&lt;p&gt;暂时不关心读写循环中做的事情，链接建立之后，回到RoundTrip函数中.&lt;/p&gt;

&lt;p&gt;如果新的链接已经创建好了，那么我们就会拿到一个persistConn类型的连接对象。如果此次http通信的请求还是建立在1.1的版本上的话，就会调用persistConn类型对象的roundTrip函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;		pconn, err := t.getConn(treq, cm)
		if err != nil {
			t.setReqCanceler(req, nil)
			req.closeBody()
			return nil, err
		}

		var resp *Response
		if pconn.alt != nil {
			// HTTP/2 path.
			t.setReqCanceler(req, nil) // not cancelable with CancelRequest
			resp, err = pconn.alt.RoundTrip(req)
		} else {
			resp, err = pconn.roundTrip(treq)
		}
		if err == nil {
			&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;到目前为止，尽管这一路看下来其中的逻辑比较复杂，又是空闲链接，又是读写循环的。但是我们在看这部分源码的时候，要始终记住一条线。客户端与服务端建立链接，在次连接上发送请求，从此链接上获取请求响应。那么到目前为止，客户端已经与服务端建立了一个连接了，接下来就是在这条连接上进行Http的通信。那么发送请求和接收响应的的逻辑主要就是在roundTrip这个方法内了。因为我们可以清楚的看到，这个方法传进去一个request，返回一个response.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ps: 个人觉得看源码最忌讳的就是被源码绕晕了。任何一个开源项目的远吗都是很复杂的，如果你一头扎进去，深度优先遍历得看，那老铁你很快就从入门到放弃了。所以说，看源码第一遍的时候，尽量不要在意太多细节。把整体的脉络先屡清楚，然后一点点的去追各种细节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;roundTrip方法内具体是怎么做的，我们跟进去看看。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) {
	....
	writeErrCh := make(chan error, 1)
	pc.writech &amp;lt;- writeRequest{req, writeErrCh, continueCh}

	resc := make(chan responseAndError)
	pc.reqch &amp;lt;- requestAndChan{
		req:        req.Request,
		ch:         resc,
		addedGzip:  requestedGzip,
		continueCh: continueCh,
		callerGone: gone,
	}

	var re responseAndError
	var respHeaderTimer &amp;lt;-chan time.Time
	cancelChan := req.Request.Cancel
	ctxDoneChan := req.Context().Done()
WaitResponse:
	for {
		testHookWaitResLoop()
		select {
		case err := &amp;lt;-writeErrCh:
			if err != nil {
				if cerr := pc.canceled(); cerr != nil {
					err = cerr
				}
				re = responseAndError{err: err}
				pc.close(fmt.Errorf(&amp;#34;write error: %v&amp;#34;, err))
				break WaitResponse
			}
			if d := pc.t.ResponseHeaderTimeout; d &amp;gt; 0 {
				timer := time.NewTimer(d)
				defer timer.Stop() // prevent leaks
				respHeaderTimer = timer.C
			}
		case &amp;lt;-pc.closech:
			re = responseAndError{err: pc.mapRoundTripErrorAfterClosed(req.Request, startBytesWritten)}
			break WaitResponse
		case &amp;lt;-respHeaderTimer:
			pc.close(errTimeout)
			re = responseAndError{err: errTimeout}
			break WaitResponse
		case re = &amp;lt;-resc:
			re.err = pc.mapRoundTripErrorFromReadLoop(req.Request, startBytesWritten, re.err)
			break WaitResponse
		case &amp;lt;-cancelChan:
			pc.t.CancelRequest(req.Request)
			cancelChan = nil
		case &amp;lt;-ctxDoneChan:
			pc.t.cancelRequest(req.Request, req.Context().Err())
			cancelChan = nil
			ctxDoneChan = nil
		}
	}

	if re.err != nil {
		pc.t.setReqCanceler(req.Request, nil)
	}
	if (re.res == nil) == (re.err == nil) {
		panic(&amp;#34;internal error: exactly one of res or err should be set&amp;#34;)
	}
	return re.res, re.err
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;roundTrip方法前面做了很多检查参数，以及我根本看不到为啥要这么做的逻辑。暂时先忽略，我们要关注的还是核心的发送请求和接收响应的逻辑。所以，我们需要额外注意两行代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	writeErrCh := make(chan error, 1)
	pc.writech &amp;lt;- writeRequest{req, writeErrCh, continueCh}

	resc := make(chan responseAndError)
	pc.reqch &amp;lt;- requestAndChan{
		req:        req.Request,
		ch:         resc,
		addedGzip:  requestedGzip,
		continueCh: continueCh,
		callerGone: gone,
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面这段代码看起来很普通，但是确实开启发请求和读相应的重要部分。代码对pc.writech和pc.reqch两个channel进行了赋值操作。在go语言中，对阻塞性的channel赋值，往往都意味着gorountine之间的通信。那么这两个管道的两段究竟链接了哪些goroutine呢？&lt;/p&gt;

&lt;p&gt;通过查看这两个channel的定义我们就一目了然了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	reqch     chan requestAndChan // written by roundTrip; read by readLoop
	writech   chan writeRequest   // written by roundTrip; read by writeLoop&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这两个channel，正是连接了之前在dialConn函数内开启的两个读写goroutine以及我们目前所看到的roundTrip方法所在的goroutine。这么一看，貌似和之前看到的东西一下子就串起来了。所以说再看源码的时候，不要死磕一个地方，往往你顺着一条线接着向后看看，自然而然的就能够领会到作者这么实现的精妙之处。&lt;/p&gt;

&lt;p&gt;看起来，这一个读goroutine和一个写goroutine都是运行在这条前面所建立的连接上的。猜测一下，读循环负责从连接上读取服务端返回的resp，写循环负责将req传递给服务端。带着这个猜想，我们可以来看看读写goroutine的实现了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (pc *persistConn) writeLoop() {
	defer close(pc.writeLoopDone)
	for {
		select {
		case wr := &amp;lt;-pc.writech:
			startBytesWritten := pc.nwrite
			err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))
			if err == nil {
				err = pc.bw.Flush()
			}
			if err != nil {
				wr.req.Request.closeBody()
				if pc.nwrite == startBytesWritten &amp;amp;&amp;amp; wr.req.outgoingLength() == 0 {
					err = nothingWrittenError{err}
				}
			}
			pc.writeErrCh &amp;lt;- err // to the body reader, which might recycle us
			wr.ch &amp;lt;- err         // to the roundTrip function
			if err != nil {
				pc.close(err)
				return
			}
		case &amp;lt;-pc.closech:
			return
		}
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上面的代码中我们可以看出，pc.writech这个用于写循环的管道在接收了roundtrip方法对其的赋值操作后，有三个关键的操作。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;err = pc.bw.Flush()&lt;/li&gt;
&lt;li&gt;wr.ch &amp;lt;- err         // to the roundTrip function&lt;/li&gt;
&lt;li&gt;pc.writeErrCh &amp;lt;- err&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个操作是调用了bw的Flush方法，跳转bw成员的定义，可以看到它就是为了向链接以及链接另一边链接的服务端写数据用的，他是一个bufio.Writer类型的对象。也就是说，当经过前期的一些处理之后，我们就可以针对使用的链接写入数据。写入数据之后，无论写入的有没有问题，都会把结果通过writech内的ch成员传递给外层的roundTrip，也会传给writeErrCh这个channel。&lt;/p&gt;

&lt;p&gt;既然writech.ch这个成员是为了通知外部的roundTrip方法的，那么writeErrCh这个channel又是用来做什么的呢？首先，在看channel作用的时候，还是要遵守一个原则，channel肯定是连接了两个goroutine。那么这两个goroutine是哪两个呢？查看这个channel的引用我们就可以看到，在readLoop中，我们会调用一个wroteRequest的方法，这个方法内会接受writeErrch这个channel所发送过来的消息。也就是说这个channel是负责链接writeloop和readloop这两个gorountine的。&lt;/p&gt;

&lt;p&gt;其次，我们要看下这个channel的定义，它连接读写循环的gorountine具体起了什么作用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	// writeErrCh passes the request write error (usually nil)
	// from the writeLoop goroutine to the readLoop which passes
	// it off to the res.Body reader, which then uses it to decide
	// whether or not a connection can be reused. Issue 7569.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;源码中的注释说，writeErrCh这个channel，是为了能将请求写入的错误从写循环的goroutine中传递到读循环的goroutine中，以此来判定目前的这条连接是否可用，如果在这条连接上写入数据的时候都出错了，那么想在这条连接读数据也会有问题。
看完了写循环中的几个关键操作，那么是时候先跟着wr.ch的脚步，回到外层的roundTrip中了。&lt;/p&gt;

&lt;p&gt;roundTrip中的后半部分，起了一个死循环外加一个select，用来监控这条连接上的请求和响应的情况。可以看出在监控writeErrCh这个channel的case上，框架先检查在连接上写入数据有误错误，如果没有，那么就要设置定时器，后面应该会等待响应的传输。
基本上writeloop所做的事情就是这样。下面让我们来看下readloop。&lt;/p&gt;

&lt;p&gt;在看readLoop的时候，我们可以换一个思路，这次先看roundTrip方法对读循环channel的监控情况。roundTrip在select中监控了传递给readloop的pc.reqch这个变量里面的ch成员，也就是resc这个channel。可以看出，在成功接收了这个channel返回回来的response之后，roundTrip的任务就完成了，如果期间没有发生任何错误的话，那么这个response就会返回给这个客户端的调用者。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	for alive {
		pc.readLimit = pc.maxHeaderResponseSize()
		_, err := pc.br.Peek(1)

		pc.mu.Lock()
		if pc.numExpectedResponses == 0 {
			pc.readLoopPeekFailLocked(err)
			pc.mu.Unlock()
			return
		}
		pc.mu.Unlock()

		rc := &amp;lt;-pc.reqch
		trace := httptrace.ContextClientTrace(rc.req.Context())

		var resp *Response
		if err == nil {
			resp, err = pc.readResponse(rc, trace)
		} else {
			err = transportReadFromServerError{err}
			closeErr = err
		}
	...
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;读循环中的关键逻辑如上，在readLoop中起了循环，起循环的前提条件是通信的这条连接的是活跃的。也就是通过alive来判断的。运行到rc := &amp;lt;- pc.reqch这一句的时候，如果pc.reqch这个channel如果还没有接受到数据的时候，会在这里卡住。当外层的roundTrip方法向这个channel发送数据的时候，rc接收到数据，开始进入pc.readResponse的逻辑，这个逻辑就是从连接中读取响应数据的关键。&lt;/p&gt;

&lt;p&gt;在pc.readResponse这个方法里，会调用一个同名的大写方法resp, err = ReadResponse(pc.br, rc.req)。这个方法将会从pc.br这个*bufio.Reader类型的对象内，不断的读取response的内容。先逐行的将Http响应的头部的基本信息都解析出来，最后通过readTransfer函数将body以及其他的响应信息都解析出来。&lt;/p&gt;

&lt;p&gt;解析完服务端发回来的响应之后，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	if resp.StatusCode == 100 {
		pc.readLimit = pc.maxHeaderResponseSize() // reset the limit
		resp, err = ReadResponse(pc.br, rc.req)
		if err != nil {
			return
		}
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;go还会检查一下服务端吐出来的statusCode是否是100，如果是100就要继续去读取真正的响应，并且把读取数据的长度限制重置。这里要请求一点的时候，为什么接收到100的状态码之后，客户端仅仅只是继续去读接下来的响应而不是再发一次请求，是因为我们的写循环已经一次性把请求的内容都传递给服务端了。不存在先发送100-continue的请求测试服务端然后再处理的情况。&lt;/p&gt;

&lt;p&gt;获取并解析完body之后，readLoop中会发分几种情况来处理这个响应。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接收这个响应的时候有错误，那么直接将错误返回给外层的roundTrip&lt;/li&gt;
&lt;li&gt;接收的响应没有Body,直接将解析出来的response返回&lt;/li&gt;
&lt;li&gt;如果有body，那么对body要做一些处理。最终返回给外部。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，Transport类型中的RoundTrip方法就已经介绍完毕了。其中还是有很多细节没有去探究的，但是这并不影响我们领略go语言这套http框架实现的精妙之处。这么一边看下来，我觉得实现比较巧妙的就是对几个channel的运用。我目前觉得，能否把go用好，一个是看channel的运用，还有一个就是interface的使用。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>golang-net-http-package源码分析(3)</title>
      <link>http://littledriver.net/post/2017/04/06/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903/</link>
      <pubDate>Thu, 06 Apr 2017 23:36:39 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/04/06/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903/</guid>
      
        <description>&lt;h1 id=&#34;maxbytesreader&#34;&gt;MaxBytesReader&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// MaxBytesReader is similar to io.LimitReader but is intended for
// limiting the size of incoming request bodies. In contrast to
// io.LimitReader, MaxBytesReader&amp;#39;s result is a ReadCloser, returns a
// non-EOF error for a Read beyond the limit, and closes the
// underlying reader when its Close method is called.
//
// MaxBytesReader prevents clients from accidentally or maliciously
// sending a large request and wasting server resources.
func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser {
	return &amp;amp;maxBytesReader{w: w, r: r, n: n}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;maxBytesReader函数返回了一个io.ReadCloser类型的对象，maxBytesReader类型对象实现了io.ReadCloser的全部接口。它主要用于检查服务端收到的request的长度是否超过我们预设的限制。&lt;/p&gt;

&lt;h1 id=&#34;notfound&#34;&gt;NotFound&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// NotFound replies to the request with an HTTP 404 not found error.
func NotFound(w ResponseWriter, r *Request) { Error(w, &amp;#34;404 page not found&amp;#34;, StatusNotFound) }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;notfound方法将404的状态码写入到ResponseWriter里面，并输出404相关错误信息&lt;/p&gt;

&lt;h1 id=&#34;parsehttpversion&#34;&gt;ParseHTTPVersion&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// ParseHTTPVersion parses a HTTP version string.
// &amp;#34;HTTP/1.0&amp;#34; returns (1, 0, true).
func ParseHTTPVersion(vers string) (major, minor int, ok bool) {
	const Big = 1000000 // arbitrary upper bound
	switch vers {
	case &amp;#34;HTTP/1.1&amp;#34;:
		return 1, 1, true
	case &amp;#34;HTTP/1.0&amp;#34;:
		return 1, 0, true
	}
	if !strings.HasPrefix(vers, &amp;#34;HTTP/&amp;#34;) {
		return 0, 0, false
	}
	dot := strings.Index(vers, &amp;#34;.&amp;#34;)
	if dot &amp;lt; 0 {
		return 0, 0, false
	}
	major, err := strconv.Atoi(vers[5:dot])
	if err != nil || major &amp;lt; 0 || major &amp;gt; Big {
		return 0, 0, false
	}
	minor, err = strconv.Atoi(vers[dot+1:])
	if err != nil || minor &amp;lt; 0 || minor &amp;gt; Big {
		return 0, 0, false
	}
	return major, minor, true
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ParseHTTPVersion通过传递进来的字符串来判断http协议版本，里面的逻辑比较简单，几乎是硬编码的方式去做判断。除了1.1和1.0是明确判断之外，最后两个if语句也是可以判断出一些格式合法，但是主副版本号没有在1.1和1.0之内的协议版本。&lt;/p&gt;

&lt;h1 id=&#34;parsetime&#34;&gt;ParseTime&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// ParseTime parses a time header (such as the Date: header),
// trying each of the three formats allowed by HTTP/1.1:
// TimeFormat, time.RFC850, and time.ANSIC.
func ParseTime(text string) (t time.Time, err error) {
	for _, layout := range timeFormats {
		t, err = time.Parse(layout, text)
		if err == nil {
			return
		}
	}
	return
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ParseTime函数将使用time.Parse函数将传递进来的string解析成相应的时间。如果按照预定的时间格式解析成功则返回结果。&lt;/p&gt;

&lt;h1 id=&#34;proxyenvironment&#34;&gt;ProxyEnvironment&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// ProxyFromEnvironment returns the URL of the proxy to use for a
// given request, as indicated by the environment variables
// HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions
// thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https
// requests.
//
// The environment values may be either a complete URL or a
// &amp;#34;host[:port]&amp;#34;, in which case the &amp;#34;http&amp;#34; scheme is assumed.
// An error is returned if the value is a different form.
//
// A nil URL and nil error are returned if no proxy is defined in the
// environment, or a proxy should not be used for the given request,
// as defined by NO_PROXY.
//
// As a special case, if req.URL.Host is &amp;#34;localhost&amp;#34; (with or without
// a port number), then a nil URL and nil error will be returned.
func ProxyFromEnvironment(req *Request) (*url.URL, error) {
	var proxy string
	if req.URL.Scheme == &amp;#34;https&amp;#34; {
		proxy = httpsProxyEnv.Get()
	}
	if proxy == &amp;#34;&amp;#34; {
		proxy = httpProxyEnv.Get()
		if proxy != &amp;#34;&amp;#34; &amp;amp;&amp;amp; os.Getenv(&amp;#34;REQUEST_METHOD&amp;#34;) != &amp;#34;&amp;#34; {
			return nil, errors.New(&amp;#34;net/http: refusing to use HTTP_PROXY value in CGI environment; see golang.org/s/cgihttpproxy&amp;#34;)
		}
	}
	if proxy == &amp;#34;&amp;#34; {
		return nil, nil
	}
	if !useProxy(canonicalAddr(req.URL)) {
		return nil, nil
	}
	proxyURL, err := url.Parse(proxy)
	if err != nil || !strings.HasPrefix(proxyURL.Scheme, &amp;#34;http&amp;#34;) {
		// proxy was bogus. Try prepending &amp;#34;http://&amp;#34; to it and
		// see if that parses correctly. If not, we fall
		// through and complain about the original one.
		if proxyURL, err := url.Parse(&amp;#34;http://&amp;#34; + proxy); err == nil {
			return proxyURL, nil
		}
	}
	if err != nil {
		return nil, fmt.Errorf(&amp;#34;invalid proxy address %q: %v&amp;#34;, proxy, err)
	}
	return proxyURL, nil
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ProxyFromEnvironment这个函数单从输入输出上来看，是根据request的信息，返回给我们一个url.URL的对象。这个对象里保存着根据我们系统的环境变量生成的代理信息。这个代理信息一般都是真正的服务器地址，也就是说，使用golang实现的服务器会起到一个代理的作用，客户端真正需要的内容需要到另外一台机器上去取。&lt;/p&gt;

&lt;p&gt;这个函数工作当中确实没有用过，一直在做cdn管理系统相关的服务，客户端的请求的内容最终都会在我们本地的服务得到应答。所以我们先来看一个对我们来说比较陌生的类型：url.URL&lt;/p&gt;

&lt;h2 id=&#34;url-url&#34;&gt;url.URL&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// A URL represents a parsed URL (technically, a URI reference).
// The general form represented is:
//
//	scheme://[userinfo@]host/path[?query][#fragment]
//
// URLs that do not start with a slash after the scheme are interpreted as:
//
//	scheme:opaque[?query][#fragment]
//
// Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
// A consequence is that it is impossible to tell which slashes in the Path were
// slashes in the raw URL and which were %2f. This distinction is rarely important,
// but when it is, code must not use Path directly.
//
// Go 1.5 introduced the RawPath field to hold the encoded form of Path.
// The Parse function sets both Path and RawPath in the URL it returns,
// and URL&amp;#39;s String method uses RawPath if it is a valid encoding of Path,
// by calling the EscapedPath method.
//
// In earlier versions of Go, the more indirect workarounds were that an
// HTTP server could consult req.RequestURI and an HTTP client could
// construct a URL struct directly and set the Opaque field instead of Path.
// These still work as well.
type URL struct {
	Scheme     string
	Opaque     string    // encoded opaque data
	User       *Userinfo // username and password information
	Host       string    // host or host:port
	Path       string
	RawPath    string // encoded path hint (Go 1.5 and later only; see EscapedPath method)
	ForceQuery bool   // append a query (&amp;#39;?&amp;#39;) even if RawQuery is empty
	RawQuery   string // encoded query values, without &amp;#39;?&amp;#39;
	Fragment   string // fragment for references, without &amp;#39;#&amp;#39;
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;粗略的看了一下该类型的定义就可以知道，这个类型内的成员就是一个合法的url中各个组成部分，我们通过一些方法可以把一条url中的不同元素解析到这个类型的成员里以便我们使用。文档中对一个url进行了划分，并且golang中为我们考虑到了url path在编解码上的问题。URL类型中的Path成员存放的是已经解码的path,而在go1.5版本之后，添加了RawPath这个成员，用于保存已经被编码过的path。&lt;/p&gt;

&lt;p&gt;既然ProxyFromEnvironment函数是根据系统的环境变量来确定代理地址的，那么首先就需要获取到我们系统上有关代理的系统变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;var (
	httpProxyEnv = &amp;amp;envOnce{
		names: []string{&amp;#34;HTTP_PROXY&amp;#34;, &amp;#34;http_proxy&amp;#34;},
	}
	httpsProxyEnv = &amp;amp;envOnce{
		names: []string{&amp;#34;HTTPS_PROXY&amp;#34;, &amp;#34;https_proxy&amp;#34;},
	}
	noProxyEnv = &amp;amp;envOnce{
		names: []string{&amp;#34;NO_PROXY&amp;#34;, &amp;#34;no_proxy&amp;#34;},
	}
)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;代码中我们可以看出，golang中已经预定义了系统中关于Http/Https代理的系统变量名。这些变量名作为envOnce这个类型当中names成员的值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// envOnce looks up an environment variable (optionally by multiple
// names) once. It mitigates expensive lookups on some platforms
// (e.g. Windows).
type envOnce struct {
	names []string
	once  sync.Once
	val   string
}

func (e *envOnce) Get() string {
	e.once.Do(e.init)
	return e.val
}

func (e *envOnce) init() {
	for _, n := range e.names {
		e.val = os.Getenv(n)
		if e.val != &amp;#34;&amp;#34; {
			return
		}
	}
}

// reset is used by tests
func (e *envOnce) reset() {
	e.once = sync.Once{}
	e.val = &amp;#34;&amp;#34;
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;envOnce这个类型有三个方法，我们在ProxyEnvironment方法中使用了envOnce.Get。envOnce的Get方法将会通过sync.Once类型变量的Do方法来执行init方法，init方法逻辑上通过遍历预定义的环境变量名来找出该环境变量在我们的系统中被设置的值并保存于val成员内。那么为什么我们不直接调用init方法，反而要把它传递给sync.Once类型的Do方法呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// Once is an object that will perform exactly one action.
type Once struct {
	m    Mutex
	done uint32
}

// Do calls the function f if and only if Do is being called for the
// first time for this instance of Once. In other words, given
// 	var once Once
// if once.Do(f) is called multiple times, only the first call will invoke f,
// even if f has a different value in each invocation. A new instance of
// Once is required for each function to execute.
//
// Do is intended for initialization that must be run exactly once. Since f
// is niladic, it may be necessary to use a function literal to capture the
// arguments to a function to be invoked by Do:
// 	config.once.Do(func() { config.init(filename) })
//
// Because no call to Do returns until the one call to f returns, if f causes
// Do to be called, it will deadlock.
//
// If f panics, Do considers it to have returned; future calls of Do return
// without calling f.
//
func (o *Once) Do(f func()) {
	if atomic.LoadUint32(&amp;amp;o.done) == 1 {
		return
	}
	// Slow-path.
	o.m.Lock()
	defer o.m.Unlock()
	if o.done == 0 {
		defer atomic.StoreUint32(&amp;amp;o.done, 1)
		f()
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;原来sync.Once为我们提供了一种机制：在同一个sync.Once类型的对象下，只有Do方法第一次被调用的时候，才会执行参数传递进来的f函数。从第二次开始，无论f传递进来是什么值都不会再调用它。而且要注意到的是，sync.Once类型并没有提供任何方法可以改变done的值，也就是说，只要是Do被执行了一次之后，除了通过新定义一个sync.Once的对象之外，就再也没有别的方式可以对f函数进行二次调用了。这也就为什么在envOnce实现的reset方法中对val成员重新赋值了一个新的sync.Once对象,但是这个reset方法是没导出的，不应该在外部使用。由此可见，sync.Once类型的Do方法是为了那些需要某个函数必须且仅能执行一次的情况。这种机制应用在我们获取系统变量的场景下是非常合适的，因为它可以防止频繁的系统调用&lt;/p&gt;

&lt;p&gt;在ProxyFromEnvironment中获取了系统关于代理环境变量的内容之后，我们将会对获取的结果进行判断，如果是空的话，那么直接返回，不需要代理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	if proxy == &amp;#34;&amp;#34; {
		return nil, nil
	}
	if !useProxy(canonicalAddr(req.URL)) {
		return nil, nil
	}
	proxyURL, err := url.Parse(proxy)
	if err != nil || !strings.HasPrefix(proxyURL.Scheme, &amp;#34;http&amp;#34;) {
		// proxy was bogus. Try prepending &amp;#34;http://&amp;#34; to it and
		// see if that parses correctly. If not, we fall
		// through and complain about the original one.
		if proxyURL, err := url.Parse(&amp;#34;http://&amp;#34; + proxy); err == nil {
			return proxyURL, nil
		}
	}
	if err != nil {
		return nil, fmt.Errorf(&amp;#34;invalid proxy address %q: %v&amp;#34;, proxy, err)
	}
	return proxyURL, nil&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;否则我们将会调用useProxy来判断一个被格式化的请求url是否应该使用我们找到的代理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func useProxy(addr string) bool {
	if len(addr) == 0 {
		return true
	}
	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		return false
	}
	if host == &amp;#34;localhost&amp;#34; {
		return false
	}
	if ip := net.ParseIP(host); ip != nil {
		if ip.IsLoopback() {
			return false
		}
	}

	no_proxy := noProxyEnv.Get()
	if no_proxy == &amp;#34;*&amp;#34; {
		return false
	}

	addr = strings.ToLower(strings.TrimSpace(addr))
	if hasPort(addr) {
		addr = addr[:strings.LastIndex(addr, &amp;#34;:&amp;#34;)]
	}

	for _, p := range strings.Split(no_proxy, &amp;#34;,&amp;#34;) {
		p = strings.ToLower(strings.TrimSpace(p))
		if len(p) == 0 {
			continue
		}
		if hasPort(p) {
			p = p[:strings.LastIndex(p, &amp;#34;:&amp;#34;)]
		}
		if addr == p {
			return false
		}
		if p[0] == &amp;#39;.&amp;#39; &amp;amp;&amp;amp; (strings.HasSuffix(addr, p) || addr == p[1:]) {
			// no_proxy &amp;#34;.foo.com&amp;#34; matches &amp;#34;bar.foo.com&amp;#34; or &amp;#34;foo.com&amp;#34;
			return false
		}
		if p[0] != &amp;#39;.&amp;#39; &amp;amp;&amp;amp; strings.HasSuffix(addr, p) &amp;amp;&amp;amp; addr[len(addr)-len(p)-1] == &amp;#39;.&amp;#39; {
			// no_proxy &amp;#34;foo.com&amp;#34; matches &amp;#34;bar.foo.com&amp;#34;
			return false
		}
	}
	return true
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们首先通过检测host和解析成ip之后是否是本地的地址，如果是的话就不应该使用代理了。紧接着会获取no_proxy环境变量,通过判断addr是否能够匹配到no_proxy中的某一条内容来决定是否使用代理。
如果需要使用代理的话，ProxyFromEnvironment函数会调用url.Parse来将Proxy解析成一个合法的url.URL值返回给调用者。&lt;/p&gt;

&lt;h1 id=&#34;proxyurl&#34;&gt;ProxyURL&lt;/h1&gt;

&lt;p&gt;ProxyURL函数和ProxyFromEnvironment有着一样的形式，他们都可以赋值给TransPort类型中的Proxy成员，只不过ProxyURL是原样返回了作为参数传递进来的url.URL。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// ProxyURL returns a proxy function (for use in a Transport)
// that always returns the same URL.
func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error) {
	return func(*Request) (*url.URL, error) {
		return fixedURL, nil
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;redirect&#34;&gt;Redirect&lt;/h1&gt;

&lt;p&gt;Redirect函数将根据我们提供的urlStr，将重定向后的Location字段中的url写入到ResponseHeader中。需要注意的是，location字段的url必须是以绝对路径的形式出现的。如果不是以绝对路径出现的话，我们要通过request的url值提取host和scheme部分加到urlStr之前。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func Redirect(w ResponseWriter, r *Request, urlStr string, code int)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;serve&#34;&gt;Serve&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func Serve(l net.Listener, handler Handler) error {
 		srv := &amp;amp;Server{Handler: handler}
  		return srv.Serve(l)
 }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Serve函数和ListenAndServe函数实际的效果是一样的，只不过Serve函数允许我们自己传递一个listener对象，而ListenAndServe函数是自己new了一个监听特定端口的tcp链接的listerner。&lt;/p&gt;

&lt;h1 id=&#34;servefile&#34;&gt;ServeFile&lt;/h1&gt;

&lt;p&gt;ServeFile函数将根据name参数提供的文件路径所指向的文件内容发送给客户端作为请求的响应。在通过ServeFile处理请求的时候，会根据一定的规则来判断是否要返回给客户端一个重定向的响应：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果请求的url路径是以index.html来结尾的，那么重定向到其所在的目录下。&lt;/li&gt;
&lt;li&gt;如果name所指向的文件的类型是一个目录，且请求的url最后一个字符不是*/*，此时也需要将请求重定向到name所指向目录下&lt;/li&gt;
&lt;li&gt;调用者主动开启重定向功能，根据name所指向的文件类型和url最后一个字符来构造重定向响应中的Location字段。比如，name所指向的文件是目录的话，那么url的最后一个字符必须是 */&lt;em&gt;， 不然就需要重定向。如果name所指向的文件是非目录的话，但是请求url最后一个字符是以&lt;/em&gt;/&lt;em&gt;结尾的，此时需要将url重定向成一个以&lt;/em&gt;/&lt;em&gt;开头 ，不以&lt;/em&gt;/*结尾的url&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果最后判定name所指向的文件是一个目录的话，那么就会去该目录下找到一个index.html的文件，将此文件的内容作为请求的响应内容。如果在目录下没有找到index.html文件的话，就会根据If-Modified-Since来判断客户端缓存的最后时间和服务器该文件修改的时间是否是有偏差的，如果客户端的缓存已经过期了，那么该请求的响应中就会列出该文件目录下的所有内容。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirect bool) {
	const indexPage = &amp;#34;/index.html&amp;#34;

	// redirect .../index.html to .../
	// can&amp;#39;t use Redirect() because that would make the path absolute,
	// which would be a problem running under StripPrefix
	if strings.HasSuffix(r.URL.Path, indexPage) {
		localRedirect(w, r, &amp;#34;./&amp;#34;)
		return
	}

	f, err := fs.Open(name)
	if err != nil {
		msg, code := toHTTPError(err)
		Error(w, msg, code)
		return
	}
	defer f.Close()

	d, err := f.Stat()
	if err != nil {
		msg, code := toHTTPError(err)
		Error(w, msg, code)
		return
	}

	if redirect {
		// redirect to canonical path: / at end of directory url
		// r.URL.Path always begins with /
		url := r.URL.Path
		if d.IsDir() {
			if url[len(url)-1] != &amp;#39;/&amp;#39; {
				localRedirect(w, r, path.Base(url)+&amp;#34;/&amp;#34;)
				return
			}
		} else {
			if url[len(url)-1] == &amp;#39;/&amp;#39; {
				localRedirect(w, r, &amp;#34;../&amp;#34;+path.Base(url))
				return
			}
		}
	}

	// redirect if the directory name doesn&amp;#39;t end in a slash
	if d.IsDir() {
		url := r.URL.Path
		if url[len(url)-1] != &amp;#39;/&amp;#39; {
			localRedirect(w, r, path.Base(url)+&amp;#34;/&amp;#34;)
			return
		}
	}

	// use contents of index.html for directory, if present
	if d.IsDir() {
		index := strings.TrimSuffix(name, &amp;#34;/&amp;#34;) + indexPage
		ff, err := fs.Open(index)
		if err == nil {
			defer ff.Close()
			dd, err := ff.Stat()
			if err == nil {
				name = index
				d = dd
				f = ff
			}
		}
	}

	// Still a directory? (we didn&amp;#39;t find an index.html file)
	if d.IsDir() {
		if checkIfModifiedSince(w, r, d.ModTime()) == condFalse {
			writeNotModified(w)
			return
		}
		w.Header().Set(&amp;#34;Last-Modified&amp;#34;, d.ModTime().UTC().Format(TimeFormat))
		dirList(w, f)
		return
	}

	// serveContent will check modification time
	sizeFunc := func() (int64, error) { return d.Size(), nil }
	serveContent(w, r, d.Name(), d.ModTime(), sizeFunc, f)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;serveContent函数里面将针对请求中是否开启range缓存以及range缓存的参数来向请求的响应中填充文件的内容。&lt;/p&gt;

&lt;h1 id=&#34;setcookie&#34;&gt;SetCookie&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func SetCookie(w ResponseWriter, cookie *Cookie) {
		if v := cookie.String(); v != &amp;#34;&amp;#34; {
			w.Header().Add(&amp;#34;Set-Cookie&amp;#34;, v)
		}
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;SetCookie方法将会向http响应的头部写入Set-Cookie字段以及相应的值。&lt;/p&gt;

&lt;h1 id=&#34;statustext&#34;&gt;StatusText&lt;/h1&gt;

&lt;p&gt;StatusText这个函数将根据传递进来的status code去代码中查找预定义好的map里面查找对应的文字描述并返回。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>golang-net/http-package源码分析(2)</title>
      <link>http://littledriver.net/post/2017/04/05/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/</link>
      <pubDate>Wed, 05 Apr 2017 19:58:31 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/04/05/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/</guid>
      
        <description>&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;

&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt;

&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;  &lt;em&gt;generated with &lt;a href=&#34;https://github.com/thlorenz/doctoc&#34;&gt;DocToc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#detectcontenttype&#34;&gt;DetectContentType&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#error&#34;&gt;Error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#handle&#34;&gt;Handle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#servemux&#34;&gt;ServeMux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#servemuxhandle&#34;&gt;ServeMux.Handle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#handler&#34;&gt;Handler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#servemuxservehttp&#34;&gt;ServeMux.ServeHTTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#handlefunc&#34;&gt;HandleFunc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#listenandserve&#34;&gt;ListenAndServe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt;

&lt;h1 id=&#34;detectcontenttype&#34;&gt;DetectContentType&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	func DetectContentType(data []byte) string&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;DetectContentType函数的功能是根据data字节数组的内容来判定它的Content-Type值。该函数最多取data数据的前512个字节来进行判断，函数内部会先过滤掉一些空白字符，然后就根据一定的匹配算法来进行匹配，如果没有匹配到任何已知的类型，就会返回一个 &amp;ldquo;application/octet-stream&amp;rdquo;。&lt;/p&gt;

&lt;h1 id=&#34;error&#34;&gt;Error&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	func Error(w ResponseWriter, error string, code int)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Error方法将会把用户指定的error和状态码写入ResponseWriter。但是调用这个函数的人需要确保没有进一步的信息写入到ResponseWriter。
实现代码是非常简单的，就是向response的header中写入数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	func Error(w ResponseWriter, error string, code int) {
		w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;text/plain; charset=utf-8&amp;#34;)
		w.Header().Set(&amp;#34;X-Content-Type-Options&amp;#34;, &amp;#34;nosniff&amp;#34;)
		w.WriteHeader(code)
		fmt.Fprintln(w, error)
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;handle&#34;&gt;Handle&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	func Handle(pattern string, handler Handler)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Handle这个方法以及HandleFunc，ServeHttp，DefaultServeMux等都是golang实现的http框架中非常重要的元素，这篇文章接下来的篇幅我将和大家请一起学习它们，以了解一个http请求是如何通过golang实现的http框架来到服务后端处理并最终返回给客户端的。&lt;/p&gt;

&lt;p&gt;简单来说，handle这个函数就是把请求的url和处理这个请求的方法绑定到一起。它的实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// Handle registers the handler for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;servemux&#34;&gt;ServeMux&lt;/h1&gt;

&lt;p&gt;可以看出在Handle方法里面调用了DefaultServeMux的handle方法来实现pattern和handler的绑定操作。那么这个DefaultServeMux是什么呢？DefaultServeMux是ServeMux类型变量的一个指针，ServeMux类型的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// ServeMux is an HTTP request multiplexer.
// It matches the URL of each incoming request against a list of registered
// patterns and calls the handler for the pattern that
// most closely matches the URL.
//
// Patterns name fixed, rooted paths, like &amp;#34;/favicon.ico&amp;#34;,
// or rooted subtrees, like &amp;#34;/images/&amp;#34; (note the trailing slash).
// Longer patterns take precedence over shorter ones, so that
// if there are handlers registered for both &amp;#34;/images/&amp;#34;
// and &amp;#34;/images/thumbnails/&amp;#34;, the latter handler will be
// called for paths beginning &amp;#34;/images/thumbnails/&amp;#34; and the
// former will receive requests for any other paths in the
// &amp;#34;/images/&amp;#34; subtree.
//
// Note that since a pattern ending in a slash names a rooted subtree,
// the pattern &amp;#34;/&amp;#34; matches all paths not matched by other registered
// patterns, not just the URL with Path == &amp;#34;/&amp;#34;.
//
// If a subtree has been registered and a request is received naming the
// subtree root without its trailing slash, ServeMux redirects that
// request to the subtree root (adding the trailing slash). This behavior can
// be overridden with a separate registration for the path without
// the trailing slash. For example, registering &amp;#34;/images/&amp;#34; causes ServeMux
// to redirect a request for &amp;#34;/images&amp;#34; to &amp;#34;/images/&amp;#34;, unless &amp;#34;/images&amp;#34; has
// been registered separately.
//
// Patterns may optionally begin with a host name, restricting matches to
// URLs on that host only. Host-specific patterns take precedence over
// general patterns, so that a handler might register for the two patterns
// &amp;#34;/codesearch&amp;#34; and &amp;#34;codesearch.google.com/&amp;#34; without also taking over
// requests for &amp;#34;http://www.google.com/&amp;#34;.
//
// ServeMux also takes care of sanitizing the URL request path,
// redirecting any request containing . or .. elements or repeated slashes
// to an equivalent, cleaner URL.
type ServeMux struct {
	mu    sync.RWMutex
	m     map[string]muxEntry
	hosts bool // whether any patterns contain hostnames
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其实只看第一段落，我们对一个请求在golang的http框架中流动的过程就有了一个大致的了解：
服务端首先将一些pattern和handler绑定在一起，形成了一个pattern和handler一一对应的列表。ServeMux作为服务端一个http请求路由的角色出现，它将对进来的请求和我们已经构造好的pattern列表进行匹配，找到一个最佳的匹配项，然后调用相应的handler处理请求，最终将结果返回给用户。http包中的Handle方法之所以会调用DefaultServeMux的Handle方法，就是要把一条pattern和handler绑定的列表项注册到ServerMux上。以便ServerMux在接受到外部过来的请求之后可以依此来进行请求的派发。&lt;/p&gt;

&lt;p&gt;文档中既然说到会找到一个最佳的匹配项，那么ServeMux中就会按照一定的匹配规则去做：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果Pattern一个绝对路径指定的文件或者说是一个目录，那么此时，pattern长度越长与请求的匹配度越高。如一个请求[&lt;a href=&#34;http://localhost:9090/abc/def/]()。假设我们注册了两个pattern和handler的表项。一个是/abc/另外一个是/abc/def/，这个时候ServeMux会优先匹配后者。并且需要注意的是，一个请求如果最后是以斜线结尾的，并且没有匹配到任何一个已经注册的Pattern-Handler表项，如果根目录/这个pattern已经被注册则会命中此条规则。&#34;&gt;http://localhost:9090/abc/def/]()。假设我们注册了两个pattern和handler的表项。一个是/abc/另外一个是/abc/def/，这个时候ServeMux会优先匹配后者。并且需要注意的是，一个请求如果最后是以斜线结尾的，并且没有匹配到任何一个已经注册的Pattern-Handler表项，如果根目录/这个pattern已经被注册则会命中此条规则。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果一个子目录的pattern已经注册好了，此时外部进来的一个请求其余的部分都命中这个pattern，但是唯独最后一个斜线不匹配，此时golang的http框架会将这个请求重定向到已经注册好的子目录的handler上。但是如果不带斜线的pattern已经被明确的注册过了，那么此时golang就不会再进行重定向操作。&lt;/li&gt;
&lt;li&gt;如果hosts被置为TRUE，那么在进行匹配的时候就会对请求的path加上hostname作为pattern来进行匹配。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;了解了ServeMux是一个类似http路由的组件，那么接下来就看看ServeMux的Handle方法都做了些什么。&lt;/p&gt;

&lt;h1 id=&#34;servemux-handle&#34;&gt;ServeMux.Handle&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	
// Handle registers the handler for the given pattern.
// If a handler already exists for pattern, Handle panics.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
	mux.mu.Lock()
	defer mux.mu.Unlock()

	if pattern == &amp;#34;&amp;#34; {
		panic(&amp;#34;http: invalid pattern &amp;#34; + pattern)
	}
	if handler == nil {
		panic(&amp;#34;http: nil handler&amp;#34;)
	}
	if mux.m[pattern].explicit {
		panic(&amp;#34;http: multiple registrations for &amp;#34; + pattern)
	}

	if mux.m == nil {
		mux.m = make(map[string]muxEntry)
	}
	mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

	if pattern[0] != &amp;#39;/&amp;#39; {
		mux.hosts = true
	}

	// Helpful behavior:
	// If pattern is /tree/, insert an implicit permanent redirect for /tree.
	// It can be overridden by an explicit registration.
	n := len(pattern)
	if n &amp;gt; 0 &amp;amp;&amp;amp; pattern[n-1] == &amp;#39;/&amp;#39; &amp;amp;&amp;amp; !mux.m[pattern[0:n-1]].explicit {
		// If pattern contains a host name, strip it and use remaining
		// path for redirect.
		path := pattern
		if pattern[0] != &amp;#39;/&amp;#39; {
			// In pattern, at least the last character is a &amp;#39;/&amp;#39;, so
			// strings.Index can&amp;#39;t be -1.
			path = pattern[strings.Index(pattern, &amp;#34;/&amp;#34;):]
		}
		url := &amp;amp;url.URL{Path: path}
		mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;因为Handle方法会修改ServeMux中的Map，为了实现线程安全的Handle方法，一进来就对Handle这个函数加上了写锁。紧接着就是一些参数的检查工作，比如注册的pattern是否为空，handler是否为nil以及该pattern是否已经注册过一次了，这些都是属于非法的注册行为。如果以上的检查都通过了，那么golang将会在ServeMux中的Map内增加一条注册记录。如果此时我们的pattern是以斜线结尾的，那么golang会检测不以斜线结尾的pattern是否已经注册过，如果没有注册过，它会为我们将不带斜线的pattern注册，并且handler重定向到带有斜线的pattern对应的handler。这里需要注意一点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过重定向的方式来注册不带斜线的pattern的时候，explicit并没有置为true，这就说明如果我们以后要明确注册一个不以斜线结尾的pattern的时候，是可以实现覆盖的效果的，不会被前面的检查条件挡住。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;回忆一下我们现在都了解了哪些知识点：首先可以通过一个Http包的Handle方法将一个pattern和handler注册起来，然后发现注册的这个操作实际上是由ServeMux这个类型的对象来实现的，它相当于一个Http的路由，ServeMux在注册时候，会做出一些改变，如为不带斜线的pattern默认添加重定向的Handler等。那么处理一个和Pattern匹配的请求的Handler是个什么东西呢？&lt;/p&gt;

&lt;h1 id=&#34;handler&#34;&gt;Handler&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// A Handler responds to an HTTP request.
//
// ServeHTTP should write reply headers and data to the ResponseWriter
// and then return. Returning signals that the request is finished; it
// is not valid to use the ResponseWriter or read from the
// Request.Body after or concurrently with the completion of the
// ServeHTTP call.
//
// Depending on the HTTP client software, HTTP protocol version, and
// any intermediaries between the client and the Go server, it may not
// be possible to read from the Request.Body after writing to the
// ResponseWriter. Cautious handlers should read the Request.Body
// first, and then reply.
//
// Except for reading the body, handlers should not modify the
// provided Request.
//
// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes
// that the effect of the panic was isolated to the active request.
// It recovers the panic, logs a stack trace to the server error log,
// and hangs up the connection. To abort a handler so the client sees
// an interrupted response but the server doesn&amp;#39;t log an error, panic
// with the value ErrAbortHandler.
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Handler是一个接口，它里面包含了一个ServeHttp的方法，也就是说，任何一个实现了ServeHttp方法的对象，都可以被赋值给Handler对象。Handler正如我们前面所讲到的那样，它负责处理一个http的请求。实际的处理逻辑应该在ServeHttp方法中实现。这个方法接收两个参数，一个是ResponseWriter，一个是Request。ServeHttp方法要保证先读取request，处理完之后把返回的header和body部分写入到responsewriter中，这个处理的顺序不能够颠倒。并且在ServeHttp在将响应结果写入到responseWriter之后，就不应该在使用ResponseWriter和request这两个参数了。说白了，当ServeHttp写入结果到respinseWriter的那一刻，整个http请求的处理就结束了。并且，golang明确的提示我们，ServeHttp内部不应该去修改request的相关信息。当ServeHttp出现panic的时候，golang会recover住它，在服务的日志中输出堆栈信息且挂起这个链接。如果直接终止一个handler，那么服务不会输出错误，而是直接panic崩掉，同时客户端也会得到一个中断的响应。&lt;/p&gt;

&lt;h1 id=&#34;servemux-servehttp&#34;&gt;ServeMux.ServeHTTP&lt;/h1&gt;

&lt;p&gt;既然现在，pattern有了，handler有了，ServeMux的注册功能也有了，那么ServeMux作为一个路由是如何将一个http请求匹配到已经注册的pattern，并且交由这个pattern对应的handler处理的呢？这也就是ServeMux派发request的一个过程。ServeMux也实现了一个ServeHttp的方法，这证明它其实也可以算作是一个handler，那么在外部请求进入到服务的时候，ServeMux会作为一个前置的handler来处理这个请求，而ServeMux的处理方式就是去匹配pattern并且派发这个请求给具体处理逻辑。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == &amp;#34;*&amp;#34; {
		if r.ProtoAtLeast(1, 1) {
			w.Header().Set(&amp;#34;Connection&amp;#34;, &amp;#34;close&amp;#34;)
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r)
	h.ServeHTTP(w, r)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到ServeMux的ServeHttp方法在处理请求的时候，会先检查request中的url是否为*。然后他会检查请求的http协议版本至少要在1.1及以上才是合法的，否则就返回给客户端一个错误。然后，serveMux将会调用Handler方法，该方法中将会检查request中的信息并匹配到相应的pattern，返回给我们一个能够处理该请求的一个handler。最后调用该handler实现的ServeHttp方法处理这个请求。看起来ServeHttp这个方法的重点就在于这个Handler方法的实现了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// Handler returns the handler to use for the given request,
// consulting r.Method, r.Host, and r.URL.Path. It always returns
// a non-nil handler. If the path is not in its canonical form, the
// handler will be an internally-generated handler that redirects
// to the canonical path.
//
// Handler also returns the registered pattern that matches the
// request or, in the case of internally-generated redirects,
// the pattern that will match after following the redirect.
//
// If there is no registered handler that applies to the request,
// Handler returns a ``page not found&amp;#39;&amp;#39; handler and an empty pattern.
func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
	if r.Method != &amp;#34;CONNECT&amp;#34; {
		if p := cleanPath(r.URL.Path); p != r.URL.Path {
			_, pattern = mux.handler(r.Host, p)
			url := *r.URL
			url.Path = p
			return RedirectHandler(url.String(), StatusMovedPermanently), pattern
		}
	}

	return mux.handler(r.Host, r.URL.Path)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Handler这个方法是永远不会返回一个值为nil的handler，即使最后request没有匹配到任何的handler，函数也会返回一个“page not found”的handler。匹配之前，handler会先调用cleanPath来对请求的urlpath做一些清理工作，排除匹配时候的干扰。清理之后的path如果和request内的urlpath不一致的话，那就说明，request内的urlpath是不符合规范的，不是一个标准的形式，此时，golang将会返回一个用于重定向这个请求的Handler。如果确实发生了这种情况，那么ServeMux的ServeHttp方法将会调用RedirectHandler类型的ServeHttp方法来处理请求。通过观察RedirectHandler的ServeHttp方法的实现，我们知道，RedirectHandler在处理请求的时候最终是将重定向的状态码和location头部字段写入到Response的header中，其中location的内容就是根据我们规范过的path来确定的。&lt;/p&gt;

&lt;p&gt;如果request传递进来的path就是一个标准的形式，那么将会调用mux.handler方法开始进行匹配工作.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// handler is the main implementation of Handler.
// The path is known to be in canonical form, except for CONNECT methods.
func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
	mux.mu.RLock()
	defer mux.mu.RUnlock()

	// Host-specific pattern takes precedence over generic ones
	if mux.hosts {
		h, pattern = mux.match(host + path)
	}
	if h == nil {
		h, pattern = mux.match(path)
	}
	if h == nil {
		h, pattern = NotFoundHandler(), &amp;#34;&amp;#34;
	}
	return
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;handler一开始就用读锁锁住了整个函数，说明在这个函数中会读取ServeMux中的handler注册的map。之前在了解ServeMux成员结构的时候说过，如果ServeMux开启了强制带域名匹配，那么它是第一优先级的，待匹配的path也要加上host。如果强制带域名匹配没有匹配到，那么就会进行其他正常的匹配，否则认为没有匹配到，返回有一个NotFoundHanlder。NotFoundHanlder在处理请求的时候也是向response写入相应的错误信息，返回给客户端。ServeMux的math方法将会遍历注册了pattern和handler的map，对pattern和path进行匹配。在匹配的时候如果发现注册map当中的pattern与path有多个匹配情况，那么将会选取pattern最长的那个作为最佳的匹配项，这一点在介绍ServeMux类型的时候也是说过的。&lt;/p&gt;

&lt;p&gt;其实讲到这里，一个请求从外部进来，到ServeMux,到handler，到ServeHttp，最终处理完成返回给客户端的一条线就已经是通的了。其中涉及到了一些细枝末节的东西，如path.Clean是如何清洗urlpath的，这些我们暂时都不做过多的了解。我们的重点要放在golang实现的http框架上面，了解它是如何进行运作的。&lt;/p&gt;

&lt;p&gt;之前我们是从http包中的Handle说起的，那么紧接着我们就来看看HandleFunc这个函数都做了什么以及与Handle方法有何异同。&lt;/p&gt;

&lt;h1 id=&#34;handlefunc&#34;&gt;HandleFunc&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;HandleFunc这个函数看起来和Handle没有什么区别，都是调用了DefaultServeMux的同名方法对pattern和处理与这个pattern匹配的请求的handler进行注册。只不过HandleFunc注册的handler并不是一个Handler类型的对象，而直接是一个函数，这个函数的原型和Handler类型中的ServeHttp方法是一样的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ServeMux的HandleFunc方法内部调用的还是Handle方法，只不过对我们传递进来的函数方法通过HandlerFunc转换成一个Handler的对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在golang中我们知道，函数也是一种值，这种值的类型我暂且就把它称作是一个函数类型吧。既然是类型，那么在golang中就可以实现这个类型相应的成员方法，HandlerFunc就是这样。ServeMux的Handle方法第二个参数就是接受了一个Handler对象，只要实现了ServeHttp方法，都可以赋值给它。HandlerFunc也实现了一个，只不过在内部调用了自己。感觉是golang利用Interface的特性玩了一个小把戏，为我们提供了额外的一种方式来对pattern和handler进行注册。&lt;/p&gt;

&lt;h1 id=&#34;listenandserve&#34;&gt;ListenAndServe&lt;/h1&gt;

&lt;p&gt;listenAndServe这个方法应该是处理一个http请求的流程中最重要的一个方法了。从函数名上我们就可以看出，这个函数起到了监听和提供服务的作用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ListenAndServe listens on the TCP network address addr
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// and then calls Serve with handler to handle requests
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// on incoming connections.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Accepted connections are configured to enable TCP keep-alives.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Handler is typically nil, in which case the DefaultServeMux is
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// used.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// A trivial example server is:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//	package main
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//	import (
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//		&amp;#34;io&amp;#34;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//		&amp;#34;net/http&amp;#34;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//		&amp;#34;log&amp;#34;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//	)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//	// hello world, the web server
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//	func HelloServer(w http.ResponseWriter, req *http.Request) {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//		io.WriteString(w, &amp;#34;hello, world!\n&amp;#34;)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//	}
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//	func main() {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//		http.HandleFunc(&amp;#34;/hello&amp;#34;, HelloServer)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//		log.Fatal(http.ListenAndServe(&amp;#34;:12345&amp;#34;, nil))
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//	}
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ListenAndServe always returns a non-nil error.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ListenAndServe通过监听一个tcp的网络地址来为通过某个tcp链接发来的请求提供服务。可以看到该函数的第二个参数就是一个Handler对象，ListenAndServe显然已经是golang服务框架中最外层的入口了，那么首先处理从外部进来请求的handler自然应该是ServeMux。当我们指定第二个参数为nil的时候，golang就会使用DefaultServeMux作为我们整个服务的路由handler。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
// If srv.Addr is blank, &amp;#34;:http&amp;#34; is used.
// ListenAndServe always returns a non-nil error.
func (srv *Server) ListenAndServe() error {
	addr := srv.Addr
	if addr == &amp;#34;&amp;#34; {
		addr = &amp;#34;:http&amp;#34;
	}
	ln, err := net.Listen(&amp;#34;tcp&amp;#34;, addr)
	if err != nil {
		return err
	}
	return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;http包中的ListenAndServe方法在其内部通过定义了一个server对象，调用server的ListenAndServe方法。这个Server看起来就是整个golang的http服务框架的核心类型。它的ListenAndServe方法监听了本机的addr端口并调用Serve方法来开启整个服务。前面我们讲到了一个请求到了ServeMux之后是如何被派发并且处理的，那么接下来，我们就来研究一下一个请求是如何从客户端到达ServeMux的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	
// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
//
// For HTTP/2 support, srv.TLSConfig should be initialized to the
// provided listener&amp;#39;s TLS Config before calling Serve. If
// srv.TLSConfig is non-nil and doesn&amp;#39;t include the string &amp;#34;h2&amp;#34; in
// Config.NextProtos, HTTP/2 support is not enabled.
//
// Serve always returns a non-nil error. After Shutdown or Close, the
// returned error is ErrServerClosed.
func (srv *Server) Serve(l net.Listener) error {
	defer l.Close()
	if fn := testHookServerServe; fn != nil {
		fn(srv, l)
	}
	var tempDelay time.Duration // how long to sleep on accept failure

	if err := srv.setupHTTP2_Serve(); err != nil {
		return err
	}

	srv.trackListener(l, true)
	defer srv.trackListener(l, false)

	baseCtx := context.Background() // base is always background, per Issue 16220
	ctx := context.WithValue(baseCtx, ServerContextKey, srv)
	ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())
	for {
		rw, e := l.Accept()
		if e != nil {
			select {
			case &amp;lt;-srv.getDoneChan():
				return ErrServerClosed
			default:
			}
			if ne, ok := e.(net.Error); ok &amp;amp;&amp;amp; ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay &amp;gt; max {
					tempDelay = max
				}
				srv.logf(&amp;#34;http: Accept error: %v; retrying in %v&amp;#34;, e, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return e
		}
		tempDelay = 0
		c := srv.newConn(rw)
		c.setState(c.rwc, StateNew) // before Serve can return
		go c.serve(ctx)
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;server对象调用了Serve方法之后，可以看到，在其实现中有一个死循环，不断的接受从外部而来的网络连接，为每一个网络连接都开启一个goroutine调用Conn类型对象的serve方法来处理这条连接上发来的http请求。Serve函数大体的逻辑就是这样，一些实现的细节我们暂时先不追究，但是有一点需要注意的是，server调用了newConn创建了一个Conn类型的对象，这个对象内其中一个成员就是我们的server对象，也就是说，再创建这个Conn对象的时候把server自己也传递了进去。&lt;/p&gt;

&lt;p&gt;了解了以上我们说的几点就可以继续向下研究了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;116
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;117
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;118
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;119
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;120
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;121
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;122
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;123
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;124
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;125
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;126
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;127
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;128
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;129
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;130
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;131
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;132
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;133
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;134
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;135
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;136
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;137
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;138
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;139
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;140
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;141
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;142
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (c *conn) serve(ctx context.Context) {
	c.remoteAddr = c.rwc.RemoteAddr().String()
	defer func() {
		if err := recover(); err != nil &amp;amp;&amp;amp; err != ErrAbortHandler {
			const size = 64 &amp;lt;&amp;lt; 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			c.server.logf(&amp;#34;http: panic serving %v: %v\n%s&amp;#34;, c.remoteAddr, err, buf)
		}
		if !c.hijacked() {
			c.close()
			c.setState(c.rwc, StateClosed)
		}
	}()

	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		if d := c.server.ReadTimeout; d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		}
		if d := c.server.WriteTimeout; d != 0 {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}
		if err := tlsConn.Handshake(); err != nil {
			c.server.logf(&amp;#34;http: TLS handshake error from %s: %v&amp;#34;, c.rwc.RemoteAddr(), err)
			return
		}
		c.tlsState = new(tls.ConnectionState)
		*c.tlsState = tlsConn.ConnectionState()
		if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
			if fn := c.server.TLSNextProto[proto]; fn != nil {
				h := initNPNRequest{tlsConn, serverHandler{c.server}}
				fn(c.server, tlsConn, h)
			}
			return
		}
	}

	// HTTP/1.x from here on.

	ctx, cancelCtx := context.WithCancel(ctx)
	c.cancelCtx = cancelCtx
	defer cancelCtx()

	c.r = &amp;amp;connReader{conn: c}
	c.bufr = newBufioReader(c.r)
	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&amp;lt;&amp;lt;10)

	for {
		w, err := c.readRequest(ctx)
		if c.r.remain != c.server.initialReadLimitSize() {
			// If we read any bytes off the wire, we&amp;#39;re active.
			c.setState(c.rwc, StateActive)
		}
		if err != nil {
			const errorHeaders = &amp;#34;\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n&amp;#34;

			if err == errTooLarge {
				// Their HTTP client may or may not be
				// able to read this if we&amp;#39;re
				// responding to them and hanging up
				// while they&amp;#39;re still writing their
				// request. Undefined behavior.
				const publicErr = &amp;#34;431 Request Header Fields Too Large&amp;#34;
				fmt.Fprintf(c.rwc, &amp;#34;HTTP/1.1 &amp;#34;+publicErr+errorHeaders+publicErr)
				c.closeWriteAndWait()
				return
			}
			if isCommonNetReadError(err) {
				return // don&amp;#39;t reply
			}

			publicErr := &amp;#34;400 Bad Request&amp;#34;
			if v, ok := err.(badRequestError); ok {
				publicErr = publicErr + &amp;#34;: &amp;#34; + string(v)
			}

			fmt.Fprintf(c.rwc, &amp;#34;HTTP/1.1 &amp;#34;+publicErr+errorHeaders+publicErr)
			return
		}

		// Expect 100 Continue support
		req := w.req
		if req.expectsContinue() {
			if req.ProtoAtLeast(1, 1) &amp;amp;&amp;amp; req.ContentLength != 0 {
				// Wrap the Body reader with one that replies on the connection
				req.Body = &amp;amp;expectContinueReader{readCloser: req.Body, resp: w}
			}
		} else if req.Header.get(&amp;#34;Expect&amp;#34;) != &amp;#34;&amp;#34; {
			w.sendExpectationFailed()
			return
		}

		c.curReq.Store(w)

		if requestBodyRemains(req.Body) {
			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)
		} else {
			if w.conn.bufr.Buffered() &amp;gt; 0 {
				w.conn.r.closeNotifyFromPipelinedRequest()
			}
			w.conn.r.startBackgroundRead()
		}

		// HTTP cannot have multiple simultaneous active requests.[*]
		// Until the server replies to this request, it can&amp;#39;t read another,
		// so we might as well run the handler in this goroutine.
		// [*] Not strictly true: HTTP pipelining. We could let them all process
		// in parallel even if their responses need to be serialized.
		// But we&amp;#39;re not going to implement HTTP pipelining because it
		// was never deployed in the wild and the answer is HTTP/2.
		serverHandler{c.server}.ServeHTTP(w, w.req)
		w.cancelCtx()
		if c.hijacked() {
			return
		}
		w.finishRequest()
		if !w.shouldReuseConnection() {
			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
				c.closeWriteAndWait()
			}
			return
		}
		c.setState(c.rwc, StateIdle)
		c.curReq.Store((*response)(nil))

		if !w.conn.server.doKeepAlives() {
			// We&amp;#39;re in shutdown mode. We might&amp;#39;ve replied
			// to the user without &amp;#34;Connection: close&amp;#34; and
			// they might think they can send another
			// request, but such is life with HTTP/1.1.
			return
		}

		if d := c.server.idleTimeout(); d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
			if _, err := c.bufr.Peek(4); err != nil {
				return
			}
		}
		c.rwc.SetReadDeadline(time.Time{})
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在conn对象的serve方法中，最引人注目的代码不过有两行，而这两行也是最核心的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;serve方法中开启了一个死循环，死循环中不断的调用readRequest(ctx)来处理从这条连接上发送过来的http请求。&lt;/li&gt;
&lt;li&gt;serverHandler{c.server}.ServeHTTP(w, w.req)，其次便是这一行代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们之前说过，conn对象在创建的时候是把server对象也包含进来的，而server对象中有一个Handler成员，它在我们定义这个server对象的时候被赋值为了nil，如果我们要使用server对象中的这个Handler成员的话，就会默认使用golang为我们预定义的DefaultServerMux对象，也就是我们所说的服务的http路由。在conn对象的serve方法内，通过readRequest来读取请求中的内容，然后调用DefaultServerMux对象的ServeHttp方法进行请求的派发处理。至此，一个http请求就是通过这样的方式从服务的外部传输到服务的内部，最后调用了DefaultServerMux的ServeHttp方法开始处理它。并且在处理完这个request之后我们还会检查是否server开启了keepalives的特性，如果开启了，那么就会保持这个闲置的链接一段时间直到请求到达在进行处理，如果没有开启这个特性那么此链接最终就会被关闭。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Learning for APUE(3)--从操作系统的角度来看文件共享</title>
      <link>http://littledriver.net/post/2017/04/04/learning-for-apue3-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</link>
      <pubDate>Tue, 04 Apr 2017 22:01:51 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/04/04/learning-for-apue3-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/IMG_0354.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;先谈文件i-o效率&#34;&gt;先谈文件I/O效率&lt;/h1&gt;

&lt;p&gt;在unix系统中读写文件会涉及到i/o操作，大家也都清楚i/o操作是非常消耗系统资源的。对于简单的读写文件来说，其i/o效率的变化是有一定规律可循的。apue第三章中提到了这样一个例子，从终端标准输入中读取数据，每次读取buffsize个字节，然后将读取到的数据写入到文件中，直到处理完标准输入中全部的数据。作者怀疑，我们选取的buffsize值可能会影响读写文件的i/o效率，所以控制buffsize大小这个变量，每次实验增加一倍的大小，直至处理完所有的数据。但是在做这个实验之前需要注意的是，进程在处理数据的时候会把它们加载到主存里，如果我们每一次实验读取的数据都是同样的，那么操作系统的缓存机制是不会将常用的数据置换出去的，它们会一直保存在内存中。这样一来，我们的测试结果就是不准确的。为了保证实验结果的准确性，每一次实验在改变buffsize大小的同时也要更换实验demo读写的文件内容。&lt;/p&gt;

&lt;p&gt;实现demo代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#include &amp;#34;apue.h&amp;#34;
#include &amp;#34;apueerror.h&amp;#34;

#define BUFFSIZE 4096

int main() {
    int n;
    char buff [BUFFSIZE];
    while((n = read(STDIN_FILENO, buff, BUFFSIZE))&amp;gt; 0) {
	if (write(STDOUT_FILENO, buff, n) != n) {
	    err_sys(&amp;#34;write file fail&amp;#34;);
	}
    }

    if (n &amp;lt; 0){
	err_sys(&amp;#34;read file fail&amp;#34;);
    }

    return 0;
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;实验结果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/WX20170404-235411@2x.png&#34; alt=&#34;&#34; /&gt;
这张表是非常有意思的，仔细看看就能发现一些特别的规律。首先看第一列，随着buffsize的增加，用户cpu的时间逐渐减小，猜测是因为buffsize一开始选取的太小，导致需要多次的进行i/o操作。但是到了buffsize为4096个字节之后，用户cpu的时间再没有明显的变化了。由于该表是在linux ext4文件系统上测试的结果，我们自然就可以得知，ext4文件系统一个磁盘块的长度是4kb，也就是4096个字节，由于从4096个字节之后，buffsize的大小是翻倍的，也就是我们每次都读写整个一个磁盘块长度的数据，这样的消耗自然要比之前的小且稳定。&lt;/p&gt;

&lt;p&gt;再看buffsize为32字节的时候对应的clocktime为8.82秒，但是随着buffsize的增加，时钟时间也不在有明显的变化。这是因为大多数文件系统都采用了一种叫做就近预读的技术。当系统检测到某个进程正在以一定的顺序进行读取的时候，系统将会试图读入比进程要求更多字节的数据进内存，以备使用。操作系统之所以会有这样的行为，是因为它假定了该进程会很快使用它预读到内存的数据。&lt;/p&gt;

&lt;h1 id=&#34;文件共享&#34;&gt;文件共享&lt;/h1&gt;

&lt;p&gt;不同进程间的文件共享也是进程间通讯的一种体现。在之前的开发生涯中，我对共享，和进程间通讯的了解仅仅止步于锁的使用以及如何避免死锁等问题的层面上。apue的3.10一节，让我从操作系统+数据结构的角度窥视了系统实现文件共享的原理，着实让我看的大呼过瘾。&lt;/p&gt;

&lt;p&gt;操作系统内核为一个打开的文件维护了三种数据结构：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程表项： 在操作系统中，维护着一张进程表。每一个进程在这个表里都有一个进程表项，里面保存了和该进程相关所有的信息。和我们本次讲述的主题有关的信息是文件描述符表，这张表里记录了进程操作的文件描述符标志以及文件指针等信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件表项：进程的文件描述符表中的每一项都有一个文件指针，这个指针指向了一个名为文件表项的数据结构。文件表项存在于内核维护的一张文件表中。它和进程表对系统的含义是一样的。每一个文件表项中都包括文件的状态标识（读， 写，追加等），文件当前的偏移量以及一个v节点的指针。这里需要提到的是，既然文件表和进程表都是属于内核维护的唯一的一份关于进程和文件的信息，那么也就说明，同一个进程或同一个文件在进程表和文件表中都只有唯一的一项，不会重复。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;v-node节点：在使用linux系统的时候，我了解过i-node这个节点的概念，它是系统中一个文件的索引节点，里面存在文件的所有者等相关信息，其中最重要的当属一个指向文件实际数据块存放磁盘位置的指针。文件的实际数据在磁盘中是存储于每个磁盘块中的，多个磁盘块根据链表的形式链接起来。想要找到文件存在磁盘上的实际数据，就得首先找到其i-node节点。这里的v-node节点让我感觉到了像是数据结构当中的一个链表头一样，里面存了一些与文件相关的信息，更重要的是一个指向该文件i-node节点的指针。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过上面的描述，我们可以很自然的画出这三种数据结构的相互关系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/fuck3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当两个不同的进程打开同一个文件的时候，进程表项，文件表项，v-node节点的关系如上图所示。在这张图中，我们更加印证了：每一个进程有一个唯一的进程表项，进程打开一个文件有一个与其关联的文件表项，但是如果两个进程最终打开的文件都是一个，他们将都指向一个vnode节点。仔细想想为什么不是一个进程一个vnode节点呢？为什么不同进程打开同一个文件需要不同的文件表项呢？&lt;/p&gt;

&lt;p&gt;第一个问题，按照之前的理解vnode节点只是去取文件落在磁盘上真实数据的一个引路人，其内部数据结构保存的信息基本是不会变的，所以并不需要每一个进程都要有一份，&lt;/p&gt;

&lt;p&gt;第二个问题，多个进程打开同一个文件，就单以读这个操作来讲，两个进程不可能以同样的速度读取。因为在读取的过程中会改变当前文件的偏移量，而这个偏移量又仅对当前这个进程有效，所以要每个进程维护一份文件表项，其内部数据会跟随进程的操作而变化。这也就解释了，我们之前说的多进程同时操作一个很大的文件的时候，互相之间可以从文件中不同的位置开始处理但是却不会受到它人的影响的现象。&lt;/p&gt;

&lt;p&gt;像write这种会对文件有改变的操作，在写入数据的时候，文件表项当中的文件当前偏移量也会随之增加，当写入的数据长度超过了该操作之前的文件长度，系统会将文件表项中的文件当前偏移量写入到文件的inode节点中。如果我们是以追加的形式打开文件进行写入的时候，在写入之前，系统会将该文件inode节点中保存的文件长度加载到文件表项中文件当前偏移量上。lseek函数就更不用说了，他会直接更改一个文件表项中的文件当前偏移量，但是不会引起任何i/o操作。&lt;/p&gt;

&lt;p&gt;系统设计了上面这三种数据结构，从根本上保证了多进程共享一个文件内容的时候不会互相影响，但这里提到的共享仅仅是读取。对共享文件的写入将有更复杂的机制来保证。&lt;/p&gt;

&lt;h1 id=&#34;原子操作&#34;&gt;原子操作&lt;/h1&gt;

&lt;p&gt;在之前的系统实现里还没有以追加的模式打开一个文件的时候，如果想从文件的尾部开始写入数据需要先调用lseek，然后再调用write。表面上看这应该是一个操作，但是实际上却调用了两个函数。如果在lseek执行了之后，该进程被挂起。此时另外一个进程也要以追加的方式写入一同一个文件的时候，由于不同的进程对同一个文件有不同的文件表项，它们之中的文件当前偏移量又没有同步，那么一开始被挂起的进程重新执行的时候，很可能就会覆盖掉另外一个进程刚刚写入的内容。&lt;/p&gt;

&lt;p&gt;为了解决上面所说的关于文件写入的问题，有两点是我们必须要考虑的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在写入之前我们拿到的文件当前偏移量必须是和文件长度相等的。&lt;/li&gt;
&lt;li&gt;移动到文件尾部和写入文件必须作为一个原子操作来进行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原子操作，顾名思义就是一个逻辑上不可分割的操作。要么全都执行完，要么就彻底不执行。针对第二点，我们可以将移动文件偏移量和写入包装在一个函数内来解决。至于第一点，我们就必须在每次写入前先到文件的inode节点中读取出文件当前的长度来作为文件的当前偏移量。&lt;/p&gt;

&lt;p&gt;lseek和以追加模式打开文件虽然都可以实现将文件的当前偏移量移动到文件的尾部，但是lseek仅仅是改变了文件表项当中的文件偏移量，并且它的效果是一次性的，且和老版的open函数配合起来没办法完成一个原子的操作。但是有了追加模式的open函数，不但实现了原子操作，并且能够满足一次打开文件，之后只要不关闭重新打开，对该文件的写入都是从文件尾部开始，不需要再调用lseek函数。另外，当我们以追加的方式打开文件之后，如果再想用lseek把文件偏移量移动到文件的其他位置之后写入数据的话是不可行的，数据仍然写入到了文件的尾部。&lt;/p&gt;

&lt;p&gt;对于open函数的追加模式，文档中有如下描述:&lt;/p&gt;

&lt;p&gt;The file is opened in append mode. Before each write(2), the file offset is positioned at the end of the file, as if with lseek(2).&lt;/p&gt;

&lt;p&gt;也就是说当你以追加的方式打开一个文件的话，以后对此文件任何写的操作都会强制的从文件尾部开始写。根据之前所讲的三种数据结构，我推测，以追加方式打开文件之后，每次write操作都会强制将文件inode节点中的文件长度赋值给文件表项中的文件当前偏移量。而lseek只会改动文件表项中的当前文件偏移量是没有用的。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Learning Process In Modern Operating System (1)</title>
      <link>http://littledriver.net/post/2017/03/29/learning-process-in-modern-operating-system-1/</link>
      <pubDate>Wed, 29 Mar 2017 22:59:50 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/03/29/learning-process-in-modern-operating-system-1/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%9B%E7%A8%8B%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5&#34;&gt;为什么会有进程这个概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A8%A1%E5%9E%8B&#34;&gt;进程的模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B&#34;&gt;创建进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B&#34;&gt;终止进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84&#34;&gt;进程的层次结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81&#34;&gt;进程的三种状态&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E5%8F%AA%E6%9C%89%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2&#34;&gt;为什么三种状态之间只有四种转换&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt;

&lt;blockquote&gt;
&lt;p&gt;我学习操作系统，向来不喜欢死记硬背，无论是当初上大学的时候，还是现在为了夯实基础重新开始学习。我一直觉得操作系统是计算机中最有魅力的一个方向，并且坚信，现代操作系统的原型有如今这样一番样貌都是通过一点一点的改进而形成的。所以，在学习操作系统的时候，我更喜欢经常反问自己，比如为什么需要进程这个概念？为什么需要lru算法，其他的算法有什么优劣。我相信，只有你真正把一个现象想通了，并且知道了他的来龙去脉，才能最终在你的脑海里帮你形成一张操作系统的网络。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;为什么会有进程这个概念&#34;&gt;为什么会有进程这个概念&lt;/h1&gt;

&lt;p&gt;当一台服务器同时接到很多网络请求的时候，如果现在让你设计这台服务器的操作系统处理请求的逻辑，你想怎么办呢？是想让这些请求都排着队一个接一个的处理，还是说以阳光普照的形式，给每一个请求都一个执行的的机会，即使某个请求在某次机会上并没有被完全处理。稍加思考就可以知道，以请求的发起者来考虑，肯定不想自己的请求排在后面，并且一旦位置靠前请求包含了些昂贵的操作，如i/o等，那么排在队尾耗时较少的请求很可能就会等待非常多的时间。这显然是不合理的。&lt;/p&gt;

&lt;p&gt;为了照顾每一个到来的请求，我们必须要想出一个办法来管理这些请求的执行，切换，以及关闭。进程的概念由此提出。
在操作系统中，进程定义是一个正在运行的程序。如果接着上面的例子来讲的话，一个请求可能就会启动一个进程来进行处理，那么多个进程执行的时候就需要对进程进行切换，挂起，保存上下文等操作。就单核的计算机来讲，某一瞬间只有一个进程在执行，但是一秒之内却有很多进程在执行，这就给使用者造成了一种错觉，计算机在并行的执行我们的请求。其实上面说的通过进程间切换的方式达到的仅仅是一种伪并行的效果，严格来讲应该叫做并发。只有在硬件层面多出几个cpu的时候，才是真正意义上的并行。&lt;/p&gt;

&lt;p&gt;进程的概念以及它的数据结构，都为操作系统对进行的操作和管理提供了极大的便利。&lt;/p&gt;

&lt;h1 id=&#34;进程的模型&#34;&gt;进程的模型&lt;/h1&gt;

&lt;p&gt;一个进程通常包括以下几部分：数据，程序，进程相关的信息。在一个多道程序的操作系统中，会在不同的进程间进行切换，每一个进程所获得执行时间可能是不同的，并且在某一个时间点也并不能确定是哪个进程在运行。进程和程序将比较起来，按我的理解，两者主要的区别就是：进程是动态的但是程序是静态的，进程不单单需要程序，还需要处理一定的数据甚至有的进程还会最终输出一些数据。cpu通过一定的调度算法去管理系统中众多进程的运行和挂起。如果同一份程序运行了两个，那么内存中将会有两个进程的信息，但是他们共享的程序代码在内存中仅有一份。&lt;/p&gt;

&lt;h1 id=&#34;创建进程&#34;&gt;创建进程&lt;/h1&gt;

&lt;p&gt;其实在我对操作系统的了解当中，无论是用户自己主动创建的，还是操作系统创建的，亦或是操作系统本身，我觉得他们都是属于进程的。为什么会这么想呢？很简单，因为进程是正在运行的一段程序，有了这个概念你就知道，无论是什么软件还是操作系统本身都是一段在内存当中运行的程序。要创建一个进程的方式有很多种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用户自己主动创建，如用户点击一个软件的图标&lt;/li&gt;
&lt;li&gt;系统初始化，操作系统在初始化的时候为了能让我们正常的使用它，肯定会启动一系列的进程&lt;/li&gt;
&lt;li&gt;正在执行的进程创建它们的子进程&lt;/li&gt;
&lt;li&gt;批处理作业的初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;系统在初始化的时候会启动很多进程，这些进程有运行在“前台”的，也有运行在“后台”的。在前台的进程负责和用户进行交互，后台的进程和用户无关，但是却在后台提供着相应的服务。这类没有父进程的进程被称作是守护进程，他们一直驻留在后台，等待提供服务。&lt;/p&gt;

&lt;p&gt;通过上面所讲的集中进程的创建方式来看，一个独立的进程通常都是被一个正在运行当中的进程通过调用一个系统调用所创建而来的（至于我刚才说的守护进程是没有父进程的，这是比较特殊的一种情况，它和unix操作系统当中的进程层级有关，涉及到一种特殊的行为叫“脱壳”），unix系统中与创建进程唯一相关的一个系统调用就是fork。&lt;/p&gt;

&lt;p&gt;在一个进程调用了fork创建一个新的进程的时候，操作系统会创建一个有着与其父进程同样副本的新进程。在刚刚创建完成的时候，子进程和其父进程的内存空间里的内容是一样的，是直接copy了父进程内存空间中所有的数据。但是父进程和子进程的地址空间是不一样的，也就是说，两个进程在内存当中有着不同的位置，占用了两份空间。如果你确实有认真思考fork函数的行为就知道，到此为止fork只是创建了一个子进程而已，但是子进程的内存空间中存的还是父进程相关的数据以及代码，我们只有紧接着通过指定一些参数来调用execve函数，将一个新的程序load到子进程的内存空间中运行，此时才算做是真正的启动了一个新的进程。如shell一般就是先创建一个子进程，然后把我们指定的程序load到刚刚创建的进程的内存空间中进行执行。unix之所以将创建一个新进程的操作设计成两段，就是因为在执行完fork函数之后，子进程有时间调整自己对一些文件描述符的控制以及对标准输出，输入，错误等重定向的问题。这和window平台略有不同，window中都是通过调用一个CreateProcess函数一部到位完成所有的操作，因为该函数所接受的参数也是较多的。&lt;/p&gt;

&lt;h1 id=&#34;终止进程&#34;&gt;终止进程&lt;/h1&gt;

&lt;p&gt;进程被终止的几种场景其实也很容易想到。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;程序正常执行完毕&lt;/li&gt;
&lt;li&gt;遇到错误了，但是命中了程序正常的错误处理逻辑&lt;/li&gt;
&lt;li&gt;严重的错误，无法执行下去&lt;/li&gt;
&lt;li&gt;被其他进程干掉&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中前两种场景没什么好说的，都是我们预料之中的。第三种是因为一些比较严重的错误，如除数为0等，无法继续执行下去。此时正常情况来讲是应该马上终止这个进程的执行，但是在一些操作系统中允许进程自己捕获一些因某些错误系统发送的中断信号，从而按照自己的意愿来处理这个错误。&lt;/p&gt;

&lt;h1 id=&#34;进程的层次结构&#34;&gt;进程的层次结构&lt;/h1&gt;

&lt;p&gt;操作系统在启动的时候，必定是有一个进程来负责一些初始化工作的，然后以此创建更多的与系统相关的进程，直到系统启动完成。这个负责初始化的进程叫做init。也就是说，一个unix系统当中所有的进程都是以Init这个初始化的进程为起点创建出来的。系统中所有的进程结构类似于unix目录，是一个树形结构，根节点就是init进程。一棵树有层级之分，那么unix系统中的进程也是有层级之分的，进程之间的层级主要体现在父进程和子进程上面，一个进程只有一个父进程，但是可以有很多子进程。能操作这个进程本身的只有他的父进程。window则不同，虽然它也有父子进程的概念，但是因为父进程掌握了子进程句柄，并且可以把它传递给其他进程来操作其创建的子进程，这样一来就没有严格的进程层级关系了。&lt;/p&gt;

&lt;p&gt;这里还要提到的，就是我们之前说过的守护进程。守护进程是一系列没有正在运行父进程的进程的集合，它们的进程层级仅位于init进程之下。之所以说守护进程没有正在运行的父进程，是因为守护进程在被其父进程创建并且开始运行之后终止了其父进程，这种行为就叫做“脱壳”。但是这种kill掉自己父进程但是自己还完好无损的行为在一些系统上是不可行的，因为有的系统一旦父进程被干掉，随之他所有的子线程也都会被干掉。&lt;/p&gt;

&lt;h1 id=&#34;进程的三种状态&#34;&gt;进程的三种状态&lt;/h1&gt;

&lt;p&gt;本科上操作系统课程的时候，学过进程的三态图，它标识了进程在操作系统中的三种状态：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;阻塞态&lt;/li&gt;
&lt;li&gt;运行态&lt;/li&gt;
&lt;li&gt;就绪态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/3e8c3c10f2e57f7838db744d8560aac8.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中就绪态和运行态之间的转换是由操作系统的进程调度程序来完成的。系统为了对所有的进程一视同仁，都给了他们一定的运行时间。所以，某一个进程不能一直占用着cpu时间，进程调度程序可以决定下一时刻哪个进程可以运行，运行多长时间，哪个进程这一轮的cpu时间已经消耗完毕要转入就绪态。相反，就绪态中的进程也会按照顺序一个一个的去享受属于他们的cpu时间执行相应的操作。&lt;/p&gt;

&lt;p&gt;一个进程如果在运行的过程当中需要依赖一些其他程序的运行结果或者说一些外部事件发生才能够继续向下执行的时候，进程就进入了阻塞态。如果其等待条件一直没有满足，那么是有可能饥饿或者饿死的。一旦条件满足，进程就马上会进入就绪态，等待系统给他分配cpu运行时间执行相应的操作。&lt;/p&gt;

&lt;p&gt;从进程模型的角度来考虑，在某一时刻内，系统中肯定有一个正在运行的进程，以及一些和系统相关的进程。如磁盘进程，终端进程等。和系统相关的进程此时应该都处于阻塞状态，当用户或者正在运行当中的进程出发了一些条件，就可能会唤醒阻塞的进程。操作系统中对于进程的运行，终止以及中断等操作的逻辑都在进程调度的程序当中，可以理解为进程调度这个程序是在底层的，其上层就是因为各种原因创建的普通进程，进程调度根据系统的信号管理着上面的普通进程。&lt;/p&gt;

&lt;h2 id=&#34;为什么三种状态之间只有四种转换&#34;&gt;为什么三种状态之间只有四种转换&lt;/h2&gt;

&lt;p&gt;按理来说，三个状态之间应该有6种转换才对。实际上，阻塞态和运行态是可以相互转化的，在cpu空闲的时候，如果一个刚刚被阻塞的进程所需的运行条件很快被满足，那么该进程是可以从阻塞态直接进入运行态的。但是就绪态是不可能像阻塞态进行转化的。因为处于就绪态的进程，首先是没有可用的cpu时间，其次阻塞态明显是一个运行的进程因为某些条件不满足而进入的下一个状态，处于就绪态的进程不可能做出任何的事情的，只有运行的进程才能被阻塞。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Learning for APUE(2)--文件 I/O</title>
      <link>http://littledriver.net/post/2017/03/19/learning-for-apue2-%E6%96%87%E4%BB%B6-i-o/</link>
      <pubDate>Sun, 19 Mar 2017 17:01:23 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/03/19/learning-for-apue2-%E6%96%87%E4%BB%B6-i-o/</guid>
      
        <description>&lt;h1 id=&#34;文件描述符&#34;&gt;文件描述符&lt;/h1&gt;

&lt;p&gt;对于内核而言，任何对文件的操作都需要文件描述符，因为这个文件描述符唯一标识了这个文件。文件描述符的有效性是针对某一个进程的，内核对不同的进程维护着不同的文件描述符。&lt;/p&gt;

&lt;h1 id=&#34;open函数&#34;&gt;open函数&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	 int
     open(const char *path, int oflag, ...);
     
     int
     openat(int fd, const char *path, int oflag, ...);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;open函数的作用是按照用户指定的模式去打开一个文件。在模式的选择上，unix系统采用了一系列具有特定意义的常量参数进行或运算的结果来表示。还有一个和open函数相似的函数我们也应该知道，它就是openat。openat和open函数唯一的区别，就是在path参数的指定上。如果传给两个函数的path参数是绝对路径的话，openat和open两个函数的行为是一样的。但是如果path参数表示的文件名是一个相对路径名的话，openat函数与open函数相比较多出来的一个参数fd可以指出我们传递的相对路径名在文件系统中的起始地址，fd一般来说可以根据打开相对路径名所在的目录获取。openat函数中的fd参数有一个特殊值AT_FDCWD，它表示path存储的相对路径名的起始地址是当前目录，当指定了这个参数的时候，其行为和open函数是一致的。&lt;/p&gt;

&lt;h1 id=&#34;create函数&#34;&gt;create函数&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	 int
     creat(const char *path, mode_t mode);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;create函数用来创建一个新文件。在一些老版本的系统中，由于当时open函数还没有打开一个不存在的文件则创建的功能，想要使用一个新的文件，得先调用create，然后close，最后在通过open打开这个文件获得其文件描述符进行操作。现在新的版本中，只要在open函数的oflag字段指定一个O_CREAT常量即可。&lt;/p&gt;

&lt;h1 id=&#34;close函数&#34;&gt;close函数&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	 int
     close(int fildes);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;close函数接收一个文件描述符的参数，然后将这个文件关闭。需要注意的是，当一个进程结束的时候，内核会自动关闭这个进程打开的所有文件。&lt;/p&gt;

&lt;h1 id=&#34;lseek函数&#34;&gt;lseek函数&lt;/h1&gt;

&lt;p&gt;每一个打开的文件都有一个叫做当前文件偏移量的东西，它类似指针一样，标识了文件当中的某个位置。文件偏移量以从文件开始处到其所在位置的字节数来表明它所指向的文件的位置。对文件的读，写等操作都是从该文件的文件偏移量指向的位置开始的。如果我们不是以追加的模式打开某一个文件，一般来说，文件偏移量在文件打开的时候都会被赋值为0。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	 off_t
     lseek(int fildes, off_t offset, int whence);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;函数接收三个参数，第一个参数是将要操作的文件描述符，第二个参数是将要设置的文件偏移量的值，第三个参数最为重要，表明了我们应该怎样解释offset的值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SEEK_SET: 此时offset被解释为设置文件的偏移量为从文件的起始处加上offset个字节的位置&lt;/li&gt;
&lt;li&gt;SEEK_CUR: 设置该文件的偏移量为其当前值加上offset个字节&lt;/li&gt;
&lt;li&gt;SEEK_END: 设置该文件的偏移量为文件的长度加上offset个字节&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数的第一个参数代表了一个文件描述符，但是并不是所有的文件描述符指向的对象都可以通过lseek设置文件偏移量，如管道和网络套接字在调用lseek的时候就会报错。使用lseek函数的时候要注意，其返回的值代表了设置后的文件偏移量，但是文件偏移量有可能是负值，所以，在检测lseek是否调用成功的时候，只需要校测其返回值是否为-1即可。&lt;/p&gt;

&lt;h3 id=&#34;seek-end&#34;&gt;SEEK_END&lt;/h3&gt;

&lt;p&gt;上面提到的whence参数的三个预设值，SEEK_END值得仔细研究一下，为什么一个文件的偏移量可以设置为比其文件长度还大的值呢。其实按我自己的理解，文件偏移量就是一个用字节数来表示其当前位置的一个指针而已，它决定了下一次对文件的读或者写的操作从何处开始。那么这个偏移量完全就可以指向任何位置，一旦使用SEEK_END,那么就代表，lseek返回的文件偏移量是从文件当前的长度开始，向后移动offset个字节的位置。&lt;/p&gt;

&lt;p&gt;很容易想象出来，这样的一次lseek函数的调用，在当前文件偏移量的位置和原文件长度的位置之间留出了一块空地，而至于这块空地占不占用实际的磁盘存储区，要看文件系统的具体实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;char buf1[] = &amp;#34;1234567890&amp;#34;;
char buf2[] = &amp;#34;0987654321&amp;#34;;

int main(void)
{
    int f = 0;
    if ((f = open(&amp;#34;lseek.txt&amp;#34;, O_RDWR | O_CREAT | O_TRUNC)) &amp;lt; 0)
    {
        err_sys(&amp;#34;open file error&amp;#34;);
    }

    if (write(f, buf1, strlen(buf1)) != strlen(buf1))
    {
        err_sys(&amp;#34;write file error&amp;#34;);
    }

    if (lseek(f, 2333, SEEK_END) == -1)
    {
        err_sys(&amp;#34;lseek error&amp;#34;);
    }

    if (write(f, buf2, strlen(buf2)) != strlen(buf2))
    {
        err_sys(&amp;#34;write file error&amp;#34;);
    }
	
    exit(0);
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过上面的demo，我们实际使用了lseek函数。执行完该程序之后，我们可以在终端中看到lseek.txt文件的情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;👉  ls -l
total 112
-rwxr-xr-x  1 xuran  staff  13692  3 19 21:58 a.out
-rw-r--r--  1 xuran  staff   4642  8 14  2016 apue.h
-rw-r--r--@ 1 xuran  staff   2021  8 14  2016 apueerror.h
-rw-r--r--  1 xuran  staff    926  3 19 01:30 control.c
-rw-r--r--@ 1 xuran  staff   1969  8 14  2016 errorlog.c
-rw-r--r--  1 xuran  staff    352  3 18 18:17 input.c
-rw-r--r--@ 1 xuran  staff    575  3 19 21:58 lseek.c
-r-xr-x---  1 xuran  staff   2353  3 19 21:58 lseek.txt
-rw-r--r--  1 xuran  staff   2197  3 19 00:14 tags
-rw-r--r--  1 xuran  staff    143  3 19 10:08 test.c&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;lseek.txt文件现在的大小是2353B，对应上面程序可以看出，首先我们向该文件写入了10个字节，然后将当前文件的偏移量从文件的末尾开始移动了2333个字节，此时文件的偏移量应该在2343字节处。最后又向文件写入了10个字节的数据，才导致了lseek.txt文件现在的长度是2353个字节。&lt;/p&gt;

&lt;p&gt;一般来说，unix系统中不会为移动文件偏移量造成的空地分配存储空间，但是我在mac os上面跑了如下demo，发现是会分配存储空间的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#include &amp;#34;apue.h&amp;#34;
#include &amp;#34;apueerror.h&amp;#34;
#include &amp;lt;fcntl.h&amp;gt;

char buf1[] = &amp;#34;1234567890&amp;#34;;
char buf2[] = &amp;#34;0987654321&amp;#34;;

int main(void)
{
    int f = 0;
    if ((f = open(&amp;#34;lseek.txt&amp;#34;, O_RDWR | O_CREAT | O_TRUNC)) &amp;lt; 0)
    {
        err_sys(&amp;#34;open file error&amp;#34;);
    }

    if (write(f, buf1, strlen(buf1)) != strlen(buf1))
    {
        err_sys(&amp;#34;write file error&amp;#34;);
    }

    if (lseek(f, 1600, SEEK_END) == -1)
    {
        err_sys(&amp;#34;lseek error&amp;#34;);
    }

    if (write(f, buf2, strlen(buf2)) != strlen(buf2))
    {
        err_sys(&amp;#34;write file error&amp;#34;);
    }

    int f2 = 0;
    if ((f2 = open(&amp;#34;ff&amp;#34;, O_RDWR | O_CREAT | O_TRUNC)) &amp;lt; 0)
    {
        err_sys(&amp;#34;open file error&amp;#34;);
    }

    for (int i = 1; i &amp;lt;= 1620; i++)
    {
        if (write(f2, &amp;#34;w&amp;#34;, 1) != 1)
        {
            err_sys(&amp;#34;write file error&amp;#34;);
        }
    }

    if (lseek(f, 1000, SEEK_SET) == -1)
    {
        err_sys(&amp;#34;lseek error&amp;#34;);
    }

    if (write(f, buf1, strlen(buf1)) != strlen(buf1))
    {
        err_sys(&amp;#34;write file error&amp;#34;);
    }

    close(f);
    close(f2);
    exit(0);
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;终端显示文件信息如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;👉  ls -sl ff lseek.txt
8 -r-xr-x---  1 xuran  staff  1620  3 19 22:44 ff
8 -r-xr-x---  1 xuran  staff  1620  3 19 22:44 lseek.txt&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看出ff和lseek.txt两个文件占用的磁盘块数量是相同的。这和apue书中写的demo结果是不一样的，我觉得是和文件系统具体的实现有关。或许在mac os的系统上，移动当前文件偏移量也是会占用磁盘空间的。后来，我再次写demo验证，向ff写入一个字节，发现两者占用的磁盘块数量也是一样的，这就让我不得不怀疑，上面ls出现的结果和最小磁盘分配空间是有关联的。于是我加大文件偏移量的数值为1000000，在mac系统上面仍然是同样的结果。&lt;/p&gt;

&lt;p&gt;So，我马上找来一台装了ubuntu的机器来进行实验。再次执行上面的demo，终于发现了空洞文件不占用磁盘空间的情况.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;mac下
ls -ls ff lseek.txt
1960 ------x---  1 xuran  staff  1000020  3 19 23:07 ff
1960 -r-xr-x---  1 xuran  staff  1000020  3 19 23:07 lseek.txt

ubuntu下
ls -ls lseek.txt ff
980 --w---x--x 1 xuran xuran 1000020 Mar 19 23:09 ff
  8 -r----x--- 1 xuran xuran 1000020 Mar 19 23:09 lseek.txt&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Bingo，看来确实是因为文件系统的实现不同导致结果不同。ubuntu系统中的文件系统，并没有对文件中的空洞部分分配磁盘空间而只分配了前面10个字节和后面10个字节的空间。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以下内容来自网上摘录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;空洞文件作用其实很大，例如迅雷下载文件，在未下载完成时就已经占据了全部文件大小的空间，这时候就是空洞文件。下载时如果没有空洞文件，多线程下载时文件就都只能从一个地方写入，这就不是多线程了。如果有了空洞文件，可以从不同的地址写入，就完成了多线程的优势任务。&lt;/p&gt;

&lt;p&gt;不同命令对文件空洞的处理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ls下的数据大小是统计文件空洞的。&lt;/li&gt;
&lt;li&gt;vim下可以看到^@^@^@^@^@^@^@，之后才是我们写入的ASCII数据。&lt;/li&gt;
&lt;li&gt;cat自动跳过文件空洞，只显示正常的数据。&lt;/li&gt;
&lt;li&gt;od下可以看到，文件空洞部分数据都是0x00。&lt;/li&gt;
&lt;li&gt;cp复制文件时也会复制相同的文件空洞。&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>Learning for APUE(1)</title>
      <link>http://littledriver.net/post/2017/03/19/learning-for-apue1/</link>
      <pubDate>Sun, 19 Mar 2017 12:11:38 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/03/19/learning-for-apue1/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;说来惭愧，像apue这种书籍被我买了一直放在书架里，仔细想想大学四年做的唯一一件错事就是没用大量的空闲时间去多读书。从集训队出来之后，一直被找工作困扰，失去了自己学习的节奏，现在看来是非常得不偿失的。俗话说，出来混总是要还的。在你想做一些技术含量更好的工作的时候，而不是仅仅的谢谢if-else，像apue书中所讲的一些基础知识是怎么也绕不开的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;文件和目录&#34;&gt;文件和目录&lt;/h1&gt;

&lt;p&gt;unix文件系统中，目录和文件的结构是树形的，起点是根目录 “/”。unix中目录其实也是一个文件，这个文件记录了此目录下每一个目录项的详细信息，如文件大小，文件权限，文件的最后修改时间等等。系统在创建一个目录的时候，会自动的创建两个目录项，“.”和“..”，前者表示当前目录，后者表示其父目录。在根目录中，这两者的意义自然是相同的。&lt;/p&gt;

&lt;p&gt;在系统中，我们通过文件路径来定位一个文件。文件路径分为相对路径和绝对路径。绝对路径以根目录为起点，但是相对路径是以当前目录为起点，所以，相对路径是相对当前目录的文件路径。&lt;/p&gt;

&lt;h1 id=&#34;输入和输出&#34;&gt;输入和输出&lt;/h1&gt;

&lt;p&gt;在unix系统中如果我们对一个文件进行操作的话，自然需要知道如何才能找到这个文件。当一个进程在运行的时候，系统实际上会为他们打开三个文件，分别是标准输入，标准输入和标准错误。被进程访问的文件在进程内部通常会得到这个文件的文件描述符，文件描述符是一个非负整数，是内核用来标识一个被进程访问的文件。进程中在对该文件进行操作的时候，都可以使用这个文件描述符。&lt;/p&gt;

&lt;p&gt;默认情况下，上面三种默认打开的文件描述符都指向终端，但是我们可以通过重定向的命令，将这几个文件描述符重定向到某个文件，这样一来，一些流入标准输出，标准错误的信息，以及要从标准输入读入的信息，他们的来源均从终端变成了某个特定的文件。&lt;/p&gt;

&lt;h1 id=&#34;程序和进程&#34;&gt;程序和进程&lt;/h1&gt;

&lt;p&gt;每一个进程在执行的时候，内核都会分配给它一个唯一的id来标识它。在unix系统中他被存在一个pid_t类型的变量里。跟进程密切相关的函数有三个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fork&lt;/li&gt;
&lt;li&gt;waitpid&lt;/li&gt;
&lt;li&gt;exec&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fork是一个大家耳熟能详的函数，它可以在一个进程中创建一个该进程的子进程。调用一次fork函数通常会返回两次，它对父进程返回子进程的pid，对子进程返回0。fork的时候，子进程将会复制父进程的内存状态，这样一来子进程的运行起点就从调用fork函数的位置开始，而不是从整个程序的起始部分开始。&lt;/p&gt;

&lt;p&gt;exec函数将根据接受的参数，执行一个新的程序文件用于替换旧的。&lt;/p&gt;

&lt;p&gt;waitpid函数将会根据接受的参数，等待某个特定进程执行结束。&lt;/p&gt;

&lt;p&gt;一个进程通常只是提供了其内部运行的一些资源，真正执行计算的是进程内的线程。线程和进程的内存模型相似，一个进程内的所有线程都共享一块进程的内存，线程也有id，但是这个id只在其对应的进程中有用。&lt;/p&gt;

&lt;h1 id=&#34;出错处理&#34;&gt;出错处理&lt;/h1&gt;

&lt;p&gt;unix系统函数通常在调用出错的时候，都会返回一个负值。如open函数，在成功的时候会返回一个文件描述符，但是在失败的时候就会返回一个-1。由于错误的种类不同，所以在调用函数失败的时候，返回的errno值也会不一样。&lt;errno.h&gt;这个头文件中包含了函数返回errno值的预定义值。另外还有一些函数可以将这个errno值映射为文字的错误信息，如strerror。&lt;/p&gt;

&lt;h1 id=&#34;信号&#34;&gt;信号&lt;/h1&gt;

&lt;p&gt;信号通常用于通知一个进程。比如一个进程如果执行了除数为0的除法的时候，系统就会发送SIGFPE信号给进程，如果该进程没有对此信号进行特别的处理，那么就会采用默认的方式，即终止此线程的执行。当然，我们也可以提供一些函数，在程序中专门用来捕捉和处理某一种特定的信号。&lt;/p&gt;

&lt;h1 id=&#34;时间&#34;&gt;时间&lt;/h1&gt;

&lt;p&gt;unix系统中一般有两种时间，第一种是utc时间，它表示了从1970年1月1日到现在为止所经历的描述，用于描述文件最近的一次修改时间。另外一种是进程时间，用来衡量一个进程使用的cpu资源。unix系统一般来说会提供三个进程运行时间：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;时钟时间： 即该进程一共运行的多久，这个时间可能包括进程因cpu调度而等待的时间&lt;/li&gt;
&lt;li&gt;内核时间： 该进程执行系统调用的时间&lt;/li&gt;
&lt;li&gt;用户时间： 该进程执行的非系统调用的时间&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;系统调用和库函数的区别&#34;&gt;系统调用和库函数的区别&lt;/h1&gt;

&lt;p&gt;我们常说的操作系统，一般包括两部分，内核和一些其他必须的软件。内核负责控制计算机软硬件资源，提供程序的运行环境。在编程中使用的系统调用，一般指的是内核的接口，它向我们开辟了一条路径，由于请求内核的相关服务。unix系统在标准的C库中为我们提供了一些和系统调用同名的函数。在使用c编程的时候，如果我们调用了一个和系统调用重名的库函数，那么这个库函数在内部将负责调用对应的系统调用函数。&lt;/p&gt;

&lt;p&gt;虽然在使用的角度上，我们可以将系统调用看做为c的库函数。但是在实现的角度上，他们是有所不同的。比如malloc库函数，它用于分配内存，但是实际上真正提供分配内存功能的是系统调用sbrk函数。这个时候，如果我们对库函数不满意，完全可以用sbrk来实现一个自己的malloc函数。总的来说也就是，库函数可以替代，但是系统调用不可以。&lt;/p&gt;

&lt;p&gt;系统调用函数提供给我们的往往是原始的功能，如sbrk就是分配一块内存空间，那么具体按什么方式分配甚至是如何管理这段内存空间，都是在库函数中处理的。类似一些返回系统时间的库函数也是一样，系统调用可能只返回一个从1970年1月1日到现在的秒数，至于如何解析这些秒数是库函数来决定的。所以从这两个例子可以看出，系统调用一般提供一个核心的功能，吐给库函数基本的数据，至于这些数据以何种方式使用则由库函数决定。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Reflection in golang (4)</title>
      <link>http://littledriver.net/post/2017/03/12/reflection-in-golang-4/</link>
      <pubDate>Sun, 12 Mar 2017 13:00:47 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/03/12/reflection-in-golang-4/</guid>
      
        <description>&lt;h1 id=&#34;reflection-in-struct-tag&#34;&gt;Reflection in Struct tag&lt;/h1&gt;

&lt;p&gt;golang中的struct类型，在使用的时候为了编码方便我们经常会给其内部的field指定一些特定的tag。这些tag不仅仅可以用来改变编码后相应字段名称，还有一些特别的作用。比如在使用Json这种数据格式的时候，我们可以为struct的field指定一个自定义的json tag，在按照json的格式编码转换的时候，该field的名字就会使用我们自定义的，而不是采取默认的将field的名字的小写形式。如果此时再加上一些特殊的tag，会改变编码时候的行为。如omiempty，在编码一个struct的时候，只要有field值为0值的时候，都不会把他们encoding到json当中。&lt;/p&gt;

&lt;p&gt;在reflect中，我们同样可以通过strct的tag以及fieldName等属性对一个未知的struct进行操作。&lt;/p&gt;

&lt;h3 id=&#34;extract-params-to-appropriate-type&#34;&gt;Extract params to appropriate Type&lt;/h3&gt;

&lt;p&gt;在使用golang实现一些网络接口的时候，普遍需要的一项工作就是解析参数。将http请求带过来的参数解析到之前约定好的数据类型的变量内。这些变量一般都是struct类型，毕竟golang中是通过struct来实现类型的组合，以便构造自定义类型的。那么实现一个这样的结构需要哪几步呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取http传递进来的所有参数，无论是get还是post&lt;/li&gt;
&lt;li&gt;定义好包含所有要处理参数的struct类型&lt;/li&gt;
&lt;li&gt;用解析到http请求参数的字段名通过反射获取到对应struct类型中与其tag相等的field&lt;/li&gt;
&lt;li&gt;将之前从请求中解析出的参数值赋值给已经找到的field&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一步完成比较容易，使用http包中的ParseForm即可将请求中传递的参数都放在req.Form中。第二步也同样简单，我们只需要将要接收的参数以及其对应的类型定义到一个struct内就行了。但是要注意的是，每一个字段tag名称都必须要和请求参数中对应的字段名相等才可以，不然我们就没法通过请求参数的字段名和将要填充的Struct类型的变量链接在一起了。整个解析参数的功能最重要的就是第三步。&lt;/p&gt;

&lt;p&gt;我们可以在外循环遍历请求参数中的字段名，内循环遍历定义好的struct类型变量的field。但是这样效率是非常低的。稍微考虑一下就可以将定义好的struct类型的变量保存在一个map[string]reflect.Value内，map的key为struct内对应的tag，value则为对应的字段值。这样我们就可以在拿到请求参数字段名的时候，以O(1)的复杂度在这个map内找到其对应的field值，然后调用相应的Set方法即可将请求参数的值解析到具体类型的变量中。之所以能够通过构造出来的map改动定义好的struct类型变量内的field值，是因为map本身是一个引用类型，其底层使用的内存空间还是属于struct。&lt;/p&gt;

&lt;p&gt;实现代码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;github.com/qiniu/errors&amp;#34;
	&amp;#34;net/http&amp;#34;
	&amp;#34;reflect&amp;#34;
	&amp;#34;strconv&amp;#34;
)

func ExtractHttpReq(req *http.Request, ptr interface{}) error {
	m := make(map[string]reflect.Value)
	value := reflect.ValueOf(ptr).Elem()
	if value.Kind() != reflect.Struct || !value.IsValid() {
		return errors.New(&amp;#34;input data is invalid&amp;#34;)
	}

	for i := 0; i &amp;lt; value.NumField(); i++ {
		tag := value.Type().Field(i).Tag.Get(&amp;#34;http&amp;#34;)
		if tag == &amp;#34;&amp;#34; {
			tag = value.Type().Field(i).Name
		}
		m[tag] = value.Field(i)
	}

	if err := req.ParseForm(); err != nil {
		return err
	}

	for key, value := range req.Form {
		f, ok := m[key]
		if !ok || !f.IsValid() {
			continue
		}

		for _, item := range value {
			Populate(f, item)
		}
	}

	return nil
}

func Populate(value reflect.Value, item string) {
	switch value.Kind() {
	case reflect.Slice:
		vv := reflect.New(value.Type().Elem()).Elem()
		Populate(vv, item)
		value.Set(reflect.Append(value, vv))
	case reflect.Int, reflect.Int8, reflect.Int16,
		reflect.Int32, reflect.Uint64:
		num, _ := strconv.ParseInt(item, 10, 64)
		value.SetInt(num)
	case reflect.Bool:
		num, _ := strconv.ParseBool(item)
		value.SetBool(num)
	case reflect.String:
		value.SetString(item)
	default:
		fmt.Println(&amp;#34;unsupport type&amp;#34;)
	}

	return
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;reflection-in-method&#34;&gt;Reflection in method&lt;/h1&gt;

&lt;p&gt;除了上面讲到的，可以使用reflect通过struct tag找到其对应的field变量并且更新里面的值之外。我们还可以是用reflect通过一个普通类型的值，找到其定义的成员函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;reflect&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;strings&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Text&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetText&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;get text&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Text&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;PrintMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsValid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;input params is invalid&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NumMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;func (%s) %s %s\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;TrimPrefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;func&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;haha&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;PrintMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ValueOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过上面的实现我们可以看出来，reflect.Type以及reflect.Value都有自己的Method方法。只不过reflect.Type的Method返回的是一个Method类型的数据，它里面包含了关于这个method的一切信息。但是reflect.Value的Method返回的是一个包含了函数值的reflect.Value。我们可以直接通过reflect.Value.Method(index).Call的形式去调用这个函数。&lt;/p&gt;

&lt;h1 id=&#34;how-to-use-reflect&#34;&gt;How to use reflect&lt;/h1&gt;

&lt;p&gt;使用reflect包写出来的代码实际上都是非常脆弱的，尽管我们在使用的过程当中能够尽量的保证我们的程序不panic。但是仔细想想，reflect包一般被用于实现我们的标准库，标准库内对painic的发生是有一套健全的处理机制的，而我在日常工作当中的项目里还仅仅只是处理error而不是处理panic。这可能跟我写的代码都是上层逻辑有关，如果实现一些标准库的话，可能就需要去注意panic的处理了。并且，reflect包使用过程当中的错误，基本不会被在编译时期就检查出来，都是在运行时触发的。&lt;/p&gt;

&lt;p&gt;reflect.Value类型的变量在调用相应方法的时候，一定记得先要检查这个变量是否是zero value或者它的动态类型是什么。因为reflect包中的很多方法在调用的时候都不会帮你做这些，一旦你使用了不当的类型调用了其所没有实现的方法的时候，将会直接导致panic的发生。另外一个类似的问题就是，在调用setxx方法之前，要检查一下这个变量是否是可寻址的并且是可以更新的。&lt;/p&gt;

&lt;p&gt;还有一个比较危险的地方就是，reflect包无法识别无限递归的问题。我们之前实现了一个格式化输出一般数据类型变量内容的函数，假设这个数据类型的内部成员的类型和外部是一致的，就会导致无限递归的调用。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;type Recursive struct {
	T Recursive
	A string
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种例子其实并不罕见，比如链表的实现常常就会使用类似的数据结构。而且reflect的代码因为没有依赖具体的数据类型，所以它的速度是非常慢的。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Reflection in golang (3)</title>
      <link>http://littledriver.net/post/2017/03/11/reflection-in-golang-3/</link>
      <pubDate>Sat, 11 Mar 2017 15:53:31 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/03/11/reflection-in-golang-3/</guid>
      
        <description>&lt;h1 id=&#34;前景提要&#34;&gt;前景提要&lt;/h1&gt;

&lt;p&gt;上一篇文章当中，主要以实现了一个display函数为主要内容，阐述了如何通过golang的reflect包将一个自定义类型的数据格式化输出，它类似于一个简洁版的fmt.Printf函数。但是这个函数只是简单的实现了从具体类型的数据到字符串的输出功能。在日常的工作中，我们时常要通过http/https请求调用一些第三方服务的接口，传输的数据不但需要保持一定的编码格式，还需要按照被调用服务接口接收数据的规范来构造我们的请求数据。&lt;/p&gt;

&lt;p&gt;在使用golang的过程当中，一定少不了对encoding/json包当中的json.Marshal方法的使用，他接收一个interface值, 返回一个以ASN.1格式编码byte数组。 ASN.1是一套正式且公用的编码标准，使用json.Marshal对我们的数据进行编码之后，得到的结果就可以在进程间以及服务间进行传输。编码这件事，说白了，就是把我们准备好的数据通过一定的规则转换成另外一种表现形式，比如把十进制数字转换成二进制数据，我觉得这就是一种编码。再不理解的话，也可以想想莫斯密电码，应该很容易就明白了。&lt;/p&gt;

&lt;p&gt;今天这篇文章，将会对上次我们实现的display函数进行再一次的扩展，使其能够具备数据编码的功能.&lt;/p&gt;

&lt;h1 id=&#34;encoding&#34;&gt;Encoding&lt;/h1&gt;

&lt;p&gt;golang的标准库内为我们提供了几种常见并且通用的编码格式，如，xml, json, asn.1等。熟悉lisp或者scheme的人肯定知道s-expression这种格式。仿照《The Go programing language》一书中的例子，我自己也实现了一个将普通数据编码成s-expression形式的函数。（由于注重的是反射的使用，所以在代码风格上面没有做过多的注意，各位看官勿喷）&lt;/p&gt;

&lt;p&gt;在我实现的Encoding函数中，我主要处理了String, int, array, slice, struct, map, ptr等类型的数据编码，其余的如interface等类型，为了简单起见，我并没有对其做处理。编码的规范如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数字的类型如int还是直接编码成对应的字符串表示。字符串类型也是一样&lt;/li&gt;
&lt;li&gt;struct类型编码成（(fieldName fieldValue) (fieldName fieldValue) &amp;hellip;）的形式&lt;/li&gt;
&lt;li&gt;map类型编码成 ((keyName value), (keyName value) &amp;hellip;)的形式&lt;/li&gt;
&lt;li&gt;指针类型不做特殊处理，而是获取到其指向的变量之后，对这个变量编码。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;116
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;117
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;118
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;119
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;120
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;121
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;122
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;123
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;124
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;125
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;126
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;127
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;128
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;129
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;130
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;131
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;132
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;133
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;134
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;135
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;136
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;137
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;138
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;139
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;140
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;141
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;142
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;143
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;144
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;145
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;146
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;147
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;148
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;149
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;150
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;151
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;152
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;153
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;154
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;155
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;156
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;157
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;158
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;159
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;160
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;161
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;162
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;163
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;164
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;165
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;166
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;167
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;168
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;169
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;170
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;171
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;172
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;173
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;174
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;175
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;176
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;177
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;178
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;bytes&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;reflect&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Encode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Invalid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;nil&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%q&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Encode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Encode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NumField&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;

			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Encode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;MapKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Encode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;

			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Encode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;MapIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

		&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%s:%s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;unsupport type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Fuck&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;fuck&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;You&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;you&amp;#34;`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Domain&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;            &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;domain&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Cache&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;          &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;cache&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;CdnState&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;cdnState&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;               &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;time&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;        &lt;span class=&#34;s&#34;&gt;`json:,inline`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Fuck&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fff&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;You&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Domain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hahah.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;CdnState&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;s&#34;&gt;&amp;#34;ws&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;success&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;s&#34;&gt;&amp;#34;tc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;success&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Encode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ValueOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Error: %+v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%+v\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()))&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上述代码的输出结果为:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;👉  go run encode.go
((Domain &amp;#34;hahah.com&amp;#34;) (Cache (&amp;#34;1&amp;#34; &amp;#34;2&amp;#34; &amp;#34;3&amp;#34;)) (CdnState ((&amp;#34;tc&amp;#34; &amp;#34;success&amp;#34;) (&amp;#34;ws&amp;#34; &amp;#34;success&amp;#34;))) (Time 2) (B ((Fuck &amp;#34;fff&amp;#34;) (You 3))))
	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看出，Encoding函数已经简单的将普通数据类型的数据编码成了s-expression的形式。其实编码的格式并不一定要局限于一些目前公认标准的格式，我们也完全可以定义一套自己的规则。只要这套规则在编码和解码的过程中都能够保证数据的完整性和正确性即可。&lt;/p&gt;

&lt;h1 id=&#34;set-value&#34;&gt;Set value&lt;/h1&gt;

&lt;p&gt;之前的几篇关于反射的文章，甚至是这一篇文章，到此为止，在代码上面的实现以及对反射的讲解都停留在观察的层面上，也就是我们仅仅是把一个普通数据类型的值通过反射更进一步的获取他们信息，如类型，值等等。然后可以通过一些手段格式化输出他们。实际上，之前几篇文章的重点，并不在于使用reflect包实现一些具体的功能，而是在向大家突出，利用reflect几乎可以处理所有现在的以及未来的数据类型。当你把普通的数据类型通过reflect.ValueOf转换成reflect.Value类型值的时候，你可以以他为起点去做任何事情。之前实现的格式化输出，以及上面实现的编码功能。那么接下来我们就来了解一下，如何通过reflet包来更改一些未知的数据类型的值。&lt;/p&gt;

&lt;h2 id=&#34;从变量说起&#34;&gt;从变量说起&lt;/h2&gt;

&lt;p&gt;大家都知道，编程中最常见的两个概念就是变量和常量。顾名思义，变量是可以改变的，常量是恒久不变的。变量为什么可以改变呢？因为变量本身就是一个被名字标识的内存空间，它是可寻址的。只要一个东西是可寻址的，那么我们就可以通过地址在内存中找到他的位置，然后修改它内存空间中所保存的内容。这其实也就是我们常说的给变量赋值的过程。&lt;/p&gt;

&lt;p&gt;对于reflect.Value值来说，它和interface一样，本身可以接受任何类型的数据。那么任意reflect.Value的值都可以像变量一样随意的更改么？我们写一个demo试试就知道了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	a := 2
	x := reflect.ValueOf(a)
	fmt.Println(x.CanSet())  //false

	y := reflect.ValueOf(&amp;amp;a)
	fmt.Println(y.CanSet())  //false

	z := y.Elem()
	fmt.Println(z.CanSet()  //true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过调用reflect.Value.CanSet方法，根据其返回的结果是true还是false就可以确定一个reflect.Value值是不是可以改变的。 x在调用的时候返回了false,这是因为在构造x的时候，使用的是a这个变量内存储的值2，但是它自己并没有申请内存来存这个值. y也同样是这样，虽然它是通过a变量的地址值来构造的。事实上，任何通过reflect.ValueOf构造出来的reflect.Value都是不可寻址的，也就是说，我们只是copy了一份值来显示，并不能去改动他。&lt;/p&gt;

&lt;p&gt;但是当我们对y调用Elem方法得到z，z却是一个可以改变的值。这是为什么呢？首先y是通过一个指针的值来构造的，其内存存储的是a这个变量的内存地址。调用Elem()方法，得到的是这个地址指向的内存空间，也就是a这个变量的地址空间。赋值给z也并没有切断y所指向的内存空间与a的联系，仅仅是给这块空间起了一个别名。&lt;/p&gt;

&lt;p&gt;reflect包中还有一个方法叫做CanAddr。它的定义是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;CanAddr reports whether the value&amp;#39;s address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;它的功能是可以判断出一个reflect.Value是否是可寻址的。在它的描述当中也指出了，slice或者一个可寻址数组中的一个元素，或者一个可寻址的结构体的一个属性，甚至是对一个指针解引用的结果都是属于可寻址的。通过这几个例子我们可以看出，一个可寻址的reflect.Value都是需要通过一个指针指向某块内存的地址来间接获取到的。比如说，s := string[]{&amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo;}, reflect.ValueOf(s)是不可寻址的，它只是通过这个slice底层引用数组的起始地址构造了一个reflect.Value值。但是这时我通过调用reflect.ValueOf(s).Index(0)，就可以得到一个可寻址的值。因为通通过reflect.ValueOf得到了slice引用的底层数组的起始地址，然后通过index方法计算了内存的偏移量，就得到了在这段连续内存当中第一个元素的内存空间，即一个可寻址的值。所以说，在reflect当中，想要拿到一个可寻址值，首先要得到这个可寻址值所在的内存空间的地址。&lt;/p&gt;

&lt;h2 id=&#34;更新变量&#34;&gt;更新变量&lt;/h2&gt;

&lt;p&gt;当我们想要更新一个reflect.Value所引用的变量的值时，可以通过Set方法来做到。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	x := []int{1,2}
	z := reflect.ValueOf(x).Index(0) //get an addressable reflectValue
	z.Set(reflect.ValueOf(3)) // update value&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;需要注意的是，在调用Set方法进行赋值操作的时候，reflect包会像普通数据类型的赋值操作一样，检查赋值的合法性。比如z标识的可寻址值是一个int类型的，如果此时在调用set方法的时候，赋值给其一个int64类型的值就会导致panic。所以在使用set之前，我们必须保证我们将要给某个变量赋的值是它能够接受的。但是Set方法有一些变体，如SetInt, SetUint等.只要调用这些函数的值是有符号整数类型甚至是其底层的数据类型符合以上的条件，setInt等方法无论接收多大的数值都会通过截断的方式，构造出一个调用这个函数的值能接受的结果并赋值给它。&lt;/p&gt;

&lt;p&gt;在第二篇文章中我们实现的格式化输出任意数据类型值的程序中，如果你仔细调试就会发现，如果输出的是一个struct类型的变量，那么其内部不可导出的field也可以被找到并且输出。我们可以通过Field或者FieldByName方法来获取struct类型值当中的某一个field，如果获取的是一个不可导出的field，那么对这个结果调用set类的修改方法会导致panic。这是一个特例，struct结构体内的不可导出field是可寻址的，但是是不可修改的。&lt;/p&gt;

&lt;h1 id=&#34;本文代码&#34;&gt;本文代码&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fengzixu/golangLearning/blob/master/reflect/encode.go&#34;&gt;点这里&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Reflection in golang (2)</title>
      <link>http://littledriver.net/post/2017/03/09/reflection-in-golang-2/</link>
      <pubDate>Thu, 09 Mar 2017 19:41:34 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/03/09/reflection-in-golang-2/</guid>
      
        <description>&lt;h1 id=&#34;前景提要&#34;&gt;前景提要&lt;/h1&gt;

&lt;p&gt;在上一篇Reflection in golang的文章中，主要介绍了reflect.Type, reflect.Value, reflect.ValueOf, reflect.Type等数据结构以及接口。文章的开头我们想通过switch/case的方式来将任意类型的数据进行格式化操作。因为遇到数据类型太多，难以维护的问题，我们选择了反射当中的kind类型来解决。文章的最后给出了一个简单的demo来表明，通过reflect.Kind的帮助，我们可以将无限的数据类型归结到几个有限的基本数据类型中，使得我们的格式化操作变得比之前要简单得多。但是同样有一个问题就是，对于slice，array，map等这种复合型的数据类型的时候，我们没有办法递归的进行操作。只能简单的输出他们的类型或者是地址。这篇文章将会以此问题为起点，继续介绍reflect包中的种种特性。&lt;/p&gt;

&lt;h1 id=&#34;recursive-display&#34;&gt;Recursive display&lt;/h1&gt;

&lt;p&gt;先来看看我实现的递归输出任意类型内容的demo&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;reflect&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;strconv&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Invalid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s = invalid\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s[%d]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NumField&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s.%s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;MapKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s[%s]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;formatAtom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;MapIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsNil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s = nil\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;(*%s)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsNil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s = nil\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s.type = %s\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.Value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s = %s\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;formatAtom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;formatAtom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Int16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;FormatInt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Quote&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;FormatBool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Chan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;FormatUint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; value&amp;#34;&lt;/span&gt;

	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Domain&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;StateSlice&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;LineMap&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Ptr&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Inter&lt;/span&gt;      &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fuck&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;you&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Domain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;s&#34;&gt;&amp;#34;xuran.qbox.net&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;StateSlice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;LineMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Inter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ValueOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;a.StateSlice[1] = &amp;#34;b&amp;#34;
a.StateSlice[2] = &amp;#34;c&amp;#34;
a.StateSlice[3] = &amp;#34;d&amp;#34;
a.LineMap[&amp;#34;fuck&amp;#34;] = 2
a.LineMap[&amp;#34;you&amp;#34;] = 1
(*a.Ptr) = 3
a.Inter.type = int
a.Inter.Value = 4&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;实现的逻辑还是非常简单的，但是使用golang的反射一定要小心小心再小心，因为reflect.Value虽然有很多方法可以调用，但是并不是每个都像String方法那么友好，对于内部包含了某种特定动态类型的reflect.Value值使用一些不恰当的方法的时候，是很有可能会直接panic的。我实现的版本中在调用特定的方法之前都利用kind()配合switch/case检查了reflect.Value类型数据所包含的动态类型是否支持我要做的操作，比如display函数中对Slice类型单个元素的操作，如果我没有检查，对一个内置动态类型为string的reflect.Value数据使用了index方法，那么就会导致panic。文档中对于Index这个函数式这样描述的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Index returns v&amp;#39;s i&amp;#39;th element. It panics if v&amp;#39;s Kind is not Array, Slice, or String or i is out of range.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对于reflect.Value类型，文档也有相应的描述&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Value is the reflection interface to a Go value.
Not all methods apply to all kinds of values. Restrictions, 
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of value before
calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可见，golang文档中对于reflect.Value方法的使用也倾向于先使用Kind来确定类型在操作这种形式。&lt;/p&gt;

&lt;p&gt;在实现的时候，需要注意以下几点：
1. 在操作struct类型值的时候，numField可以返回包括匿名成员在内的所有成员数量。
2. mapKeys方法会返回一个map内key的集合，但是当我们迭代的时候，它的顺序是不一致的，这和map本身是hashMap实现是有关系的。用formatAtom来处理map的key的时候其实是有一些问题，因为map的key的类型在golang中是可以使用一切可以比较的类型，如interface, array等都是合法的类型，但是上面的实现中暂时没有处理。
3. 处理指针类型的时候，v.ELem()返回的是一个该指针指向的变量。即使此时指针的值是nil，formatAtom的第一个case reflect.Invaild也会以合适的方式处理它，并且在实现中，已经提前检测了指针所指向的值是否为nil。&lt;/p&gt;

&lt;h2 id=&#34;对递归实现的一些思考&#34;&gt;对递归实现的一些思考&lt;/h2&gt;

&lt;p&gt;reflect中的zero value和golang中普通的zero value值是不一样的， 一般来讲普通的zero value指的是特定类型的默认值，如int是0，string是&amp;rdquo;&amp;ldquo;。reflect.ValueOf的文档描述中，有这样的解释：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;ValueOf returns a new Value initialized to the concrete value stored in the 
interface i. ValueOf(nil) returns the zero Value.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;也就是说，ValueOf通过传进来的interface值内部的动态类型的值初始化创建一个reflect.Value,如果传递进来的interface的值本身就为nil，而不是interface内部动态类型值为nil，那么valueOf出来的结果就是reflect中的zero value.他的类型应该是Invalid。对于zero value的reflect.Value值，除了调用Kind和String两个方法之外，其余的方法都会造成panic。&lt;/p&gt;

&lt;p&gt;测试代码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	var haha *int
	//haha = nil
	fmt.Println(reflect.ValueOf(haha).IsValid()) true
	fmt.Println(reflect.ValueOf(haha)) &amp;lt;nil&amp;gt;
	var hehe interface{}
	fmt.Println(reflect.ValueOf(hehe).IsValid() false&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过上面的代码就可以看出，valueof一个包含了指向nil的指针的interface值得到的reflect.Value是非zero value，但是valueof一个值为nil的interface变量就是 zero value。&lt;/p&gt;

&lt;p&gt;仔细思考过上面代码的同学就可以看出一些额外的端倪，当我们在处理a.Inter的时候，看程序的执行结果是命中了reflect.Interface的case。但是假设我们现在写这样的两行代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	var ff interface{} = 3
	fmt.Println(reflect.Value(ff).Kind())&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;输出的结果却是int。返回来看之前valueOf函数的说明是可以得出一些线索的。valueof构造出来的reflect.Value和field(i)构造出来的reflect.Value调用kind的方法得出的结果并不是一致的。即使看起来两个reflect.Value都是通过一个interface的值构造出来的。虽然现在还不能明确搞清楚其中的原因，但是直觉上我觉得，valueof是通过interface包含的动态类型的值来构造reflect.Value的，虽然valueof接受的是一个Interface，但实际上却用了Interface内包含的3，field(4)返回的仅仅是Inter这个interface类型的变量。所以他的kind是reflect.Interface,如果再向下递归查找，就可以得出和上面一样的结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	fmt.Println(reflect.ValueOf(a).Field(4).Kind()) // interface
	fmt.Println(reflect.ValueOf(a).Field(4).Elem().Kind() // int&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;再举一个例子来说明上面的情况&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	var i interface{} = 3
	fmt.Println(reflect.ValueOf(i).Kind()) //int
	
	fmt.Println(reflect.ValueOf(&amp;amp;i).Kind()) //ptr
	fmt.Println(reflect.ValueOf(&amp;amp;i).Elem().Kind()) //interface
	fmt.Println(reflect.ValueOf(&amp;amp;i).Elem().Elem().Kind()) //int&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可见valueOf这个函数会像剥洋葱一样，一层一层的递归查找下去，而不是一下子就找到最底层的类型来创建reflect.Value类型的值。&lt;/p&gt;

&lt;h1 id=&#34;本文代码&#34;&gt;本文代码&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fengzixu/golangLearning/blob/master/reflect/reflect.go&#34;&gt;点这里&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Reflection in golang (1)</title>
      <link>http://littledriver.net/post/2017/03/05/reflection-in-golang-1/</link>
      <pubDate>Sun, 05 Mar 2017 19:40:29 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/03/05/reflection-in-golang-1/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;工作当中需要用到go的反射相关功能，实话说，这还是第一次接触我所学语言当中的反射机制。我觉得这对我来说是一个好的现象，一个是证明了自己之前做的东西技术含量是比较低的，给自己一个警醒，另外一个是证明我现在做的东西和之前做的东西已经有很大的不同了。本次工作当中对反射的应用，我会另写一篇博文，并且将部分源码up到github上面。这篇文章就先讲一讲我学习的go反射相关的知识。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;0x001&#34;&gt;0x001&lt;/h1&gt;

&lt;p&gt;go语言在reflect包中为我们提供了反射的功能，那么具体什么是反射功能呢？反射功能其实就是在程序运行时可以对一个变量进行一些操作，如查询，更新，但是实际上在程序的编译时期我们是并不知道这个变量的类型是什么的。这就和我们之前写golang程序的思路不太一样。golang本身是一个强类型的语言，它和js和py不同，golang所产出的程序需要编译，并且在编译的时候就会做一些静态类型的检查工作。之前写代码的时候，对于变量类型的要求也是很高的，比如类型断言，类型转换的时候。不同类型的变量有不同的方法，可以进行不同的操作，但是变量所做的操作都是在已知类型的基础上完成的。golang提供的reflect包却可以在不知道变量具体类型的前提下正确的进行它能够执行的操作。&lt;/p&gt;

&lt;h1 id=&#34;0x002&#34;&gt;0x002&lt;/h1&gt;

&lt;p&gt;一个能体现go反射存在意义的最好的例子就是fmt.Fprintf函数，他接收任意类型的值，包括用户自定义的。然后根据传递进来的值的类型进行格式化，最终返回一个字符串。我们先可以按照它的例子也实现一个简单的Sprint格式化函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	type Stringer struct {
		String() string
	}
	
	func Sprint(x interface{}) string { 
		switch x := x.(type){
			case Stringer:
				return x.String()
			case bool:
				if x {
					return &amp;#34;true&amp;#34;
				}else {
					return &amp;#34;false&amp;#34;
				}
			case int:
				return strconv.Itoa(x)
			default:
				return &amp;#34;???&amp;#34;
		}
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们实现的函数接收一个interface的值，进入函数的逻辑之后，首先x.(type)得到x变量所包含值的具体的动态类型是什么。如果是Stringer类型，那么说明这个类型实现了String方法，可以直接调用。但是对于其他的类型，我们就需要自己来做转换。但是上面函数一个很大的缺陷，就是我们需要去维护那个switch语句，因为只要我们需要去处理不同类型的数据，我们就要在这个switch里面加入相应的case。并且，如果需要处理的类型是我们自定义，亦或是其余第三方包定义的类型，虽然他们的底层类型可能都是一些基础的数据类型，但是case里面的基础类型是不会匹配到底层类型的，而且，如果匹配的是自定义的类型，那么势必这个函数会对很多包产生不必要的依赖。&lt;/p&gt;

&lt;p&gt;在使用反射之前，我们貌似没有任何办法去查看未知类型变量的表示。&lt;/p&gt;

&lt;h1 id=&#34;0x003-reflect-type&#34;&gt;0x003 reflect.Type&lt;/h1&gt;

&lt;p&gt;go语言的reflect当中定义了两种非常重要的类型，reflect.Value, reflect.Type。其中reflect.Type可以表示一个具体的go的类型，它实现了很多的方法，可以区分reflect.Type具体包含的是哪种类型的变量，并且还可以检查对应类型一些更详细的信息。reflect.Type的实现细节和Interface类型实现相同，其内部包含了所存储数据具体的动态类型。&lt;/p&gt;

&lt;p&gt;reflect包还提供了一个TypeOf方法，这个方法可以接受一个interface的参数，并且以reflect.Type的形式返回这个interface值内所保存数据的动态类型到底是什么。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;   t := reflect.TypeOf(3)
   fmt.Println(t.String()) “int”
   fmt.Println(t) &amp;#34;int&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在上面代码中，我们将3以隐式转换的形式赋值给TypeOf的interface类型的参数，通过调用TypeOf函数，我们可以得出所传参数具体的golang类型是什么。当我们将3转换成一个interface值的时候，这个interface类型的参数实际上包含了两个重要的信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;传递给他数据的具体数据类型&amp;mdash;&amp;ndash;&amp;gt; int (动态类型)&lt;/li&gt;
&lt;li&gt;传递给他数据的值是&amp;mdash;-&amp;gt; 3 (动态值)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这也就提醒了我们，当我们把一个具体类型的数据赋值给一个Interface类型的变量的时候，它内部实际会生成这两种信息。&lt;/p&gt;

&lt;h1 id=&#34;0x004-reflect-value&#34;&gt;0x004 reflect.Value&lt;/h1&gt;

&lt;p&gt;reflect.Value是reflect包中另外一个非常重要的类型,其实reflect.Value和reflect.Type是一样的，reflect.Value可以保存任何类型的数据，
对应的reflect.ValueOf方法也接受一个Interface{}的值(任意类型的数据)，最后以reflect.Value的形式返回interface变量内包含的动态值。这里需要注意的是，reflect.Value虽然可以从其他任意类型的值转换而来，但是需要通过valueOf这种方法才行，上面说的意思并不代表你可以把任意类型的值直接赋值给reflect.Value类型的变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;		s := 3
		fmt.Println(reflect.ValueOf(s)) // 3
		fmt.Println(reflect.ValueOf(s).String()) &amp;lt;int value&amp;gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面代码通过valueOf得到了s被转换为Interface类型变量后的动态值。第一行直接输出了动态值3，第二行调用String方法却并没有输出3，那是因为int类型并没有实现Stringer接口中的String方法，所以reflect包就返回了这个动态值的类型。
reflect.Type和refletc.Value虽然都包含了很多的方法，但是这些方法并不是对他们所包含的所有的类型和值都适用。上面的代码就表现了，reflect.Value包含的具体的值并不支持String这个方法。&lt;/p&gt;

&lt;p&gt;reflect.ValueOf还有一个相反的方法是reflect.Value.Interface, valueof方法本身已经得到某个interface变量内包含的动态值了，但是在此之上调用interface方法就又把结果转换回了interface类型。本质上来说，reflect.Value类型和interface类型的变量都保存任意类型的值，但是他们的区别在于。interface类型的变量隐藏了其内部包含值的动态类型以及它能做的相关的操作。只有在知道其内部包含值的动态类型是什么的前提下，我们才能够通过类型断言的方式得到其内部存储的数据。reflect.Value就和它有很大的不同，reflect.Value本身就提供了很多的方法，让我们能够了解其内部包含值的一些信息，无论它的类型是什么。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/QQ20170309-163323@2x.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后关于reflect.Value还要提到的一点是，它支持一个名做kind的方法，这个方法将返回一个reflect.Kind的类型值。Kind类型对golang中已有的基础类型做了归类，虽然我们可以在golang使用无数的新类型(这些新类型大多是基础类型的组合)，但是一些基础的类型目前确实有限的，恰恰kind对此做了一层包装。&lt;/p&gt;

&lt;p&gt;比如在我们之前实现的sprint函数中，我们可能担心无法处理[]float64,[]string这种类型的变量，但是实际上他们都有一个共同的特点就是使用了slice这种引用类型。kind就把无限的数据类型，归纳到了有限的几个大家公用的基础类型上面。kind内包装的基础类型增长缓慢，即使用了switch也不会造成频繁改动case的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	const (
        Invalid Kind = iota
        Bool
        Int
        Int8
        Int16
        Int32
        Int64
        Uint
        Uint8
        Uint16
        Uint32
        Uint64
        Uintptr
        Float32
        Float64
        Complex64
        Complex128
        Array
        Chan
        Func
        Interface
        Map
        Ptr
        Slice
        String
        Struct
        UnsafePointer
)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;所以有了它，我们可以将我们之前实现的sprint函数改动一下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	func Sprint(x relect.Value) string { 
		switch x := x.kind(){
			case reflect.Int, reflect.Int8:
				...
			case reflect.Bool:
				...
			case reflect.Array, reflect.Slice:
				...
		}
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;改动之后的版本就非常的清晰了，Kind的出现可以将我们从处理具体类型的泥潭中解救出来，根据一切具体类型都是通过对基本类型的聚合甚至就是基本类型的前提，我们可以对基本类型进行分类，只处理有限的情况。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>工作中踩过的的坑之golang的临时变量</title>
      <link>http://littledriver.net/post/2017/03/05/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E7%9A%84%E5%9D%91%E4%B9%8Bgolang%E7%9A%84%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sun, 05 Mar 2017 11:26:36 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/03/05/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E7%9A%84%E5%9D%91%E4%B9%8Bgolang%E7%9A%84%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;在使用golang的时候，经常在一些比较小的地方被绊倒，这些“坑”并不是什么难以理解和运用的技术，而是一些语言的细节我们没有了解清楚。这类的问题我将他统一称为golang中的“坑”。这些细小的问题容易遗漏，特此记录，以便随时翻看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;golang中的临时变量&#34;&gt;golang中的临时变量&lt;/h1&gt;

&lt;p&gt;在使用golang的时候，我们都遇到过遍历一个集合的情况，如遍历Slice，Map等。golang遍历Slice格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	for _, item := range s {
		fmt.printfln(item)
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在循环的过程当中，并不是每一次循环都申请一个不同的临时变量item，而且整次循环只声明一个临时变量，在循环结束后这个变量会被gc回收。每次循环都会把Slice中的一个值赋值给item，然后输出出来。如上面代码实例中使用是没有问题的，下面来看看两种异常情况。&lt;/p&gt;

&lt;h2 id=&#34;多个goroutine并发得到了同一个值&#34;&gt;多个goroutine并发得到了同一个值&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	
import &amp;#34;fmt&amp;#34;

func main() {
	doneChan := make(chan int)
	for i := 0; i &amp;lt; 10; i++ {
		go func() {
			fmt.Printf(&amp;#34;Address: %#v Value: %d\n&amp;#34;, &amp;amp;i, i)
		}()
	}

	&amp;lt;-doneChan
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上述代码的本意是每一个goroutine读取一个i值，随着goroutine的增加，读取到的i的地址以及i的值也会随之变化。我们期待的结果是这样的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	Address: (*int)0x11111 Value: 0
	Address: (*int)0x22222 Value: 1
	Address: (*int)0x33333 Value: 2
	Address: (*int)0x33333 Value: 3
	...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;但是实际上，得到的结果却是这样的:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10
Address: (*int)(0x1040a124) Value: 10&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;得到现在这种异常结果的原因，在于我们没有正确理解golang的遍历机制。我们以为golang在循环遍历的过程当中，每一次遍历都会新定义一个临时变量i来存储值，这样在多个goroutine中我们读取i的值是不一样的。但是实际上，在整个循环当中golang只会定义一个临时变量i，内存空间只有一份，每次遍历的值都会放在这个内存的空间中，所以，才会出现上述的异常结果。在最后一次循环的时候，i是为10的，循环中启动的10个goroutine都读取的是同一个i值。&lt;/p&gt;

&lt;p&gt;如果想实现我们预期的效果，需要在每次循环中都新定义一个变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;doneChan&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Address: %#v Value: %d\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;doneChan&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;修改后的结果为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Address: (*int)(0x1040a148) Value: 9
Address: (*int)(0x1040a124) Value: 0
Address: (*int)(0x1040a128) Value: 1
Address: (*int)(0x1040a12c) Value: 2
Address: (*int)(0x1040a130) Value: 3
Address: (*int)(0x1040a134) Value: 4
Address: (*int)(0x1040a138) Value: 5
Address: (*int)(0x1040a13c) Value: 6
Address: (*int)(0x1040a140) Value: 7
Address: (*int)(0x1040a144) Value: 8&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;取集合中多个元素的地址却得到的是同一个&#34;&gt;取集合中多个元素的地址却得到的是同一个&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Addr: %#v, Item: %+v\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面这段程序的结果如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Addr: (*int)(0x1040a124), Item: 1
Addr: (*int)(0x1040a124), Item: 2
Addr: (*int)(0x1040a124), Item: 3&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从程序的结果上我们可以看出，在遍历的过程当中访问值是没问题的，因为是同步的，不涉及到多线程访问。但是访问变量的地址确实有问题的。假设当你实现的一个函数接收的是一个int类型的指针，如果你想把循环过程当中的变量的地址传递进去，然后在函数中访问不同的变量值，就是不可行的。解决办法也很简单，就是每次循环的时候，都创建一个新的临时变量。以遍历map举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	for k, v := range abilityMap {
 		enableValue := v.Enable
  		ability := fusion.AbilityQueryArgs{
  			Domain:       domain,
  			AbilityType:  k,
  			AbilityValue: fusion.AbilityValueStringToInt[v.AbilityValue],
  			Config:       v.Config,
 			Enable:       &amp;amp;enableValue,
  		}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这与第一个遇到的问题其实是类似的，总结下来, 在遍历的过程当中，如果是同步逻辑，那么使用值没问题，但是使用地址不行。如果是异步逻辑，使用地址和值都是不行的。&lt;/p&gt;

&lt;p&gt;所以，在遍历集合类型数据的过程当中，要注意使用的是变量的地址还是值，并且要注意是在同步场景还是异步场景下。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>golang net/http package源码分析(1)</title>
      <link>http://littledriver.net/post/2017/02/17/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/</link>
      <pubDate>Fri, 17 Feb 2017 15:11:16 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/02/17/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;平时在工作的过程当中对net包里面的各种库有非常多的使用，本文将先对golang标准库中net/http包进行剖析，文末会向大家展示使用golang编写的简单网络服务的运行机制。基于golang1.8版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	func CanonicalMIMEHeaderKey(s string) string&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;函数功能描述&#34;&gt;函数功能描述&lt;/h3&gt;

&lt;p&gt;该函数将会按照mime的规范来格式化你传递进来的http header字符串。如你传入keep-alive，该函数就会返回一个Keep-Alive。具体的规范简单来说就是把开头的第一个字母以及如果连字符后面的第一个字母变成大写。&lt;/p&gt;

&lt;p&gt;函数的内部会逐个字节的去检测你传递进来需要转换的http header字符串里面的字符是否合法。具体的检测规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;检查某个字符的ascii码值是否处于ascii码表中可显示字符能表示的范围内&lt;/li&gt;
&lt;li&gt;在net/textproto包下会有一个预定义的数组，它以ascii码值为索引，true为对应的元素值。在上一条检测成功的前提下，还会利用检查的字符作为数组索引去预定义的数组中取值的方式来再次校验这个字符是否真的是合法的ascii字符。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;检测函数内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// validHeaderFieldByte reports whether b is a valid byte in a header
// field name. RFC 7230 says:
//   header-field   = field-name &amp;#34;:&amp;#34; OWS field-value OWS
//   field-name     = token
//   tchar = &amp;#34;!&amp;#34; / &amp;#34;#&amp;#34; / &amp;#34;$&amp;#34; / &amp;#34;%&amp;#34; / &amp;#34;&amp;amp;&amp;#34; / &amp;#34;&amp;#39;&amp;#34; / &amp;#34;*&amp;#34; / &amp;#34;+&amp;#34; / &amp;#34;-&amp;#34; / &amp;#34;.&amp;#34; /
//           &amp;#34;^&amp;#34; / &amp;#34;_&amp;#34; / &amp;#34;`&amp;#34; / &amp;#34;|&amp;#34; / &amp;#34;~&amp;#34; / DIGIT / ALPHA
//   token = 1*tchar
func validHeaderFieldByte(b byte) bool {
	return int(b) &amp;lt; len(isTokenTable) &amp;amp;&amp;amp; isTokenTable[b]
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面我们来看下这个函数的具体实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func CanonicalMIMEHeaderKey(s string) string {
	// Quick check for canonical encoding.
	upper := true
	for i := 0; i &amp;lt; len(s); i++ {
		c := s[i]
		if !validHeaderFieldByte(c) {
			return s
		}
		if upper &amp;amp;&amp;amp; &amp;#39;a&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39; {
			return canonicalMIMEHeaderKey([]byte(s))
		}
		if !upper &amp;amp;&amp;amp; &amp;#39;A&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;Z&amp;#39; {
			return canonicalMIMEHeaderKey([]byte(s))
		}
		upper = c == &amp;#39;-&amp;#39;
	}
	return s
}

// canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is
// allowed to mutate the provided byte slice before returning the
// string.
//
// For invalid inputs (if a contains spaces or non-token bytes), a
// is unchanged and a string copy is returned.
func canonicalMIMEHeaderKey(a []byte) string {
	// See if a looks like a header key. If not, return it unchanged.
	for _, c := range a {
		if validHeaderFieldByte(c) {
			continue
		}
		// Don&amp;#39;t canonicalize.
		return string(a)
	}

	upper := true
	for i, c := range a {
		// Canonicalize: first letter upper case
		// and upper case after each dash.
		// (Host, User-Agent, If-Modified-Since).
		// MIME headers are ASCII only, so no Unicode issues.
		if upper &amp;amp;&amp;amp; &amp;#39;a&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39; {
			c -= toLower
		} else if !upper &amp;amp;&amp;amp; &amp;#39;A&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;Z&amp;#39; {
			c += toLower
		}
		a[i] = c
		upper = c == &amp;#39;-&amp;#39; // for next time
	}
	// The compiler recognizes m[string(byteSlice)] as a special
	// case, so a copy of a&amp;#39;s bytes into a new string does not
	// happen in this map lookup:
	if v := commonHeader[string(a)]; v != &amp;#34;&amp;#34; {
		return v
	}
	return string(a)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;内层的canonicalMIMEHeaderKey函数在转换之前需要检查所有的字符是否符合规范，如果符合规范则开始转换。检测的过程当中，通过判断当前字符是否是连接符来决定是否应该转换字符为大写。在规范的http请求头中，第一个字符和连接线后第一个字符都应该是大写的。至于其余的字符，都应该是小写才对。第一个if分支用来将第一个小写字符和连接符后的小写字符变为大写，第二个if分支用来将除上述两个字符之外的字符变为小写。commonHeader检测我们转换后的字符串，如果是已知的，则直接返回我们预定义的，否则返回转换后的。&lt;/p&gt;

&lt;p&gt;外层的CanonicalMIMEHeaderKey则决定是否要进行进一步的检测和转换，如果传递进来的字符串是符合规范的，那么外层的逻辑可保证不会进行多余的转换。外层的两个if逻辑和上面内层叙述的两个if逻辑是一样的。都是按照标准的http header来检测每一个字符来决定是否要进行下一步的转换。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Https通信机制</title>
      <link>http://littledriver.net/post/2017/02/16/https%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Thu, 16 Feb 2017 19:45:51 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/02/16/https%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</guid>
      
        <description>&lt;h1 id=&#34;为何要使用加密通信&#34;&gt;为何要使用加密通信&lt;/h1&gt;

&lt;p&gt;这个标题看起来似乎是一句废话，谁不想自己将要在互联网传递的信息是加密的呢？但是事实并不是这样。互联网中传递的信息类型有很多种，我们谈到的信息指的是隐私信息，如用户名和密码或者是聊天记录等。
如今的web服务在应用层上大多采取http协议来进行通信，http协议是没有加密机制的，所有需要传递的信息都是明文传输。为了信息的完整性，保密性，正确性，我们需要以更安全的协议来保证通信的安全。&lt;/p&gt;

&lt;h1 id=&#34;使用密钥加密通信的内容&#34;&gt;使用密钥加密通信的内容&lt;/h1&gt;

&lt;p&gt;我们很容易想到使用对称加密的方式，客户端和服务端共享同一个密钥，客户端和服务端之间通信的时候使用此密钥来加密通信的内容，当加密的信息到达目的地的时候，需要使用相同的密钥解密才能读取出信息。
但是处于互联网中的通信双方彼此之间的距离是很远的，很难做到在线下交换需要共享的密钥。线上传输的方式也并不安全，所以人们对加密方式进行改进，使用公开密钥的方式进行加密。&lt;/p&gt;

&lt;p&gt;公开密钥加密属于非对称的加密方式。服务端发布一个公开密钥，这个密钥是所有的人都可以拿到的。客户端在想和服务端通信之前，用服务端发布的公开密钥加密要传输的数据。服务端保存了一个私有密钥，这个密钥只在服务端存在。当服务端接受到客户端发来加密的数据的时候，使用私钥进行解密以得到客户端想要传输的数据。这种非对称加密的方式改进了共享密钥中无法安全传递加密密钥的问题。但是，公开密钥也有一个缺点：客户端无法验证它得到的密钥就是其想通信的那个服务端发布的公开密钥。也就是说，公开密钥加密的通信方式存在着遭受中间人攻击的风险。中间可以伪装成合法的服务端与客户端进行通信。&lt;/p&gt;

&lt;h1 id=&#34;用证书来证明你的身份&#34;&gt;用证书来证明你的身份&lt;/h1&gt;

&lt;p&gt;既然公开密钥加密的方式的弊端是无法验证公开密钥的发布者是否合法。那么就需要借助第三方证书机构颁发的证书来证明其身份。第三方的证书机构很多，如果你遵循一定的协议，自己也可以成为一个证书的颁发机构。但是你建立的证书颁发机构是不受信任的。&lt;/p&gt;

&lt;p&gt;服务端会将自己想发布的公开密钥发送给证书机构，证书机构将此公开密钥集成到将要颁发的证书内。但这时大家可能会有疑问，我们如何得知客户端得到的这个服务端的证书是合法的呢？当然也是通过一定的验证机制。但是因为证书验证是否合法的过程也需要密钥的传输，问题好像就进入了无限的递归之中。所以，一般的浏览器在发布版本的时候，都会把受信任的证书机构的密钥集成在浏览器中。当客户端接受到了服务端的证书的时候，会使用该密钥来验证证书的完整性和合法性。如果验证通过，那么客户端将会得到两个信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;该证书是由合法的证书机构颁发的，收信任的&lt;/li&gt;
&lt;li&gt;随证书附带的服务端公开密钥也是合法的&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;https的通信过程&#34;&gt;HTTPS的通信过程&lt;/h1&gt;

&lt;p&gt;Https的通信分为两部分，第一部分是建立https连接，第二部分是在建立的安全连接上进行通信。https通信之所以安全是因为它使用密钥对通信内容进行了加密，对通信双方的身份进行确认，一旦通信的内容有被篡改会立刻知道。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o6sfmikvw.bkt.clouddn.com/bg2014020502.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;https链接的建立&#34;&gt;HTTPS链接的建立&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户端首先发送一个client hello的报文，主动与服务端建立https连接。报文内包含客户端支持的ssl协议的版本以及一些加密组件。最重要的是，报文内会包含一个随机数，用于之后的通信加密。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务端接收到客户端发来的client hello的报文之后，会返回一个server hello的报文，里面包括了服务端支持的ssl协议的版本以及通过客户端加密组件筛选出来的共同支持的部分组件，同样，报文内会包含一个随机数。之后，服务端会把带有公开密钥的证书发送给客户端。最后，发送一个server hello done报文表示第一次握手成功。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端接受到服务端发来的证书证书之后会对证书进行验证。验证成功之后会取出随证书携带的服务端公开密钥。此时客户端会再向服务端发送一个随机数，这个随机数已经是链接建立过程当中发送的第三个随机数，又称为pre-master-key。这个报文发送给服务端之后，通信的双方都各自拥有了三个随机数，他们会根据这三个随机数生成一个用于之后通信的对称密钥。然后，客户端还会给服务端发送一个ChangeCipherSpec报文来通知服务端接下来的通信加密方式和使用的密钥会改变。最后，客户端发送给服务端一个Finished报文，此报文包含了从建立连接开始一直到本次之前客户端发送报文的整体校验值。服务端会拿到这个报文的内容进行校验。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务端接收到客户端发来的报文之后，向客户端发送ChangeCipherSpec报文，表明之后服务端向客户端的通信当中通信加密的方式和使用的密钥也会发生改变。最后再发送一个Finished报文，代表https链接正式建立成功。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;https通信&#34;&gt;HTTPS通信&lt;/h2&gt;

&lt;p&gt;基于上面https链接的成功建立，接下来的通信过程中使用共享密钥的方式进行加密。整个通信过程都会受到ssl的保护。&lt;/p&gt;

&lt;h1 id=&#34;https混合了两种加密方式&#34;&gt;HTTPS混合了两种加密方式&lt;/h1&gt;

&lt;p&gt;https在整个通信的过程当中使用了两种加密方式。利用公开密钥加密传输以后通信过程当中使用的共享密钥。因为公开密钥加密方式属于非对称加密，加密和解密次数多了自然会影响性能。我们可以用公开密钥的加密方式来传输一个共享密钥，保证了共享密钥传输的安全性之后就可以使用共享密钥加密来传输数据，从而提高了性能。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>RabbitMq的数据持久化</title>
      <link>http://littledriver.net/post/2017/01/03/rabbitmq%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Tue, 03 Jan 2017 10:10:25 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2017/01/03/rabbitmq%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      
        <description>&lt;p&gt;我们一般在异步系统的实现中，选择使用消息队列.其中一个比较重要的原因就是担心数据储存在内存中会因为物理上的影响而丢失。消息队列中都有使消息持久化的机制。本次我在项目中应用rabbitmq的时候，也有消息持久化的需求，结合实际经验，介绍一下rabbimq中消息持久化的原理。&lt;/p&gt;

&lt;h1 id=&#34;为什么需要持久化&#34;&gt;为什么需要持久化&lt;/h1&gt;

&lt;p&gt;一般来说，异步的系统在处理某一个任务的时候，都不会一次性将任务当中所有的逻辑处理完。很多时候会因为服务重启，优先级高低，甚至是硬盘损坏等原因而影响了任务的正常运行。既然有中断，就证明处理中的任务会丢失。如果不对消息持久化的话，服务重启之后可能就忘记了之前处理过但是没处理完的任务，导致了系统中有很多的垃圾任务存在。一个基本的异步系统是需要在服务遇到问题重启之后，将之前未完成的任务重新加载继续执行的。&lt;/p&gt;

&lt;p&gt;诚然，这种功能可以通过数据库来实现。但是，一方面利用数据库重新实现一个消息队列的时间较长，功能不完善，还有一个就是，异步系统中任务数量一旦增多，优先级和并发度也是需要我们考虑的。综合来讲，使用rabbitmq这种消息队列是非常适合的。&lt;/p&gt;

&lt;h1 id=&#34;rabbitmq消息持久化三要素&#34;&gt;rabbitmq消息持久化三要素&lt;/h1&gt;

&lt;h2 id=&#34;持久化的队列和交换器&#34;&gt;持久化的队列和交换器&lt;/h2&gt;

&lt;p&gt;rabbitmq所在的服务器可能会因为各种情况而重启，如果不做设置的话，重启前建立的交换器和队列在重启后都会消失，不会重新建立。在创建队列和交换器的时候，可以设置durable的属性为true，即可实现队列和交换器的持久化。每次rabbitmq因故重启的时候，都会重新创建这些队列和交换器，而不需要我们再主动创建。&lt;/p&gt;

&lt;h2 id=&#34;持久化的消息投递模式&#34;&gt;持久化的消息投递模式&lt;/h2&gt;

&lt;p&gt;现在我们有了持久化的队列和交换器，如果想实现消息持久化的话，需要将我们投递的消息也改成一种“持久化的模式”。在send消息的时候，将消息的投递模式设为常数2，此时该消息被标记为持久化的消息。&lt;/p&gt;

&lt;h2 id=&#34;投递消息到持久化的队列和交换器中&#34;&gt;投递消息到持久化的队列和交换器中&lt;/h2&gt;

&lt;p&gt;有了持久化的消息，队列，交换器，现在要做的就是将持久化的消息投递到持久化的交换器，最终达到持久化的队列。如果持久化的消息投递到了非持久化的队列或者交换器，很有可能因为rabbitmq重启而导致丢失。&lt;/p&gt;

&lt;h1 id=&#34;消息持久化的实现&#34;&gt;消息持久化的实现&lt;/h1&gt;

&lt;p&gt;持久化消息在被发送到持久化的交换器之后，消息的相关信息会被写入一个持久化的日志文件里，这个日志文件是存储在硬盘的。只有这个消息被写入了这个日志之后，你的发送消息的操作才会得到响应。消息到达队列之后，如果在未消费之前，rabbitmq重启，此时队列和交换器都会重新自动建立，然后读取持久化日志中的消息，重新插入到相应的队列或交换器中。正常被消费掉的消息在持久化日志里面的记录会被标记为待收集处理的状态，这里的正常消费是只消息被拿走处理并且被ACK掉的。&lt;/p&gt;

&lt;h1 id=&#34;最后的手段&#34;&gt;最后的手段&lt;/h1&gt;

&lt;p&gt;如果你觉得有了上面的手段就可以保证消息肯定不会丢失，那确实是为时过早了。根据上面提供的方法，你是否注意到，在消息写入到持久化日志之前如果出现异常，是不是也会出现消息丢失的情况呢。所以说，最靠谱的保持消息不丢失的办法就是，在消息没有被正常保存到持久化日志之前通知消息的生产者，让它重发一遍不就行了么？直到消息真正的被持久化起来。&lt;/p&gt;

&lt;p&gt;rabbitmq在信道这一层级为我们提供了一个发送确认的模式，当我们使用的信道开启了这种模式的时候，消息在到达了持久化队列并且成功写入了持久化日志之后会给消息的生产者发送一个“确认接受”的消息，生产者接受这个消息之后可以根据自定义的回调函数才执行一些逻辑。同样，如果消息没有被正确的投递或者持久化，rabbitmq也会发送一个nack的消息给生产者，代表这个消息已经丢失了，可以在相应的回调函数中来决定是否要重发这条消息。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Review 2016</title>
      <link>http://littledriver.net/post/2016/12/29/review-2016/</link>
      <pubDate>Thu, 29 Dec 2016 20:58:59 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2016/12/29/review-2016/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;我的一生，是抗争的一生。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;review-plan&#34;&gt;Review Plan&lt;/h1&gt;

&lt;p&gt;整个第四季度都在忙，今天终于有空能够好好总结一下这即将过去的一年。仔细想想自己还有几天就要跨入24岁的高龄，不由得虎躯一震，感叹时光飞快。话不多说，来看看我今年年中的时候给自己制定的这一年的规划吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xj54b.com1.z0.glb.clouddn.com/year.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;坚持记账，规范用钱习惯。这一个目标从毕业到目前为止贯彻的还是比较不错的。无意外情况，每个月都能够存下4000块，小金库目前余额12k。之所以制定这条目标的原因，并不是要去尽力的省钱，而是如目标中所写，要规范自己的用钱习惯，看看自己一个月来的工资都花到了什么地方。半年来下，几个花销比较大的项目：吃，书，电子产品。我自己一向对吃的东西要求较高，每个星期酸奶+牛奶要喝很多，水果和零食也比较多，算是恩格尔系数比较高的人群。书这半年买了很多，但是仍然是买书如山倒，读书如抽丝。电子产品，这半年新添了一个BOSE25的耳机，一台PS4，然后又买了几个PS4上面的游戏。总体来说，没有不理智的消费，这条目标完成度我给自己打95分。&lt;/li&gt;
&lt;li&gt;坚持健身，减重130。定这个目标的原因是因为过年的时候检查身体，发现自己有轻微的高血脂，体重也达到了150斤。觉得身体健康不能忽视，第三季度的时候，健身比较多，饮食上也控制的不错，体重降到了140斤。但是第四季度，疯狂加班三个月，健身几乎没有了。下一年第一季度要继续努力。无论是工作还是梦想，首先都要有一个好的身体，身体没了什么都没了。这条目标完成度我给自己打70分。&lt;/li&gt;
&lt;li&gt;学会游泳。这个目标制定的初衷和上一条一样，为了保持身体健康，第三季度游泳较多。成功学会了蛙泳。第四季度很少去游泳，给自己打85分吧。&lt;/li&gt;
&lt;li&gt;学习数据库的操作和实现，mongo，redis。很遗憾，这条目标几乎是没有完成。我反思了一下，一个是工作太忙，导致我几乎没有自己的时间去学习。另外一个原因可能是我还是有一些时间没有利用起来。这条目标的完成度我给自己打0分。&lt;/li&gt;
&lt;li&gt;对golang有更深入的了解。这半年来，我在编写golang代码的时候，是非常注重代码风格的。至于其他方面，确实没有了解深入，甚至一个标准库的源码都没有看过。一些高级的用法也还没有学会。这条目标的完成度我给自己打50分。&lt;/li&gt;
&lt;li&gt;读完书单上的书。ok，既然说到读书，就来看看我给自己拉的书单吧。&lt;img src=&#34;http://7xj54b.com1.z0.glb.clouddn.com/book.png&#34; alt=&#34;&#34; /&gt;cdn技术详解只看了2章，软技能-代码之外的生存指南是黄总所赠，只看了40%，go语言圣经看了15%，go源码分析0%， 图解http协议100%， go web编程%0， 算法第四版只看了20%，csapp和apue 0%。总体来说，完成度非常低，客观原因确实没有太多的时间，主观上给自己定的目标过高了。在计划17年的读书计划时要量力而行才是。这条目标的完成度给自己打40分。&lt;/li&gt;
&lt;li&gt;睡觉前不看手机和电脑。这一条是因为有一段时间，觉得自己睡了很久但是非常疲劳，所以决定改善一下睡眠习惯。大概坚持了一个月吧，就放弃了。完成度给自己打30分。&lt;/li&gt;
&lt;li&gt;学习python。完成度是0%。恩，一个是中途觉得自己定这个目标是太贪心了，还有一个就是觉得应该先把golang玩熟。平时也没有找到合适的project来练习，所以完成度不好。&lt;/li&gt;
&lt;li&gt;复习数据结构知识。这一条是我感到最遗憾的，这半年我是跟了coursera上面的普林斯顿大学的算法第四版的公开课，目前还是只完成第第二周的大作业和课程。感受较深的还是，学习算法需要一定的时间来保证，断断续续其实很难有所收获。这一条目标会移动到下半年继续完成。目前的完成度，20%吧。&lt;/li&gt;
&lt;li&gt;在linux下熟练工作。恩，怎么说呢，这个目标当初定的也比较飘。没有把目标实体化到可以做的地步。本来想学习一下vim和shell脚本的使用，但是这两样都没有完成。这个目标仍然是需要继续努力的，但是在下半年的计划中，要指定的更加细化一点才对。完成度给自己打30分。&lt;/li&gt;
&lt;li&gt;学习韩语，流利交流。好吧，我承认这个目标是为了女朋友定的。女朋友家里和她自己都是习惯用韩语交流的，恩，既然要成为一家人，还是要在这上面多做努力才是。期间和女朋友学过几次，但是都因为不太认真，中途放弃了。完成度为0分。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;恩，实话说，之前半年的计划完成的并不是很好。尤其是技术上和读书上的计划，被工作占据的时间太多，一定程度上影响了计划的完成。不过也有自己的原因，确实没有平衡好学习和工作。计划的制定上还是犯了很多错误，比如没有考虑到自己的实际情况，还有就是某些计划太飘了，这样到年终也不好去衡量到底完成了没有。指定明年计划的时候要注意一下。&lt;/p&gt;

&lt;h1 id=&#34;review-work&#34;&gt;Review Work&lt;/h1&gt;

&lt;p&gt;这一年的工作基本都是在七牛云。2月末从猎豹移动离职，正式从PC端转向服务端。3月和4月，一个半月的时间主要是在适应团队和工作环境，负责了cdnspider的开发和维护，但是完成的并不是很好。&lt;/p&gt;

&lt;p&gt;6月份毕业之后，离开学校，正式踏入社会，成为了一名码农。所在sophon小组负责七牛云cdn项目管理系统的开发和维护。贴一部分工作记录，review一下。
&lt;img src=&#34;http://7xj54b.com1.z0.glb.clouddn.com/work1.png&#34; alt=&#34;&#34; /&gt;
整体看来，这半年的工作还是非常，非常，非常饱和的。尤其是第四季度，9 11 6了2个月，身体和精神上都收到比较大的考验。不过，劳累的同时也确实学到了很多。总结一下，这半年来主要完成了以下几个事情。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接入CDN提供商，开始了解并熟悉cdn相关业务，对golang语言的使用起到了一定的锻炼作用。期间因为做事方法不对，走了很多弯路，这个项目完成之后，给自己也定下了一个死规矩：万事先想好再写代码，一个项目的完成，99%的时间都是在思考，想清楚之后，%1的时间即可将自己的想法实现出来。&lt;/li&gt;
&lt;li&gt;为cdn管理系统接入新版缓存规则。主要任务是推动融合的9家厂商适配新版的缓存规则。自己在这个项目中不但是其中三家厂商的负责人，需要在代码上亲自完成适配过程。同时还需要和其他几位同事合作，推动他们加快其负责厂商的新缓存适配。做这个项目的过程中，我慢慢明白了，程序员的工作内容不只有代码，还需要良好的沟通技能，以及强大的责任心，甚至是高效的做事方法。每一个项目都有自己最终的一个目标，作为这个项目的负责人，我有责任和义务去推动它，直至完成。&lt;/li&gt;
&lt;li&gt;域名配置的标准化操作。主要任务是负责校准管理系统本地的域名配置和厂商的域名配置不匹配的地方。如本地的域名防盗链配置和cdn厂商的不一样，此时就应该以厂商为标准，校准本地数据库中的配置。在这个项目中，第一次接触了mongodb，非关系型的数据库。由于大学和第一份实习都是WIN平台下的，数据库只接触过sql server。而且操作的都是线上的数据，整个过程还是比较紧张的，怕误操作导致一些线上的事故。最终还是有惊无险的完成了这个项目，也体验了一把”洗库“的”快感“。从连mongo的查询语句都不会写，到后来也能够熟练操作，是一个从0到1的过程。但遗憾的是，最终和其他同事配合的不太好，清理工作的实际效果并没有那么大。&lt;/li&gt;
&lt;li&gt;中间源镜像存储。主要的任务是接入中间源的镜像存储以及源站的独立。这是我第一次接手的一个非常紧急的需求，时间紧，东西虽然做出来了，但是离上线的程度还有一定的差距，最终导致了项目延期，花费了好多时间来补之前因为图快而埋下的坑。反思之后，还是觉得自己的工作方法有问题，把问题都归结到时间少上面是不对的。工作中很多时候都需要在有资源限制的条件下去完成一件事，对手中资源的利用以及目标的拆解和明确还做的非常不到位。&lt;/li&gt;
&lt;li&gt;cdn管理系统重构。系统重构应该是今年我做的最大的一个项目，整个第四季度都是在围着他转，疯狂的加班了2个月。在这个项目中，我也负责了相对来说比较重要的几部分：整体框架的设计和实现，删除接口的实现，四家cdn厂商服务的设计与实现。不得不承认，虽然这个过程是很痛苦的，但是确实得到了不小的锻炼。尤其是在框架的设计和实现上，第一次用到了第三方的消息队列，第一次去试着设计一个小型的分布式系统，第一次非常正式的去整理项目的技术文档。在这个项目中有很多个第一次，让我得到了非常大的成长，无论是技术上的，还是工作技能上的。最大的体会有以下几点：a. 文档很重要，思考很重要，任何事情都需要想清楚在做。而文档就是为了在实施的过程当中指引着我们，不要偏离原来的航道。并且，要写出一个优秀的技术文档是非常非常难的。框架的设计和文档的编写我几乎花了一个多星期的时间，但是现在看来，这一切都是值得的。编程，有的时候想法比代码更重要。b.项目周期长，难度大，我仍然不能很好的控制住自己的情绪，会出现烦躁不安，易怒的情况。这也是一直让我头痛的地方，这半年努力的在改正，但是仍然没有完全控制住。c. 一个人的强大是没用的，现实就是需要我们去照顾一些能力较弱的同伴，毕竟大家在一条船上，我划的再快也是没用的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总的来说，这一年工作上面收获还是蛮多的，唯一让我遗憾的就是，工作仍然在吞噬着我90%以上的时间。我没有太多的时间去总结和提升自己，成长并不一定就是无休止的工作，对于新人来讲，总结和反思更加重要。长时间如此，只能沦为工作机器，下一年在平衡生活和工作上面还要多做功能才是。&lt;/p&gt;

&lt;h1 id=&#34;review-me&#34;&gt;Review Me&lt;/h1&gt;

&lt;p&gt;自己这半年思想上波动比较大，年底也是做了一个比较大胆的决定，对生活和工作都有一些新的理解。感受最深的几点如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;绝不以自己的标准去要求别人，可以给出建议，但是不会强迫对方改正。但是我能改变的是我自己，严于律己，保持高度的自律是不可动摇的。&lt;/li&gt;
&lt;li&gt;要努力控制住自己的情绪，不然其实还是会失去很多机会的。&lt;/li&gt;
&lt;li&gt;做任何事情之前都要多想，想好这件事情应该怎么做，到底要做成什么样。工作和追求技术是两回事，追求技术可以细思慢想，但是工作确实需要在有限的时间和有限的条件下完成目标。以最直接最简洁的方式完成目标，自己的工作效率才会有一个大的提升。&lt;/li&gt;
&lt;li&gt;对技术应该继续深入，迄今为止，我的计划仍然是两年之内不会考虑任何技术之外的事情，我需要在工作的前几年来沉淀自己的技术。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;恩，对于自己来说，暂时想到的就是这样。叹一口气，感觉又是一年过去了。实话实说，毕业之后的日子过的一直很累，也诚惶诚恐。生怕自己一停下来，就变成了”api程序员“，工作几年之后却没有相应年限的能力。身边一些鲜活的例子也让给我敲响了警钟，一句话，在技术的道路上落后就要挨打。&lt;/p&gt;

&lt;p&gt;未来的一年里，除了在工作上要更上一层路，软实力上也要注意锻炼了。年龄越大，工作的时间越久，可能以后需要的相关能力也就越多，早做准备，才能以防万一。趁着元旦假期也应该好好想想，自己下一个半年的计划了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>初识RabbitMq</title>
      <link>http://littledriver.net/post/2016/12/17/%E5%88%9D%E8%AF%86rabbitmq/</link>
      <pubDate>Sat, 17 Dec 2016 15:11:59 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2016/12/17/%E5%88%9D%E8%AF%86rabbitmq/</guid>
      
        <description>&lt;h1 id=&#34;rabbitmq-amqp&#34;&gt;RabbitMq &amp;amp; AMQP&lt;/h1&gt;

&lt;p&gt;rabbitmq是一个实现了AMQP(高级消息队列协议)的消息队列系统。消息队列使用消息将通信双方链接起来，使得消息通过像rabbitmq这种消息代理服务器在不同的程序之间进行路由。这就像是在通信双方之间放置了一座邮局一样。rabbitmq不是对AMQP协议的唯一实现，与其说我们在学习rabbitmq，倒不如说我们在学习AMQP，一种标准的消息通信协议。&lt;/p&gt;

&lt;h1 id=&#34;rabbitmq中的路由模型&#34;&gt;RabbitMq中的路由模型&lt;/h1&gt;

&lt;p&gt;rabbitmq作为一个邮局的角色，将通信的双方链接了起来。通信双方生产者和消费者的身份可以随意的变换，对于生产者和消费者来说，他们都不知道彼此的存在。
生产者生产消息发送给rabbitmq的服务器，消费者接受rabbitmq服务器发送的消息进行消费。通过rabbitmq服务器路由的消息通常分为两部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;消息主体内容(以二进制形式存储)&lt;/li&gt;
&lt;li&gt;消息标签&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;主体内容不用解释，消息标签也很容易理解，它相当于有这条消息的一个描述，会决定这个消息最终的去向。&lt;/p&gt;

&lt;h2 id=&#34;信道&#34;&gt;信道&lt;/h2&gt;

&lt;p&gt;想要发送和接受消息，通信双方首先都需要与rabbitmq服务器建立一条TCP连接。一旦TCP链接打开，我们就可以在其上建立一条AMQP信道。信道是建立在真实的TCP链接之上的，以后众多的AMQP命令都是通过信道来完成的。之所以不直接用TCP链接，是因为多线程频繁发送AMQP命令的时候
，如接受消息，发送消息等。都会在短时间建立大量的TCP链接，首先这对系统的资源是一个极大的浪费，其次，线程的调度会使得TCP链接频繁的建立和关闭，这势必会影响到消息通信的性能。
我们的目标是在不影响性能和使用较少资源的前提下，满足多线程工作对于链接的需求。线程启动之后，在TCP连接上建立属于自己的AMQP信道，在不影响性能的前提下也保证的了通信的私密性。并且
，在一条TCP链接上，一秒可以建立成千上万个AMQP信道，对于高并发系统的多线程调度是完全能够满足的。&lt;/p&gt;

&lt;h1 id=&#34;amqp的协议模型&#34;&gt;AMQP的协议模型&lt;/h1&gt;

&lt;p&gt;AMQP协议栈中，有三个不可或缺的部分，以自上而下的顺序来展示，分别是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;交换器&lt;/li&gt;
&lt;li&gt;绑定&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;

&lt;p&gt;队列是最接近消费者的部分，也是rabbitmq中消息传递的终点。队列核心的作用有两个:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;存储未派发的消息&lt;/li&gt;
&lt;li&gt;派发消息给相应的消费者&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一条消息从生产者发出，首先要发送到交换器，交换器根据特定的规则将消息发送给相应的队列。此时消息存储在队列中。
如果当前有消费者订阅了该队列，那么就将消息派发给消费者，否则继续保存此消息。消费者订阅队列的方式也有以下两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单次订阅： 通过AMQP提供的basic.get方法，每当想要处理消息的时候，都订阅一个队列，接收到消息之后取消订阅。等到再次需要消息的时候，与队列重新建立订阅关系，获取消息。&lt;/li&gt;
&lt;li&gt;持续订阅： 通过AMQP提供的basic.consume方法，订阅一个队列，自动不断的接收队列派发的消息。直到主动取消与队列的订阅关系为止。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过上面的描述，很容易看出，单次订阅是有需要的时候再去消息，消费者是主动的。而持续订阅消费者是被动的，要一直等待接收队列中的消息。
但是切记不要把单次订阅放在死循环中来模拟持续订阅的效果，这将会对rabbitmq的性能造成极大的影响。&lt;/p&gt;

&lt;p&gt;队列中的消息派发给消费者之后，并不会立刻将这个消息从队列中删除，而是会等消费者回复一个确认的消息来确定此消息已经被成功接收了。这个时候，rabbitmq的队列才会放心的将此消息移除。rabbitmq在等待某个消息的确认信息之前，会一直在队列保存着这个消息。这样一来即使消费者因进程崩溃等原因断开了与mq的链接，
rabbitmq会认为该消息没有被成功派发，进而会派发给其他订阅这个队列的消费者。假设没有这种机制，队列将消息派发出去之后并不知道该消息是否派发成功就删除它，那么，
如果此时消息派发失败，这个消息就被彻底丢掉了。这种成功接收消息的确认机制能够保证，队列中任意一个消息都会被消费者成功处理。&lt;/p&gt;

&lt;p&gt;上面说的情况，是建立在队列派发的消息正是消费者需要处理的消息的前提下。假设，消费者并不想处理队列派发过来的消息，
通常有两种方式可以选择。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在向rabbitmq发送确认信息前，主动断开链接。这个时候，rabbitmq会认为此消息没有被成功接受，会派发给其他订阅的消费者&lt;/li&gt;
&lt;li&gt;调用AMQP提供的Reject命令，来拒绝接受此消息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要说明的是，在调用reject命令的时候，有一个叫做requeue的布尔型参数需要设置。若该值为true，那么被拒绝的消息会重新回到队列中等待被派发。
如果为false，那么该消息将会被发送至一个“死信”队列中。该队列中的消息都是一些被拒绝且不需要继续处理的。&lt;/p&gt;

&lt;p&gt;要按照规则使用队列之前，首先需要创建队列。在AMQP中，消费者和生产者都可以创建队列，但是同一个队列只能被成功创建一次，另外一次的创建就是无效的，但是不会报错。
对消费者来说，如果已经在某个信道上订阅了某个队列，那么在对这个队列取消订阅之前，不得再创建新的队列。创建队列的时候会需要提供一个队列的名称，如不提供则rabbitmq会为你指定一个默认的名称。至于到底是由生产者来创建队列还是消费者来创建队列，最好的办法是消费者和生产者都创建。首先，创建两次并不会造成什么不利的影响，因此猜测创建队列的操作应该是幂等的。
其次，无论是让谁单独来创建，都有可能在消息从交换器发送过来的时候，队列还没有创建成功。如果出现这种情况，那么消息就会被丢弃。综合上面两个因素，生产者和消费者都做创建队列的工作比较稳妥。&lt;/p&gt;

&lt;h2 id=&#34;交换器和绑定&#34;&gt;交换器和绑定&lt;/h2&gt;

&lt;p&gt;有了交换器和绑定，他们和队列在实现了rabbitmq中的消息路由框架。一个完整的消息传递过程如下：生产者生产消息，消息由主体内容和标签构成。生产完毕后，将消息发送给交换器。交换器接收到消息后，
会根据消息的标签来决定将其投放给哪一个队列。这个标签也被称为路由键。队列需要携带特定的路由键绑定到交换器上。如果消息携带的路由键和队列绑定在交换器上的路由键相匹配，那么此时该消息就会被发送给这个队列。
否则，消息中的路由键没有和任何一个队列的路由键匹配，该消息将会被丢弃。投放到队列中的消息会被订阅该队列的消费者取走处理。&lt;/p&gt;

&lt;p&gt;之所以使用这么复杂的方式，将生产者的消息送到消费者的身边。除了能够通过交换器和路由键实现多样化的通信方式之外，还有的一个好处就是，通信的双方都不需要在意对方的任何状态。他们交互的对象都是rabbitmq，这样一来
，即使开发过程中出现消费者和生产者的更换，或者使用不同的语言来实现消费者和生产者，切换起来都是无障碍的，非常方便。在代码层面上，生产者和消费者也就彻底的解耦了。&lt;/p&gt;

&lt;h3 id=&#34;交换器&#34;&gt;交换器&lt;/h3&gt;

&lt;p&gt;交换器的类型决定了消息通信的使用场景，大致分为以下几类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;direct&lt;/li&gt;
&lt;li&gt;fanout&lt;/li&gt;
&lt;li&gt;topic&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;direct&#34;&gt;direct&lt;/h4&gt;

&lt;p&gt;direct交换器的作用非常简单：只要消息的路由键和队列的路由键匹配，那么就将消息投放到相应的队列中。rabbitmq服务器会自动实现一个direct类型的交换器。&lt;/p&gt;

&lt;h4 id=&#34;fanout&#34;&gt;fanout&lt;/h4&gt;

&lt;p&gt;见名知意，fanout类型的交换器即为扇形交换器。他会将收到的消息投放给所有绑定到该交换器上面的队列。这种特性能够帮助我们对同一个消息采取多种的处理方式。&lt;/p&gt;

&lt;h4 id=&#34;topic&#34;&gt;topic&lt;/h4&gt;

&lt;p&gt;topic交换器和其他几种类型最大的不同就是在路由键上可以使用通配符，以此来实现不同来源的消息可以被投放进一个相同的队列。像direct，一个消息再发给交换器的时候，
它自身携带的路由键就已经决定了它被投递的队列是那个，队列上的路由键也决定了它只能够接收带有同样路由键的消息。topic在队列的路由键上支持两种通配符&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;* ： *号代表可以匹配一个特定位置的0个和多个字符。有*的路由键里，.号被当做是分隔符。&lt;/li&gt;
&lt;li&gt;#： #号代表全匹配，此时.号被当做是普通字符。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;举例来讲，如果队列绑定交换器时指定的路由键是*.abc.com那么，该队列将会接受一切路由键以.abc.com为后缀的消息。通过上面的阐述，我们能够了解到。
一个完成的消息路由过程，需要消息，交换器，队列互相合作。队列要携带特定的路由键绑定交换器才会收到消息。一个消息最后被投放到哪个，或者哪几个队列，是由交换器的类型和其路由键来决定的。&lt;/p&gt;

&lt;h1 id=&#34;vhost-多租户模式的虚拟主机与隔离&#34;&gt;Vhost：多租户模式的虚拟主机与隔离&lt;/h1&gt;

&lt;p&gt;vhost是AMQP中的一个概念，vhost对于AMQP就相当于虚拟主机对于物理主机一样。都是在逻辑上实现多实例的分离，使得我们可以在同一台rabbitmq服务器上启动多个vhost，来为多个应用程序服务。
一方面，vhost严密的隔离性使得我们不需要担心多个应用程序之间消息数据的混乱以及交换器和队列的命名冲突问题，还有一个就是减少了我们管理多个rabbitmq的成本。一个vhost就相当于一个小的rabbitmq实例，
除了在链接rabbitmq的时候需要指定特定的vhost名称，其余没有特别的使用限制。而且，在没介绍vhost之前，我们就已经在使用了，只不过使用的是默认的vhost,它的名称是&amp;rdquo;/&amp;ldquo;。&lt;/p&gt;

&lt;p&gt;vhost必须在连接的时候就指定。例如，当我们要使用amqp协议链接rabbitmq时，会建立一个这样的url，amqp://user:passwd@localhost:port/vhost。当我们要链接rabbitmq的时候，如果我们在url中指定了vhost，那么我们就只能访问这个vhost中的队列和交换器。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>乐观锁和悲观锁</title>
      <link>http://littledriver.net/post/2016/11/27/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</link>
      <pubDate>Sun, 27 Nov 2016 20:59:27 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2016/11/27/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;本科的时候学习过数据库，但是只限于书面上的东西，并没有过多的实践。而且我依稀记得，当时教学的重点是在关系代数和数据库三大范式这两方面。
学完之后，晕晕乎乎，最后只记得自己学会了写sql语句。最近在工作中遇到了处理数据库并发性访问的难题，组里的前辈教会我用golang实现了悲观锁和乐观锁。虽然结合现实工作中的场景能够了解为何需要这两个东西。
但自己本身对乐观锁和悲观锁还是第一次听说(MD,好菜~~&lt;del&gt;(&amp;gt;_&amp;lt;)&lt;/del&gt;~~)，觉得学习新东西不应该只停留在会用的层面上，要尝试理解一下背后的原理。So，写此博文，做一记录，同时也提醒自己，该补补数据库系统的知识了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;数据库的并发控制&#34;&gt;数据库的并发控制&lt;/h1&gt;

&lt;p&gt;简单来说，数据库中并发控制的任务就是确保在多个事务同时存取同一份数据的时候，能够不破坏事务的统一性，隔离性以及数据的一致性。
乐观并发控制和悲观并发控制是实现并发控制的两种主要技术手段。将这两种思想进行延伸，就得出了我上面所说的，乐观锁和悲观锁。
乐观锁和悲观锁其实并不局限于关系型数据库中，非关系型数据库同样可以实现这两种锁。本质上来讲，乐观锁和悲观锁都是处理并发控制问题的一种思想。&lt;/p&gt;

&lt;h1 id=&#34;悲观锁的定义-以关系型数据库为例&#34;&gt;悲观锁的定义(以关系型数据库为例)&lt;/h1&gt;

&lt;p&gt;在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务操作的数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。
悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。&lt;/p&gt;

&lt;h1 id=&#34;场景1&#34;&gt;场景1&lt;/h1&gt;

&lt;p&gt;众所周知，数据库的增删改查操作是原子操作。何为原子操作？说白了就是你在对一份数据做增删改查操作的时候，同一时间肯定只会有一个操作作用于这条数据上。不会出现丢失更新的情况。
实际应用的过程当中，我遇到过下面的情形：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我需要先读数据库中id为1的一条数据，在代码中对取出的这份数据有所更改。最后把我修改后的这份数据写回数据库，以达到对id为1这条数据更新的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据上面的描述我们可以知道，读，改，更新，这三个操作是捆绑在一起的，只有这三个操作都完成之后，才能够说明他们对id为1的这条数据处理完成了。所以，这三个操作在一起应该是一个原子性的操作。换句话说，在对id为1的这条数据执行那三个操作的时候，中途不得有人再去碰那条数据，无论是读写。
读的话可能会造成脏读的现象，写的话可能会造成丢失更新的情况。无论是同一个进程中的多线程，还是同一个服务部署在多台服务器上的多进程场景，都会出现上面所说的那种情况。
为了处理这样的问题，我们很容易想到的就是，为数据库中的每一条数据都加上锁。任何进程或者线程想要操作某条数据的时候，都必须通过加锁的方式来得到这条数据的操作权限。当对这条数据的操作完成之后，要通过解锁的方式释放掉这条数据操作权限，以便其他进程和线程来使用。&lt;/p&gt;

&lt;p&gt;悲观锁思想的特别之处在于它对数据的修改是持悲观态度的，他假定脏读和更新覆盖这两个问题是有很大概率会发生的，所以对每条数据都加了锁。并且在任意一条数据处理的过程中，这条数据都是处于被锁定的状态。&lt;/p&gt;

&lt;h1 id=&#34;悲观锁的实现&#34;&gt;悲观锁的实现&lt;/h1&gt;

&lt;p&gt;悲观锁的实现，既可以依靠数据库的排它锁机制，也可以自己实现一个“排它锁”来保证数据访问的排他性，这里只介绍实现悲观锁的主要工作流程，至于用什么方式来实现，各位读者可以根据自己的需求来决定。
（本人工作当中用的数据库是mongodb，是通过建立一个数据锁的collection来实现的。）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对任意一条数据操作前，都加上排他锁&lt;/li&gt;
&lt;li&gt;如果对每条数据加锁失败，说明获取此条数据的操作权限失败。此时，你可以选择设定超时时间进行等待，亦或是直接跑出异常&lt;/li&gt;
&lt;li&gt;加锁成功，则获取到对应数据的操作权限。在操作完成之后，需要解锁&lt;/li&gt;
&lt;li&gt;在某条数据正在处理期间，若有其他事务想要操作这条数据，都会等待解锁或者直接抛出异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;悲观锁的优缺点&#34;&gt;悲观锁的优缺点&lt;/h1&gt;

&lt;p&gt;悲观锁用比较极端的方式来保证了数据的一致性。但是服务运行的过程中，频繁对锁的操作会产生很多额外的开销。&lt;/p&gt;

&lt;h1 id=&#34;乐观锁的定义-以关系型数据库为例&#34;&gt;乐观锁的定义(以关系型数据库为例)&lt;/h1&gt;

&lt;p&gt;在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。他假设多用户并发的事务并不会互相影响，各自的事务能够在不产生锁的情况下处理只影响自己的那份数据。在更新数据的时候，都会
去检查该事务读取数据之后有没有其他的事务对数据作了修改。如果比较结果和之前所读取到的数据没变化，那么则可以正常更新数据。如果比较结果有其他事务修改了数据，则正在提交的事务会回滚。&lt;/p&gt;

&lt;p&gt;乐观锁的思想在于，他假设数据一般情况下不会出现冲突。所以也就不会对数据加锁。只有最后在提交对数据的更新的时候，才会去检测到底是否出现冲突。&lt;/p&gt;

&lt;h1 id=&#34;场景2&#34;&gt;场景2&lt;/h1&gt;

&lt;p&gt;同一条数据在并发环境中可能会被多个进程或者线程同时处理。假设目前有两个进程AB在同时处理一条数据data1，AB可能同时也可能先后拿到了data1，此时两个进程开始处理属于他们独立的两份数据，在处理期间互不影响。
当两个进程要处理完毕之后，需要更新data1。此时我们要求只有一个进程可以更新成功，如果不做限制，那么就又吃了并发的亏，造成了更新丢失的现象。&lt;/p&gt;

&lt;p&gt;上述场景是非常符合乐观锁的思想的。乐观锁只在最后提交数据更新的时候去检测data1是否与之前读取到的版本是一致的，如果发现有修改，就证明在此进程处理的过程中已经有其他的更新操作成功了，此时就不能够再去覆盖已经成功的修改了。&lt;/p&gt;

&lt;h1 id=&#34;乐观锁的实现&#34;&gt;乐观锁的实现&lt;/h1&gt;

&lt;p&gt;一般实现乐观锁的方式，是在每条数据内加上版本号。在读取数据的时候将版本号一起读出，在更新的时候，会先对比该数据的版本号看数据是否被修改过。如果没有，则将版本号+1，更新数据。否则放弃此次更新操作。需要注意的是，对比数据的版本号和更新版本号两个操作在一起必须是一个原子操作，mongo的update操作内部是保证了这一点，至于其他的数据库要想办法来实现这两个操作的原子性才可以。&lt;/p&gt;

&lt;h1 id=&#34;乐观锁的优缺点&#34;&gt;乐观锁的优缺点&lt;/h1&gt;

&lt;p&gt;乐观锁的锁操作较悲观锁少了很多，减轻了很多系统的开销。但无法避免脏读现象。&lt;/p&gt;

&lt;h1 id=&#34;到底该用哪个&#34;&gt;到底该用哪个&lt;/h1&gt;

&lt;p&gt;如果你的系统对性能要求较高，并且允许同一份数据的不同形态在多进程或者多线程的环境下运行，直到最后更新数据的时候再处理冲突的话。那么可以使用乐观锁。
如果你的系统对数据的一致性要求较高，只允许一份数据以一种形态运行在多个进程或者线程中运行。不但写的时候要避免冲突，读的时候也要防止脏读。那么可以使用悲观锁。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>三种基本排序算法</title>
      <link>http://littledriver.net/post/2016/11/09/%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 09 Nov 2016 19:36:42 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2016/11/09/%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;学习三种最基本的排序算法思想，文中代码已经经过大量测试。如发现有误，欢迎指正。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;选择排序算法&#34;&gt;选择排序算法&lt;/h1&gt;

&lt;h2 id=&#34;核心思想&#34;&gt;核心思想&lt;/h2&gt;

&lt;p&gt;如果以一个不含有重复元素并且元素个数为N的数组为排序对象的话，选择排序将从索引为0的数组元素开始，进行N趟排序，每趟排序都将确定一个元素是有序的。在进行第i趟排序的时候(i&amp;gt;=0)，待排序的元素为array[i],选择排序将会遍历a[i+1&amp;hellip;..N-1]的所有元素，找到i~N-1区间内的最小元素，然后和array[i]交换位置。每一趟排序，在寻找最小元素的时候，只是记录下当前最小元素的索引，直到本趟排序遍历结束才交换array[i]和找到的最小元素。当然，第i趟待排序的array[i]很可能就是当前最小的元素。&lt;/p&gt;

&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	void sort(int[] a) {
		for(int i = 0; i &amp;lt; len(a); i++){
			int min = i;
			for(int j = i+1; j &amp;lt; len(a); j++) {
				if (a[min] &amp;gt; a[j]){
					min = j;
				}
			}
			
			int temp = a[i];
			a[i] = a[min];
			a[min] = temp;
		}
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;性能分析&#34;&gt;性能分析&lt;/h2&gt;

&lt;p&gt;由上面的实现代码可以看书，选择排序最昂贵的操作是元素之间的比较。从索引为i的元素开始(i &amp;gt;= 0)，a[i]这个元素需要N-i-1次比较，依次类推，直到数组当中的最后一个需要排序的元素a[N-2],需要1次比较。由等差数列求合公式可知（1 + 2 + 3 + &amp;hellip; + N-1）= (N^2 - N)/2，所以选择排序的比较次数约为N^2/2。&lt;/p&gt;

&lt;h2 id=&#34;优点与缺点&#34;&gt;优点与缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;选择排序最大的优点就是交换数组当中元素的次数少，这一点是其他排序算法都不能够比拟的。由上面的实现代码我们可以看出，交换操作的次数受限于最外层的循环次数，也就是输入数据的规模。因为交换操作可以达到O(N)级别，是线性的。&lt;/li&gt;
&lt;li&gt;选择排序的缺点也很明显，上一趟排序并不能给下一趟排序提供任何的有效信息，每一趟排序都是独立的。设想一下，如果我们输入的数据是一个本身已经有序的数组，或者每个元素都相同的数组，这种情况下选择排序仍然会傻乎乎的一个个比较下去，不会做出任何的优化。但是正常来讲，数据的输入应该有排序算法有影响才是，倒序的数据花时间最长，正序的数据花时间最短。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;插入排序算法&#34;&gt;插入排序算法&lt;/h1&gt;

&lt;h2 id=&#34;核心思想-1&#34;&gt;核心思想&lt;/h2&gt;

&lt;p&gt;插入排序的思想也非常的简单。当我们对索引为i(i &amp;gt; 0)的元素array[i]进行排序的时候，认为array[0&amp;hellip;.i-1]区间内的元素是已经有序的。我们只需要倒序遍历0~i-1区间内的元素，找到一个array[i]合适的位置插入到那里即可。如果是以升序来排的话，从i-1一直遍历到0，发现比array[i]大的元素则记录下这个元素的索引为j，直到发现比array[i]小的元素或到达了数组的边界为止。然后，将array[j&amp;hellip;.i-1]区间内的元素均向后移动一位，把array[i]插入到索引为j的位置。&lt;/p&gt;

&lt;h2 id=&#34;实现-1&#34;&gt;实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	void sort(int[] a) {
		for (int i = 1; i &amp;lt; len(a); i++){
			int j = i;
			int tmp = a[i];
			for(int k = i - 1; k &amp;gt;= 0 &amp;amp;&amp;amp; a[k] &amp;gt; tmp; k++) {
				j = k;
				a[k + 1] = a[k];
			}
			
			a[j] = tmp;
		}
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;性能分析-1&#34;&gt;性能分析&lt;/h2&gt;

&lt;p&gt;由上面的实现代码可知，影响插入排序性能的操作插是移动数组内元素的次数以及元素之间的比较的次数。与选择排序不同，插入排序的性能和输入数据的有序性是有关的。假定输入的数组中元素不会重复。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最坏的情况：输入的数据是倒序的。从索引为1的元素开始比较，一直到索引为N-1的元素，移动数组元素的次数为，1+2+3+&amp;hellip;&amp;hellip;+N-1,约为N^2/2。并且每一次的移动都对应着一次比较，比较的次数也约为N^2/2。所以最坏的情况下，插入排序的时间复杂度应为O(1/2N^2).&lt;/li&gt;
&lt;li&gt;最好的情况：输入的数据都是有序的。这种情况下，排序过程是不涉及到元素移动的，只会做比较操作。从索引为1的元素开始直到索引为N-1的元素位置，一共比较了N-1次。所以，最好的情况下，插入排序的时间复杂度为O(N)级别。&lt;/li&gt;
&lt;li&gt;平均的情况：由上面两个分析结果可知。最坏情况下，插入排序的性能由移动次数来决定，因为移动伴随着比较，所以只算一遍，不叠加。最好的情况下，移动次数可以忽略不计，但是比较次数成了决定性能的唯一因素。所以，当处在平均的情况下时，应该有交换次数和比较次数共同来决定。平均状态下，每个元素都向后移动半个数组的长度，也就是移动(N-1)/2次，这样一来，规模为N的数组内的元素只有一半的元素可以移动，(N-1)/2 * (N/2),移动次数约为N^2/4。在这个过程中，有一半的元素不需要移动位置，单纯比较的次数应该也在N/2次。由于在计算时间复杂度的多项式内2次方为最高阶，所以平均状态下，插入排序的时间复杂度为O(1/4N^2)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;优点和缺点&#34;&gt;优点和缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;优点：在数组元素有序或者是部分有序的情况下，时间复杂度可以达到O(N)或者O(1/4N^2)级别。原始的数组中的元素有序性越强，则插入排序算法的优势就更明显。插入排序最大的优点其实就在于它能够快速的发现已经有序的元素，而不会再做其他的操作。&lt;/li&gt;
&lt;li&gt;缺点：在最坏的情况下和选择排序一样，都是O(1/2N^2)级别&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Ps: 其实在讨论上述两种算法的性能的时候，还有一个更重要的指标是数据的访问次数。在上面插入排序我给出的实现代码中可以看书，某趟排序中，在将待排序元素与其左侧元素进行比较的时候，并没有立刻交换他们的位置，而只是把较大的元素向后移动。这样一来就可以省去一半的数组访问操作。而比较操作和移动操作本质上来讲也就是对数组的访问。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;希尔排序-插入排序的升级版&#34;&gt;希尔排序&amp;mdash;插入排序的升级版&lt;/h2&gt;

&lt;h3 id=&#34;改进之处&#34;&gt;改进之处&lt;/h3&gt;

&lt;p&gt;希尔排序某种意义上来讲是对插入排序的一个升级，设想一下，在插入排序的过程当中，如果最小的元素是在数组的最右端的话，我们想把它移动到正确的位置就需要经过N-1次的移动，因为插入排序在移动数组元素的时候都是相邻元素之间的移动。依次类推，第二小的元素，第三小的元素。。。希尔排序通过改变移动元素之间的间隔，对不相邻的两个元素移动位置，因此在每一趟排序的时候，某个元素可能都会以跳跃的方式尽快的接近它最合适的位置，减少了这其中的移动次数，从而提高了排序性能。&lt;/p&gt;

&lt;h3 id=&#34;核心思想-2&#34;&gt;核心思想&lt;/h3&gt;

&lt;p&gt;希尔排序是对插入排序的改进，那么插入排序的瓶颈在哪里呢？就是输入数据的有序性，数据的有序性越高，插入排序算法就越快。想提高数据的有序性，肯定就需要通过一些列的操作来调整数据的顺序。普通的插入排序由于移动元素的步长为1，所以效率较低。希尔排序则选择了提高移动元素的步长，假设步长为h(1 &amp;lt;= h &amp;lt; N)，原始的输入数据就会被分为几个元素之间间隔为h的子数组。此时我们对间隔为h的子数组进行插入排序，子数组的元素较少，而且移动元素的步长也很大，因此速度也会很快,子数组的有序程度取决于我们选择的步长。随后，步长的值会依次递减，直到变为1为止。在这个过程当中，每个元素会以最小的代价向其最合适的位置逼近。整个数组也会变得越来越有序，直到移动元素的步长减为1.希尔排序便退化成插入排序，但此时的数组内元素的有序性已经很符合插入排序的要求了。&lt;/p&gt;

&lt;h3 id=&#34;实现-2&#34;&gt;实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;	void sort(int[] a) {
        int h = 1;
        int N = len(a);
        while (h &amp;lt; N / 3) h = 3 * h + 1;
        while (h &amp;gt;= 1) {
            for (int i = h; i &amp;lt; N; i++) {
                Comparable min = a[i];
                int pos = i;
                for (int j = i; j - h &amp;gt;= 0 &amp;amp;&amp;amp; less(min, a[j - h]); j -= h) {
                    pos = j - h;
                    a[j] = a[j - h];
                }

                a[pos] = min;
            }

            h = h / 3;
        }
	}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;性能分析-2&#34;&gt;性能分析&lt;/h3&gt;

&lt;p&gt;希尔排序的性能主要取决于步长h的选择，由上面的分析可知，步长h是一个递增的序列，从1开始。那么如何构造这个递增的序列，肯定会有一个响应的数学公式。对这个递增序列的探讨太过复杂，涉及到的数学知识比较多，我在此就不深追究了。我们的重点是学习算法的思想，而不是过度的拘泥于其中的数学证明部分。&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;以上就是我对三种基本排序算法的分析和实现。大学的时候学过数据结构，但是现在回想起来，当初学的可能很机械。不但是数据结构，计算机领域中的所有知识都是一个不断进化的过程，我们要搞清楚它为什么要优化，不优化有什么问题，优化了又能解决多少问题。凡事多问自己几个为什么，用反证法的思想去学习计算机领域的知识可能会让我们对知识本身有更加深刻的理解。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>程序员，你的工作不只有代码</title>
      <link>http://littledriver.net/post/2016/11/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%B8%8D%E5%8F%AA%E6%9C%89%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 04 Nov 2016 07:48:24 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2016/11/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%B8%8D%E5%8F%AA%E6%9C%89%E4%BB%A3%E7%A0%81/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;代码不是工作的全部，工作也不是生活的全部&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我还在大学的时候，我对以后的工作的认知可以用一句话来概括：技术好的吃肉，技术不好的吃屎。计算机虽然是一个专业性和技术性较强的行业，
但是彼时的我太过迷信于技术，思想偏激，导致在第一份工作当中走了很多的极端。我想，很多计算机专业的学生可能在学校的时候，甚至是刚刚实习的时候都和我有一样的想法：工作就是写代码，代码写的牛逼了，自然什么好事就都找上门来了。然而，如今工作近一年，我对工作和技术以及生活，都有了与之前截然不同的认识。&lt;/p&gt;

&lt;h1 id=&#34;工作的核心是解决问题&#34;&gt;工作的核心是解决问题&lt;/h1&gt;

&lt;p&gt;仔细想想，我们工作的内容既不是无休止的加班写代码，也不是每天疲惫的奔波于大小会议之间，而是解决我们自身遇到的，公司遇到的，用户遇到的各种问题。如果要给一个码农的工作能力打分的话，要关注的绝对不是他代码写的多牛逼，技术多好，解决问题的能力才是决定他工作能力高低的最重要的因素。漂亮的代码和高效的方案，其实都是我们解决问题的一种手段或是一项技能。可能有的技术能力非常突出，但是并不代表他能很好的完成工作。这也就解释了，为什么我们身边有那么多“技术大牛”，但是最后能够功成名就的没几个，甚至是“怀才不遇”。&lt;/p&gt;

&lt;p&gt;单就工作来说，任何一个公司都不需要整个团队里面全都是技术牛人，但是却急需能够高效快速的解决问题并把事情做好的人。后者其实就是我们口中常说的，靠谱的人。当靠谱的人从接受一件事情到最后完美解决这件事情，一些良好的做事习惯和处理问题的细节将会贯穿整个过程。比如拿到问题之后先拆解问题，分而治之，如果是一个小团队的leader，他可能会考虑底下人的性格和做事风格，把对的事交给合适的人去做。总之，靠谱的人会积极整合和利用手中的资源，花费最少的时间把这件事做成。而技术，仅仅是这其中的一环。技术高超那当然是非常不错的，但是往往做一件事，解决我一个问题的时候，拿出70%的技术实力就可以了，剩下的30%可能跟你的情绪，做事风格有关。不然为什么有的时候技术上很简单的一个东西，但是最后把这件事做成却花费了相当多的时间呢？所以说，工作的核心是解决问题把交代给你的事情顺利的做好，技术的好坏只能影响你是否能够把这件事即完成但是又做的很漂亮，属于锦上添花。不要总是闷头搞技术，其他能力也一样重要。&lt;/p&gt;

&lt;h1 id=&#34;做事不要走极端&#34;&gt;做事不要走极端&lt;/h1&gt;

&lt;p&gt;很多码农兄弟可能看了上面一段话在心里会想:这个货一看就不是一个纯粹的技术人员，每天想这么多有啥用的，不抓紧提升自己的技术实力，毕竟技术强才是硬道理啊。对此，我不想多说什么，毕竟几个月前的我也是这种想法。&lt;/p&gt;

&lt;p&gt;我觉得工作能力和技术能力是两种不同的力量，就像我们在大学里最后毕业有去考研搞科研的同学，也有投身于互联网企业想要锻炼自己工程能力的人一样。两种能力虽然会互相影响，但是本质上来说他们还是独立的。如果是一个工作能力很强，把每一件交代给他的事情都能完成很好的人，他的技术能力可能并不需要很牛，原因我上面也提到了。但是，作为一个技术人员，提升自己的技术实力是义不容辞的，甚至说是伴随整个职业生涯的。作为一个有追求并热爱自己工作的码农，肯定会想尽办法来提升自己，但这并不代表对其他的事情你可以什么都不想。我个人在这种走极端处理事情的方式上已经吃过很多亏，俗话说吃一堑，长一智。我觉得肯定是有办法来平衡这两者的。&lt;/p&gt;

&lt;p&gt;周围有一个同事A，基础很好，名校毕业，让我一时间崇拜不已，心想，人家咋就那么NB呢，我为啥这么渣呢？！冷静下来仔细思考，一个人之所以能够达到他现在的状态，是受很多因素影响的，家庭环境，教育条件，努力程度，甚至是天赋。总是有那么几个人能够360°完爆你。我不想给自己灌鸡汤，也不想把这篇文章变做一碗鸡汤。事实就是很多人是比你强的，但是一时半会又追不上。怎么办？“日拱一卒”即可。&lt;/p&gt;

&lt;p&gt;发现周围有厉害的人进而发现自己的不足这是正确的，但是妄自微薄却是错误的。总不能说他比我厉害我就不活了吧。生活还是要继续往下走，你现在意识到不如人家，哪里不如人家就可以一点一点的努力补上来，就算你到最后也追不上他，但是如果能一直保持你们之间的那个距离，是不是也算是一种进步呢？所以，为了弥补自己在技术上面的不足，我宁愿每天晚上拿出2个小时来看书，算法不好我补算法，Linux系统我不懂就刷apue。天长日久，付出一定会得到回报。&lt;/p&gt;

&lt;h1 id=&#34;不要抱怨没成长&#34;&gt;不要抱怨没成长&lt;/h1&gt;

&lt;p&gt;刚毕业的码农们都希望自己在技术上有着突飞猛进的成长，当你刚刚进入一家公司的时候这种感觉是最强烈的。但是天长日久，你很快就会发现你的工作内容已经对你的技术实力的成长没有多大帮助了，这个时候人就会感觉到慌，害怕，觉得自己如逆水行舟不进则退。这是一种非常普遍的现象，当然，我说的是那些对自己的前途有着理想的人，参加工作之后混吃等死的并不在我说的这一类人中。这个时候怎么办？靠天靠地不如靠自己，不要想着让别人给你创造一个让你快速成长的环境，抓紧时间提升自己。在技术方面制定一个计划，多看书，多实践，在提升自己实力的同时也在等待着机会。毕竟机会都是留给有准备的人。指不定哪一天就有一个从0到1的项目叫你去做，那个时候你就会庆幸自己在成长饱和期内没有浪费时间。总的来说，能不能成长靠你自己，总抱怨是没用的，与其怪罪他人没提供给你一个可以锻炼自己的事情和环境，不如马上行动起来，自己动手，丰衣足食。&lt;/p&gt;

&lt;h1 id=&#34;学会承担&#34;&gt;学会承担&lt;/h1&gt;

&lt;p&gt;任何一个人的工作不是独立的，而是融于某一个团队之中。预估给每个人分配的任务都是一种假想：假定你在规定的时间内能够完成预估的工作。规定时间内完成不了的现象不说，当你在完成被分配的工作之后，并且还有一些冗余时间你会怎么做？去看一些自己想看的技术文章，还是去问问其他人有没有其他的工作可以帮着分担一下呢？&lt;/p&gt;

&lt;p&gt;其实这两种想法都没有错，你去看技术文章可能是出于对自己负责，想提升自己的实力更好的工作，这无可厚非。但是如果你能够主动的去帮团队内其他成员分担一些繁重的工作，说明你更加成熟，考虑问题更加全面，想用自己的力量让整个团队的效率更高。&lt;/p&gt;

&lt;p&gt;之前的我可能是比较自私的，我是属于那种工作完成就想去看技术书籍的人。但是最近的一些事让我感受到，我不单单需要技术上的成长，同时也需要工作能力的提升。我想观察下自己，是否有能力能够帮助整个团队做好一件事情并且一直向好的方向发展，这也是我在预判自己以后的职业走向的一种方式。团队和个体都是互惠互利的，当你想向团队索取的时候，先想想自己为团队贡献过什么吧。&lt;/p&gt;

&lt;h1 id=&#34;return-0&#34;&gt;return 0&lt;/h1&gt;

&lt;p&gt;经历多了，才知道一个优秀码农并不仅仅是技术上的优秀，还有很多因素制约着一个人的成长。上面说的几点，我现在仍然还没有做好，写这篇文章也并不想站在道德的制高点去贬低谁，只是觉得，既然发现了问题，就要思考问题，然后解决问题。&lt;/p&gt;

&lt;p&gt;下一次，将会给大家带来另外一个话题：程序员，你的生活不仅仅只有工作。请大家敬请期待吧。&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>