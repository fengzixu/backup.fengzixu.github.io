<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>golang-net-http-packageæºç åˆ†æ-4 | LittleDriver</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="http://littledriver.net/css/theme-override.css">
    <header>

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="http://littledriver.net/">/home/littledriver</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/">~/home</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/categories/">~/categories</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/tags/">~/tags</a>
      </li>
      

      
      
      <li class="pull-right">
        <a href="/index.xml">~/subscribe</a>
      </li>
      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">golang-net-http-packageæºç åˆ†æ-4</span></h1>

<h2 class="date">2017/04/24</h2>
<p class="terms">
  
  
  Categories: <a href="/categories/%E5%B7%A5%E4%BD%9C%E4%BA%86%E4%B9%9F%E4%B8%8D%E8%83%BD%E6%94%BE%E6%9D%BE%E7%B3%BB%E5%88%97">å·¥ä½œäº†ä¹Ÿä¸èƒ½æ”¾æ¾ç³»åˆ—</a> 
  
  
  
  Tags: <a href="/tags/sourcecodeanalyse">SourceCodeAnalyse</a> 
  
  
</p>
</div>


<nav id="TableOfContents">
<ul>
<li><a href="#transport">Transport</a>
<ul>
<li><a href="#field">Field</a></li>
<li><a href="#method">Method</a>
<ul>
<li><a href="#roundtrip">RoundTrip</a></li>
</ul></li>
</ul></li>
</ul>
</nav>


<main>
<p></p>

<h1 id="transport">Transport</h1>

<h2 id="field">Field</h2>

<pre><code> Proxy func(*Request) (*url.URL, error)
</code></pre>

<p>Proxyæ¥å—ä¸€ä¸ªrequestï¼Œè¿”å›ä¸€ä¸ªurl.URLçš„å¯¹è±¡ã€‚Proxyå’ŒProxyEnvironmentçš„å‡½æ•°ç­¾åæ˜¯ä¸€æ ·çš„ï¼Œä»–ä»¬æœ‰ç€åŒæ ·çš„ç±»å‹ã€‚</p>

<pre><code>DialContext func(ctx context.Context, network, addr string) (net.Conn, error)
Dial func(network, addr string) (net.Conn, error)
</code></pre>

<p>ä¸Šé¢ä¸¤ä¸ªFieldéƒ½æ˜¯å‡½æ•°ç±»å‹çš„å¯¹è±¡ï¼Œè°ƒç”¨ä¹‹åå¯ä»¥ç”Ÿæˆä¸€ä¸ªæœªåŠ å¯†çš„tcpé“¾æ¥ã€‚ä½†æ˜¯æ–‡æ¡£ä¸­æ˜ç¡®æç¤ºæˆ‘ä»¬ï¼Œåº”è¯¥ä½¿ç”¨DialContextæ¥ä»£æ›¿Dailï¼Œå› ä¸ºå‰è€…å¯ä»¥åœ¨æˆ‘ä»¬ä¸éœ€è¦è¿™ä¸ªé“¾æ¥çš„æ—¶å€™ä¸»åŠ¨å°†å®ƒç»“æŸã€‚å¦‚æœä¸€ä¸ªTransportç±»å‹å¯¹è±¡ä¸­è¿™ä¸¤ä¸ªå±æ€§éƒ½èµ‹å€¼äº†ï¼Œé‚£ä¹ˆDialContextçš„ä¼˜å…ˆçº§æ˜¯è¦æ¯”Dialé«˜çš„ã€‚</p>

<pre><code>DialTLS func(network, addr string) (net.Conn, error)
</code></pre>

<p>DialTLSçš„è°ƒç”¨å°†ä¼šå»ºç«‹ä¸€ä¸ªTLSçš„é“¾æ¥ã€‚å¦‚æœDialTLSæˆå‘˜è¢«åˆå§‹åŒ–ï¼Œé‚£ä¹ˆå¯¹äºhttpsçš„requestå°±ä¼šè¢«DialTLSæˆå‘˜ç»™Hookä½ï¼Œå¦åˆ™å°±ç”±Dialå’ŒTLSClientConfigä¸¤ä¸ªæˆå‘˜é…åˆèµ·æ¥åšè¿™ä»¶äº‹ã€‚DialTLSè°ƒç”¨ä¹‹åè¿”å›çš„é“¾æ¥é»˜è®¤æ˜¯Tlsæ¡æ‰‹å·²ç»å®Œæˆçš„çŠ¶æ€ã€‚</p>

<pre><code>TLSClientConfig *tls.Config
TLSHandshakeTimeout time.Duration
</code></pre>

<p>å®¢æˆ·ç«¯ä¸Šhttpsçš„ç›¸å…³é…ç½®ä»¥åŠhttpsæ¡æ‰‹çš„è¶…æ—¶æ—¶é—´ã€‚ä½†æ˜¯åœ¨DialTLSæˆå‘˜è¢«èµ‹å€¼äº†ä¹‹åï¼Œè¿™ä¸¤ä¸ªæˆå‘˜çš„å€¼å°±å°†ä¼šè¢«å¿½ç•¥äº†ã€‚</p>

<pre><code>DisableKeepAlives bool
</code></pre>

<p>å¦‚æœè¿™ä¸ªå±æ€§è¢«ç½®ä¸ºtrue,é‚£ä¹ˆåœ¨ä¸¤æ¬¡ä¸åŒçš„è¯·æ±‚ä¹‹é—´å°±ä¸ä¼šå¯¹åŒä¸€æ¡tcpé“¾æ¥è¿›è¡Œé‡ç”¨äº†ï¼Œå³å…³é—­äº†Keep-AliveåŠŸèƒ½ã€‚</p>

<pre><code>MaxIdleConns int
MaxIdleConnsPerHost int
IdleConnTimeout time.Duration
</code></pre>

<p>MaxIdleConnså±æ€§ä¸ºä¸€ä¸ªTransportå¯¹æ‰€æœ‰çš„hostå¼€å¯çš„æœ€å¤§ç©ºé—²è¿æ¥æ•°ï¼Œæ˜¯ä¸€ä¸ªæ€»é‡ï¼ŒMaxIdleConnsPerHostä¸ºå¯¹æ¯ä¸€ä¸ªhostæ‰€èƒ½å¼€å¯çš„æœ€å¤§ç©ºé—²è¿æ¥æ•°ã€‚IdleConnTimeoutä¸ºç©ºé—²é“¾æ¥ä¿æŒå¤šä¹…å°†ä¼šå…³é—­å®ƒã€‚</p>

<pre><code>ResponseHeaderTimeout time.Duration
</code></pre>

<p>ResponseHeaderTimeoutæŒ‡å®šäº†ä¸€ä¸ªä»å‘é€äº†æ‰€æœ‰çš„requeståˆ°å¾—åˆ°æœåŠ¡ç«¯å‘é€çš„responseçš„Headerçš„è¶…æ—¶æ—¶é—´ã€‚</p>

<pre><code>MaxResponseHeaderBytes int64
</code></pre>

<p>MaxResponseHeaderBytesæŒ‡å®šäº†å®¢æˆ·ç«¯æ‰€èƒ½æ¥å—æœåŠ¡ç«¯å‘é€responseçš„æœ€å¤§å­—èŠ‚æ•°ã€‚</p>

<h2 id="method">Method</h2>

<pre><code>func (t *Transport) CancelRequest(req *Request) {
	t.cancelRequest(req, errRequestCanceled)
}
</code></pre>

<p>cancelRequestå‡½æ•°å†…éƒ¨è¯»å–äº†ä¸€ä¸ªmap[*Request]func(error)ç±»å‹çš„mapï¼Œkeyä¸ºrequestï¼Œvalueæ˜¯requestå¯¹åº”çš„cancelæ–¹æ³•ã€‚å…ˆæŠŠrequestå¯¹åº”çš„cancel methodæ‹·è´å‡ºæ¥ï¼Œç„¶åä»mapä¸­åˆ é™¤è¿™ä¸€æ¡è®°å½•ï¼Œæœ€åè°ƒç”¨è¿™ä¸ªcancelæ–¹æ³•ï¼Œå…³é—­è¿æ¥ã€‚</p>

<pre><code>func (t *Transport) CloseIdleConnections() {
	t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)
	t.idleMu.Lock()
	m := t.idleConn
	t.idleConn = nil
	t.idleConnCh = nil
	t.wantIdle = true
	t.idleLRU = connLRU{}
	t.idleMu.Unlock()
	for _, conns := range m {
		for _, pconn := range conns {
			pconn.close(errCloseIdleConns)
		}
	}
	if t2 := t.h2transport; t2 != nil {
		t2.CloseIdleConnections()
	}
}
</code></pre>

<p>CloseIdleConnectionså‡½æ•°ä¸»è¦ç”¨æ¥å…³é—­å› ä¹‹å‰çš„è¯·æ±‚å»ºç«‹å¹¶ä¸”å…¶ç›®å‰å¤„äºç©ºé—²çš„é“¾æ¥ã€‚Transportå†…éƒ¨æœ‰ä¸€ä¸ªidleConnæˆå‘˜ï¼Œä»–æ˜¯ä¸€ä¸ªmapç±»å‹çš„å˜é‡ï¼Œå…¶valueæ˜¯persistConnç±»å‹ï¼Œè¡¨ç¤ºäº†ä¸€ä¸ªå·²ç»å»ºç«‹çš„é“¾æ¥ã€‚CloseIdleConnectionsåˆšä¸€æ‰§è¡Œï¼Œå°±å°†Transportå†…å’Œç©ºé—²é“¾æ¥ç›¸å…³çš„fieldéƒ½æ¸…ç©ºï¼Œå¹¶ä¸”å°†idleConnæˆå‘˜copyäº†ä¸€ä»½ã€‚ä¹‹åå®ƒå°±éå†è¿™ä¸ªå­˜æœ‰å¾ˆå¤šç©ºé—²é“¾æ¥çš„mapï¼Œå°†ä»–ä»¬ä¸€ä¸€å…³é—­ã€‚åœ¨å…³é—­æ¯ä¸€ä¸ªç©ºé—²é“¾æ¥çš„æ—¶å€™ï¼Œæœ€ç»ˆè°ƒç”¨äº†persistConnç±»å‹çš„closeLockedæ–¹æ³•ï¼Œåœ¨å…¶å†…éƒ¨è°ƒç”¨äº†netåŒ…å†…Connç±»å‹çš„closeæ–¹æ³•ä»¥çœŸæ­£å…³é—­è¿™æ¡tcpé“¾æ¥ã€‚</p>

<pre><code>func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper) {
	t.altMu.Lock()
	defer t.altMu.Unlock()
	oldMap, _ := t.altProto.Load().(map[string]RoundTripper)
	if _, exists := oldMap[scheme]; exists {
		panic(&quot;protocol &quot; + scheme + &quot; already registered&quot;)
	}
	newMap := make(map[string]RoundTripper)
	for k, v := range oldMap {
		newMap[k] = v
	}
	newMap[scheme] = rt
	t.altProto.Store(newMap)
}
</code></pre>

<p>RegisterProtocolå‡½æ•°å°†ä¼šæ³¨å†Œä¸€ä¸ªschemeå’Œå¤„ç†ä½¿ç”¨è¿™ä¸ªschemeè¯·æ±‚çš„RoundTripperæ–¹æ³•åˆ°mapä¸­ã€‚åœ¨å¤„ç†è¯·æ±‚çš„æ—¶å€™ï¼Œä¼šæ ¹æ®è¯·æ±‚ä½¿ç”¨çš„schemeå¯¹mapä¸­çš„roundtripeæ–¹æ³•è¿›è¡ŒåŒ¹é…ã€‚å¦‚æœæ²¡æœ‰æ ¹æ®schemeæ³¨å†Œç‰¹æ®Šçš„RoundTripperæ–¹æ³•ï¼Œé‚£ä¹ˆä¼šè°ƒç”¨é»˜è®¤çš„RoundTripper</p>

<h3 id="roundtrip">RoundTrip</h3>

<p>RoundTripå…¶å®æ˜¯RoundTriperè¿™ä¸ªInterfaceçš„ä¸€ä¸ªæ–¹æ³•ï¼Œä½ ç»™å®ƒä¸€ä¸ªè¯·æ±‚ï¼Œå®ƒåç»™ä½ ä¸€ä¸ªå“åº”ã€‚åœ¨golangçš„httpæ¡†æ¶ä¸­ï¼ŒClientå‘é€è¯·æ±‚æ¥å—å“åº”çš„é€»è¾‘ä¸»è¦å°±æ˜¯ä¾èµ–äºå¯¹RoundTripå‡½æ•°çš„å®ç°ï¼ŒClientå®šä¹‰ä¸­æœ‰ä¸€ä¸ªåä¸ºTransportçš„æˆå‘˜ï¼Œå®ƒçš„ç±»å‹æ˜¯RoundTripperï¼Œä¸€èˆ¬æ¥è¯´éƒ½æ˜¯è°ƒç”¨è¿™ä¸ªæˆå‘˜çš„RoundTripæ–¹æ³•ã€‚åœ¨æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªClientå¯¹è±¡çš„æ—¶å€™ï¼Œå¦‚æœæ²¡ä¸ºå…¶ç‰¹æ„æŒ‡å®šä¸€ä¸ªå®ç°äº†RoundTripæ–¹æ³•çš„å¯¹è±¡ï¼Œé‚£ä¹ˆClientä¼šä½¿ç”¨ä¸€ä¸ªé¢„å®šä¹‰çš„Transportç±»å‹çš„å˜é‡ã€‚æ‰€ä»¥è¯´ï¼ŒTransportåº”è¯¥æ‰æ˜¯Clientçš„æ ¸å¿ƒå®ç°ã€‚</p>

<pre><code>	t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)
	ctx := req.Context()
	trace := httptrace.ContextClientTrace(ctx)

	if req.URL == nil {
		req.closeBody()
		return nil, errors.New(&quot;http: nil Request.URL&quot;)
	}
	if req.Header == nil {
		req.closeBody()
		return nil, errors.New(&quot;http: nil Request.Header&quot;)
	}
	scheme := req.URL.Scheme
	isHTTP := scheme == &quot;http&quot; || scheme == &quot;https&quot;
	if isHTTP {
		for k, vv := range req.Header {
			if !httplex.ValidHeaderFieldName(k) {
				return nil, fmt.Errorf(&quot;net/http: invalid header field name %q&quot;, k)
			}
			for _, v := range vv {
				if !httplex.ValidHeaderFieldValue(v) {
					return nil, fmt.Errorf(&quot;net/http: invalid header field value %q for key %v&quot;, v, k)
				}
			}
		}
	}
</code></pre>

<p>åœ¨RoundTripå‰åŠéƒ¨åˆ†çš„ä»£ç ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå®ƒä¸»è¦åšäº†äº†äº›å‚æ•°æ£€æŸ¥å·¥ä½œï¼Œå¦‚urlï¼Œheaderç­‰å­—æ®µå€¼çš„åˆæ³•æ€§ã€‚</p>

<pre><code>	altProto, _ := t.altProto.Load().(map[string]RoundTripper)
	if altRT := altProto[scheme]; altRT != nil {
		if resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol {
			return resp, err
		}
	}
</code></pre>

<p>æ¥ä¸‹æ¥RoundTripæ–¹æ³•å°†åœ¨altProtoè¿™ä¸ªatmoic.Valueç±»å‹çš„å˜é‡ä¸­å–å‡ºä¸€ä¸ªå€¼ï¼Œå¹¶ä¸”å°†å®ƒè½¬æ¢ä¸ºä¸€ä¸ªmapã€‚å…¶ä¸­è¿™ä¸ªmapçš„valueå°±æ˜¯ä¸€ä¸ªå®ç°äº†RoundTripæ–¹æ³•çš„å¯¹è±¡ã€‚altProtoçœ‹èµ·æ¥æ˜¯Transportè¿™ä¸ªç±»å‹å¯¹è±¡ä¸­çš„ä¸€ä¸ªæˆå‘˜ï¼Œå®ƒæ˜¯atomic.Valueç±»å‹ï¼Œé‡Œé¢å­˜å‚¨äº†ä¸€ä¸ªmapï¼Œæ³¨å†Œå’Œè¯·æ±‚åè®®ç›¸å¯¹åº”çš„RoundTripæ–¹æ³•ã€‚å¦‚æœä¹‹å‰å·²ç»å¯¹æŸä¸ªåè®®æŒ‡å®šäº†å¤„ç†ä½¿ç”¨è¯¥åè®®å‘é€è¯·æ±‚çš„æ–¹æ³•ï¼Œé‚£ä¹ˆåœ¨è¿™é‡Œå°±ä¼šç›´æ¥è°ƒç”¨RoundTripæ–¹æ³•è¿›è¡Œå¤„ç†ã€‚</p>

<p>å¦‚æœæ²¡æœ‰å·²ç»äº‹å…ˆå‡†å¤‡å¥½çš„RoundTripæ–¹æ³•ï¼Œé‚£ä¹ˆå°±éœ€è¦å®¢æˆ·ç«¯å…ˆä¸æœåŠ¡ç«¯å»ºç«‹tcpè¿æ¥ï¼Œä»¥ä¾¿ä¹‹åçš„é€šä¿¡ã€‚</p>

<pre><code>		// Get the cached or newly-created connection to either the
		// host (for http or https), the http proxy, or the http proxy
		// pre-CONNECTed to https server. In any case, we'll be ready
		// to send it requests.
		pconn, err := t.getConn(treq, cm)
		if err != nil {
			t.setReqCanceler(req, nil)
			req.closeBody()
			return nil, err
		}
</code></pre>

<p>RoundTripæ–¹æ³•ä¸­ï¼Œtransportå¯¹è±¡è°ƒç”¨äº†getConnæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•è·å–ä¸€æ¡è¿æ¥ï¼Œè¿™æ¡è¿æ¥å¯èƒ½æ˜¯ä¹‹å‰è¯·æ±‚å¤„ç†å®Œç©ºé—²ç­‰å¾…ä½¿ç”¨çš„ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯æ–°å»ºç«‹çš„ã€‚</p>

<pre><code>func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (*persistConn, error) {
	req := treq.Request
	trace := treq.trace
	ctx := req.Context()
	if trace != nil &amp;&amp; trace.GetConn != nil {
		trace.GetConn(cm.addr())
	}
	if pc, idleSince := t.getIdleConn(cm); pc != nil {
		if trace != nil &amp;&amp; trace.GotConn != nil {
			trace.GotConn(pc.gotIdleConnTrace(idleSince))
		}
		// set request canceler to some non-nil function so we
		// can detect whether it was cleared between now and when
		// we enter roundTrip
		}
		t.setReqCanceler(req, func(error) {})
		return pc, nil
	}
	
	...
}
</code></pre>

<p>getConnå‡½æ•°ä¸€è¿›æ¥å°±å…ˆè°ƒç”¨getIdleConnå»è·å–å·²ç»å»ºç«‹ä½†æ˜¯ç›®å‰é—²ç½®çš„é“¾æ¥ã€‚</p>

<pre><code>func (t *Transport) getIdleConn(cm connectMethod) (pconn *persistConn, idleSince time.Time) {
	key := cm.key()
	t.idleMu.Lock()
	defer t.idleMu.Unlock()
	for {
		pconns, ok := t.idleConn[key]
		if !ok {
			return nil, time.Time{}
		}
		if len(pconns) == 1 {
			pconn = pconns[0]
			delete(t.idleConn, key)
		} else {
			// 2 or more cached connections; use the most
			// recently used one at the end.
			pconn = pconns[len(pconns)-1]
			t.idleConn[key] = pconns[:len(pconns)-1]
		}
		t.idleLRU.remove(pconn)
		if pconn.isBroken() {
			// There is a tiny window where this is
			// possible, between the connecting dying and
			// the persistConn readLoop calling
			// Transport.removeIdleConn. Just skip it and
			// carry on.
			continue
		}
		if pconn.idleTimer != nil &amp;&amp; !pconn.idleTimer.Stop() {
			// We picked this conn at the ~same time it
			// was expiring and it's trying to close
			// itself in another goroutine. Don't use it.
			continue
		}
		return pconn, pconn.idleAt
	}
}
</code></pre>

<p>åœ¨getIdleConnå‡½æ•°å†…å°†è¿è¡Œä¸€ä¸ªæ­»å¾ªç¯ï¼Œå¾ªç¯å†…éƒ¨ä¼šåœ¨idleConnè¿™ä¸ªmapå†…æ ¹æ®connectMethodç±»å‹å†…çš„ä¸€äº›å’Œè¯·æ±‚æœ‰å…³çš„ä¿¡æ¯ï¼Œæ‰¾åˆ°ä¸€æ¡æ»¡è¶³æ¡ä»¶çš„é“¾æ¥è¿”å›ç»™å¤–éƒ¨ä½¿ç”¨ã€‚</p>

<ol>
<li>åœ¨åªæœ‰ä¸€æ¡ç©ºé—²é“¾æ¥çš„æ—¶å€™æ²¡æœ‰é€‰æ‹©ï¼Œåªæœ‰ä½¿ç”¨è¿™æ¡</li>
<li>è¶…è¿‡2æ¡åŠä»¥ä¸Šçš„ç©ºé—²é“¾æ¥ï¼Œé€‰å–æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„é‚£ä¸€æ¡</li>
</ol>

<p>åœ¨é€‰åˆ°é“¾æ¥çš„ä¹‹åï¼Œåœ¨è¿”å›ç»™å¤–é¢ä½¿ç”¨ä¹‹å‰è¿˜è¦æ£€æŸ¥è¿™ä¸ªé“¾æ¥æ˜¯å¦å·²ç»ä¸­æ–­äº†ä»¥åŠè¿™æ¡ç©ºé—²é“¾æ¥æ˜¯å¦å·²ç»è¶…æ—¶äº†ï¼Œå¦‚æœå·²ç»è¶…æ—¶äº†ï¼Œé‚£ä¹ˆå¾ˆæœ‰å¯èƒ½åœ¨åˆ«çš„åœ°æ–¹å°±ä¼šè¢«å…³é—­äº†ã€‚ä¸ç®¡æ˜¯ä¸­æ–­è¿˜æ˜¯è¶…æ—¶ï¼Œéƒ½åº”è¯¥æ‰§è¡Œcontinueé€»è¾‘é‡æ–°å†ç©ºé—²è¿æ¥æ± å†…å†æ‰¾ä¸€æ¡ã€‚</p>

<p>æ— è®ºæ˜¯åœ¨è°ƒç”¨getIdleConnä¹‹å‰è¿˜æ˜¯ä¹‹åï¼Œéƒ½ä¼šçœ‹åˆ°ä¸€ä¸ªClientTraceç±»å‹çš„å˜é‡traceæ¥è°ƒç”¨GetConnå’ŒGotConnã€‚å…¶å®ClientTraceè¿™ä¸ªç±»å‹é‡Œé¢çš„æˆå‘˜ä»¥åŠæ–¹æ³•éƒ½æ˜¯å¯¹ä¸€ä¸ªè¯·æ±‚å…·æœ‰é’©å­åŠŸèƒ½çš„ï¼Œå…¶å†…éƒ¨çš„æˆå‘˜å’Œæ–¹æ³•å¯ä»¥ç”¨æ¥æ—¶åˆ»è·Ÿè¸ªä¸€ä¸ªè¯·æ±‚åœ¨çœŸæ­£å‘é€ç»™æœåŠ¡ç«¯ä¹‹å‰çš„å„ç§æƒ…å†µã€‚å¦‚æœæˆåŠŸè·å–åˆ°ç©ºé—²çš„ç½‘ç»œè¿æ¥ä¹‹åï¼Œè¿˜å°†è°ƒç”¨setReqCancelerå‡½æ•°ï¼Œå®ƒå°†è®¾ç½®å’Œæœ¬æ¬¡è¯·æ±‚æœ‰å…³çš„ä¸€ä¸ªå–æ¶ˆå‡½æ•°ä»¥ä¾¿åœ¨ä¹‹åå¯ä»¥æœ‰æ•ˆæ£€æŸ¥ä¸€ä¸ªreqæ˜¯å¦å·²ç»è¢«å–æ¶ˆå¤„ç†ã€‚</p>

<p>å¦‚æœgetIdleConnå‡½æ•°æˆåŠŸè·å–åˆ°ä¸€ä¸ªç©ºé—²é“¾æ¥ï¼Œé‚£ä¹ˆgetConnå‡½æ•°å°†è¿”å›è¿™ä¸ªé“¾æ¥ä»¥ä¾›å¤–é¢ä½¿ç”¨ã€‚å¦‚æœæ²¡æœ‰è·å–åˆ°åˆé€‚çš„ç©ºé—²é“¾æ¥ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥çš„é€»è¾‘å°†ä¼šåˆ›å»ºä¸€æ¡æ–°çš„é“¾æ¥ã€‚</p>

<pre><code>	cancelc := make(chan error, 1)
	t.setReqCanceler(req, func(err error) { cancelc &lt;- err })

	go func() {
		pc, err := t.dialConn(ctx, cm)
		dialc &lt;- dialRes{pc, err}
	}()

	idleConnCh := t.getIdleConnCh(cm)
	select {
	case v := &lt;-dialc:
		// Our dial finished.
		if v.pc != nil {
			if trace != nil &amp;&amp; trace.GotConn != nil &amp;&amp; v.pc.alt == nil {
				trace.GotConn(httptrace.GotConnInfo{Conn: v.pc.conn})
			}
			return v.pc, nil
		}
		// Our dial failed. See why to return a nicer error
		// value.
		select {
		case &lt;-req.Cancel:
			// It was an error due to cancelation, so prioritize that
			// error value. (Issue 16049)
			return nil, errRequestCanceledConn
		case &lt;-req.Context().Done():
			return nil, req.Context().Err()
		case err := &lt;-cancelc:
			if err == errRequestCanceled {
				err = errRequestCanceledConn
			}
			return nil, err
		default:
			// It wasn't an error due to cancelation, so
			// return the original error message:
			return nil, v.err
		}
	case pc := &lt;-idleConnCh:
		// Another request finished first and its net.Conn
		// became available before our dial. Or somebody
		// else's dial that they didn't use.
		// But our dial is still going, so give it away
		// when it finishes:
		handlePendingDial()
		if trace != nil &amp;&amp; trace.GotConn != nil {
			trace.GotConn(httptrace.GotConnInfo{Conn: pc.conn, Reused: pc.isReused()})
		}
		return pc, nil
	case &lt;-req.Cancel:
		handlePendingDial()
		return nil, errRequestCanceledConn
	case &lt;-req.Context().Done():
		handlePendingDial()
		return nil, req.Context().Err()
	case err := &lt;-cancelc:
		handlePendingDial()
		if err == errRequestCanceled {
			err = errRequestCanceledConn
		}
		return nil, err
	}
</code></pre>

<p>å¯ä»¥çœ‹å‡ºï¼Œå†åˆ›å»ºæ–°çš„é“¾æ¥æ—¶å€™ï¼Œä¸»è¦æ˜¯é dialConnè¿™ä¸ªå‡½æ•°ï¼Œåœ¨ä¸€ä¸ªgoroutineé‡Œé¢è°ƒç”¨å®ƒä¹‹åï¼Œåˆ©ç”¨selectè¯­å¥æ¥ç­‰å¾…å¤„ç†å»ºç«‹é“¾æ¥è¿‡ç¨‹å½“ä¸­çš„å„ç§æƒ…å†µã€‚è¿™é‡Œæ˜¯é˜»å¡çš„ï¼Œå› ä¸ºselectçš„caseéƒ½æ˜¯é˜»å¡çš„channelåœ¨ç­‰å¾…æ¥å—åˆ°æ¥çš„å€¼ã€‚å½“é“¾æ¥é¡ºåˆ©å»ºç«‹å®Œæˆçš„ä¹‹åï¼Œdialcè¿™ä¸ªchannelå°†ä¼šæ¥æ”¶åˆ°ä¸€ä¸ªå€¼ï¼Œå› æ­¤å°†ä¼šå‘½ä¸­selectçš„ç¬¬ä¸€ä¸ªcaseã€‚å¦‚æœå…¶æ¥æ”¶åˆ°çš„å€¼å½“ä¸­çš„persistConnç±»å‹çš„æˆå‘˜éƒ¨ä½nilé‚£ä¹ˆå°±åº”è¯¥è¿”å›å®ƒï¼Œä¸€ä¸ªæ–°çš„ç½‘ç»œé“¾æ¥å°±å·²ç»å»ºç«‹å¥½äº†ã€‚</p>

<p>é‚£ä¹ˆæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±æ¥çœ‹ä¸€ä¸‹dialConnå‡½æ•°éƒ½åšäº†äº›ä»€ä¹ˆï¼š</p>

<pre><code>pconn := &amp;persistConn{
		t:             t,
		cacheKey:      cm.key(),
		reqch:         make(chan requestAndChan, 1),
		writech:       make(chan writeRequest, 1),
		closech:       make(chan struct{}),
		writeErrCh:    make(chan error, 1),
		writeLoopDone: make(chan struct{}),
	}
	trace := httptrace.ContextClientTrace(ctx)
	tlsDial := t.DialTLS != nil &amp;&amp; cm.targetScheme == &quot;https&quot; &amp;&amp; cm.proxyURL == nil
	if tlsDial {
		...
	} else {
		conn, err := t.dial(ctx, &quot;tcp&quot;, cm.addr())
		if err != nil {
			if cm.proxyURL != nil {
				// Return a typed error, per Issue 16997:
				err = &amp;net.OpError{Op: &quot;proxyconnect&quot;, Net: &quot;tcp&quot;, Err: err}
			}
			return nil, err
		}
		pconn.conn = conn
	}

	...
	
	pconn.br = bufio.NewReader(pconn)
	pconn.bw = bufio.NewWriter(persistConnWriter{pconn})
	go pconn.readLoop()
	go pconn.writeLoop()
	return pconn, nil
</code></pre>

<p>åœ¨ä¸è€ƒè™‘httpså’Œä»£ç†çš„æƒ…å†µä¸‹ï¼ŒdialConnå‡½æ•°é¦–å…ˆä¼šé€šè¿‡t.dialå‡½æ•°å»ºç«‹ä¸€ä¸ªç½‘ç»œé“¾æ¥ã€‚ä¹‹åï¼Œé€šè¿‡bufio.NewReaderå’Œbufio.NewWriteråˆ†åˆ«åˆå§‹åŒ–äº†persistConnç±»å‹å¯¹è±¡å†…çš„brå’Œbwæˆå‘˜ã€‚è¿™ä¸¤ä¸ªæˆå‘˜ä¸€ä¸ªè´Ÿè´£ä»è¿æ¥ä¸­è¯»å–æ•°æ®ï¼Œå¦å¤–ä¸€ä¸ªè´Ÿè´£å‘é“¾æ¥ä¸­å†™å…¥æ•°æ®ã€‚æ¥ä¸‹æ¥å¯åŠ¨ä¸¤ä¸ªgoroutineï¼Œè¿è¡Œè¯»å¾ªç¯å’Œå†™å¾ªç¯ã€‚</p>

<p>æš‚æ—¶ä¸å…³å¿ƒè¯»å†™å¾ªç¯ä¸­åšçš„äº‹æƒ…ï¼Œé“¾æ¥å»ºç«‹ä¹‹åï¼Œå›åˆ°RoundTripå‡½æ•°ä¸­.</p>

<p>å¦‚æœæ–°çš„é“¾æ¥å·²ç»åˆ›å»ºå¥½äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¼šæ‹¿åˆ°ä¸€ä¸ªpersistConnç±»å‹çš„è¿æ¥å¯¹è±¡ã€‚å¦‚æœæ­¤æ¬¡httpé€šä¿¡çš„è¯·æ±‚è¿˜æ˜¯å»ºç«‹åœ¨1.1çš„ç‰ˆæœ¬ä¸Šçš„è¯ï¼Œå°±ä¼šè°ƒç”¨persistConnç±»å‹å¯¹è±¡çš„roundTripå‡½æ•°ã€‚</p>

<pre><code>		pconn, err := t.getConn(treq, cm)
		if err != nil {
			t.setReqCanceler(req, nil)
			req.closeBody()
			return nil, err
		}

		var resp *Response
		if pconn.alt != nil {
			// HTTP/2 path.
			t.setReqCanceler(req, nil) // not cancelable with CancelRequest
			resp, err = pconn.alt.RoundTrip(req)
		} else {
			resp, err = pconn.roundTrip(treq)
		}
		if err == nil {
			
</code></pre>

<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå°½ç®¡è¿™ä¸€è·¯çœ‹ä¸‹æ¥å…¶ä¸­çš„é€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œåˆæ˜¯ç©ºé—²é“¾æ¥ï¼Œåˆæ˜¯è¯»å†™å¾ªç¯çš„ã€‚ä½†æ˜¯æˆ‘ä»¬åœ¨çœ‹è¿™éƒ¨åˆ†æºç çš„æ—¶å€™ï¼Œè¦å§‹ç»ˆè®°ä½ä¸€æ¡çº¿ã€‚å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯å»ºç«‹é“¾æ¥ï¼Œåœ¨æ¬¡è¿æ¥ä¸Šå‘é€è¯·æ±‚ï¼Œä»æ­¤é“¾æ¥ä¸Šè·å–è¯·æ±‚å“åº”ã€‚é‚£ä¹ˆåˆ°ç›®å‰ä¸ºæ­¢ï¼Œå®¢æˆ·ç«¯å·²ç»ä¸æœåŠ¡ç«¯å»ºç«‹äº†ä¸€ä¸ªè¿æ¥äº†ï¼Œæ¥ä¸‹æ¥å°±æ˜¯åœ¨è¿™æ¡è¿æ¥ä¸Šè¿›è¡ŒHttpçš„é€šä¿¡ã€‚é‚£ä¹ˆå‘é€è¯·æ±‚å’Œæ¥æ”¶å“åº”çš„çš„é€»è¾‘ä¸»è¦å°±æ˜¯åœ¨roundTripè¿™ä¸ªæ–¹æ³•å†…äº†ã€‚å› ä¸ºæˆ‘ä»¬å¯ä»¥æ¸…æ¥šçš„çœ‹åˆ°ï¼Œè¿™ä¸ªæ–¹æ³•ä¼ è¿›å»ä¸€ä¸ªrequestï¼Œè¿”å›ä¸€ä¸ªresponse.</p>

<blockquote>
<p>ps: ä¸ªäººè§‰å¾—çœ‹æºç æœ€å¿Œè®³çš„å°±æ˜¯è¢«æºç ç»•æ™•äº†ã€‚ä»»ä½•ä¸€ä¸ªå¼€æºé¡¹ç›®çš„è¿œå—éƒ½æ˜¯å¾ˆå¤æ‚çš„ï¼Œå¦‚æœä½ ä¸€å¤´æ‰è¿›å»ï¼Œæ·±åº¦ä¼˜å…ˆéå†å¾—çœ‹ï¼Œé‚£è€é“ä½ å¾ˆå¿«å°±ä»å…¥é—¨åˆ°æ”¾å¼ƒäº†ã€‚æ‰€ä»¥è¯´ï¼Œçœ‹æºç ç¬¬ä¸€éçš„æ—¶å€™ï¼Œå°½é‡ä¸è¦åœ¨æ„å¤ªå¤šç»†èŠ‚ã€‚æŠŠæ•´ä½“çš„è„‰ç»œå…ˆå±¡æ¸…æ¥šï¼Œç„¶åä¸€ç‚¹ç‚¹çš„å»è¿½å„ç§ç»†èŠ‚ã€‚</p>
</blockquote>

<p>roundTripæ–¹æ³•å†…å…·ä½“æ˜¯æ€ä¹ˆåšçš„ï¼Œæˆ‘ä»¬è·Ÿè¿›å»çœ‹çœ‹ã€‚</p>

<pre><code>func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) {
	....
	writeErrCh := make(chan error, 1)
	pc.writech &lt;- writeRequest{req, writeErrCh, continueCh}

	resc := make(chan responseAndError)
	pc.reqch &lt;- requestAndChan{
		req:        req.Request,
		ch:         resc,
		addedGzip:  requestedGzip,
		continueCh: continueCh,
		callerGone: gone,
	}

	var re responseAndError
	var respHeaderTimer &lt;-chan time.Time
	cancelChan := req.Request.Cancel
	ctxDoneChan := req.Context().Done()
WaitResponse:
	for {
		testHookWaitResLoop()
		select {
		case err := &lt;-writeErrCh:
			if err != nil {
				if cerr := pc.canceled(); cerr != nil {
					err = cerr
				}
				re = responseAndError{err: err}
				pc.close(fmt.Errorf(&quot;write error: %v&quot;, err))
				break WaitResponse
			}
			if d := pc.t.ResponseHeaderTimeout; d &gt; 0 {
				timer := time.NewTimer(d)
				defer timer.Stop() // prevent leaks
				respHeaderTimer = timer.C
			}
		case &lt;-pc.closech:
			re = responseAndError{err: pc.mapRoundTripErrorAfterClosed(req.Request, startBytesWritten)}
			break WaitResponse
		case &lt;-respHeaderTimer:
			pc.close(errTimeout)
			re = responseAndError{err: errTimeout}
			break WaitResponse
		case re = &lt;-resc:
			re.err = pc.mapRoundTripErrorFromReadLoop(req.Request, startBytesWritten, re.err)
			break WaitResponse
		case &lt;-cancelChan:
			pc.t.CancelRequest(req.Request)
			cancelChan = nil
		case &lt;-ctxDoneChan:
			pc.t.cancelRequest(req.Request, req.Context().Err())
			cancelChan = nil
			ctxDoneChan = nil
		}
	}

	if re.err != nil {
		pc.t.setReqCanceler(req.Request, nil)
	}
	if (re.res == nil) == (re.err == nil) {
		panic(&quot;internal error: exactly one of res or err should be set&quot;)
	}
	return re.res, re.err
}
</code></pre>

<p>roundTripæ–¹æ³•å‰é¢åšäº†å¾ˆå¤šæ£€æŸ¥å‚æ•°ï¼Œä»¥åŠæˆ‘æ ¹æœ¬çœ‹ä¸åˆ°ä¸ºå•¥è¦è¿™ä¹ˆåšçš„é€»è¾‘ã€‚æš‚æ—¶å…ˆå¿½ç•¥ï¼Œæˆ‘ä»¬è¦å…³æ³¨çš„è¿˜æ˜¯æ ¸å¿ƒçš„å‘é€è¯·æ±‚å’Œæ¥æ”¶å“åº”çš„é€»è¾‘ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦é¢å¤–æ³¨æ„ä¸¤è¡Œä»£ç ï¼š</p>

<pre><code>	writeErrCh := make(chan error, 1)
	pc.writech &lt;- writeRequest{req, writeErrCh, continueCh}

	resc := make(chan responseAndError)
	pc.reqch &lt;- requestAndChan{
		req:        req.Request,
		ch:         resc,
		addedGzip:  requestedGzip,
		continueCh: continueCh,
		callerGone: gone,
	}
</code></pre>

<p>ä¸Šé¢è¿™æ®µä»£ç çœ‹èµ·æ¥å¾ˆæ™®é€šï¼Œä½†æ˜¯ç¡®å®å¼€å¯å‘è¯·æ±‚å’Œè¯»ç›¸åº”çš„é‡è¦éƒ¨åˆ†ã€‚ä»£ç å¯¹pc.writechå’Œpc.reqchä¸¤ä¸ªchannelè¿›è¡Œäº†èµ‹å€¼æ“ä½œã€‚åœ¨goè¯­è¨€ä¸­ï¼Œå¯¹é˜»å¡æ€§çš„channelèµ‹å€¼ï¼Œå¾€å¾€éƒ½æ„å‘³ç€gorountineä¹‹é—´çš„é€šä¿¡ã€‚é‚£ä¹ˆè¿™ä¸¤ä¸ªç®¡é“çš„ä¸¤æ®µç©¶ç«Ÿé“¾æ¥äº†å“ªäº›goroutineå‘¢ï¼Ÿ</p>

<p>é€šè¿‡æŸ¥çœ‹è¿™ä¸¤ä¸ªchannelçš„å®šä¹‰æˆ‘ä»¬å°±ä¸€ç›®äº†ç„¶äº†ï¼š</p>

<pre><code>	reqch     chan requestAndChan // written by roundTrip; read by readLoop
	writech   chan writeRequest   // written by roundTrip; read by writeLoop
</code></pre>

<p>è¿™ä¸¤ä¸ªchannelï¼Œæ­£æ˜¯è¿æ¥äº†ä¹‹å‰åœ¨dialConnå‡½æ•°å†…å¼€å¯çš„ä¸¤ä¸ªè¯»å†™goroutineä»¥åŠæˆ‘ä»¬ç›®å‰æ‰€çœ‹åˆ°çš„roundTripæ–¹æ³•æ‰€åœ¨çš„goroutineã€‚è¿™ä¹ˆä¸€çœ‹ï¼Œè²Œä¼¼å’Œä¹‹å‰çœ‹åˆ°çš„ä¸œè¥¿ä¸€ä¸‹å­å°±ä¸²èµ·æ¥äº†ã€‚æ‰€ä»¥è¯´å†çœ‹æºç çš„æ—¶å€™ï¼Œä¸è¦æ­»ç£•ä¸€ä¸ªåœ°æ–¹ï¼Œå¾€å¾€ä½ é¡ºç€ä¸€æ¡çº¿æ¥ç€å‘åçœ‹çœ‹ï¼Œè‡ªç„¶è€Œç„¶çš„å°±èƒ½å¤Ÿé¢†ä¼šåˆ°ä½œè€…è¿™ä¹ˆå®ç°çš„ç²¾å¦™ä¹‹å¤„ã€‚</p>

<p>çœ‹èµ·æ¥ï¼Œè¿™ä¸€ä¸ªè¯»goroutineå’Œä¸€ä¸ªå†™goroutineéƒ½æ˜¯è¿è¡Œåœ¨è¿™æ¡å‰é¢æ‰€å»ºç«‹çš„è¿æ¥ä¸Šçš„ã€‚çŒœæµ‹ä¸€ä¸‹ï¼Œè¯»å¾ªç¯è´Ÿè´£ä»è¿æ¥ä¸Šè¯»å–æœåŠ¡ç«¯è¿”å›çš„respï¼Œå†™å¾ªç¯è´Ÿè´£å°†reqä¼ é€’ç»™æœåŠ¡ç«¯ã€‚å¸¦ç€è¿™ä¸ªçŒœæƒ³ï¼Œæˆ‘ä»¬å¯ä»¥æ¥çœ‹çœ‹è¯»å†™goroutineçš„å®ç°äº†ã€‚</p>

<pre><code>func (pc *persistConn) writeLoop() {
	defer close(pc.writeLoopDone)
	for {
		select {
		case wr := &lt;-pc.writech:
			startBytesWritten := pc.nwrite
			err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))
			if err == nil {
				err = pc.bw.Flush()
			}
			if err != nil {
				wr.req.Request.closeBody()
				if pc.nwrite == startBytesWritten &amp;&amp; wr.req.outgoingLength() == 0 {
					err = nothingWrittenError{err}
				}
			}
			pc.writeErrCh &lt;- err // to the body reader, which might recycle us
			wr.ch &lt;- err         // to the roundTrip function
			if err != nil {
				pc.close(err)
				return
			}
		case &lt;-pc.closech:
			return
		}
	}
}
</code></pre>

<p>ä»ä¸Šé¢çš„ä»£ç ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œpc.writechè¿™ä¸ªç”¨äºå†™å¾ªç¯çš„ç®¡é“åœ¨æ¥æ”¶äº†roundtripæ–¹æ³•å¯¹å…¶çš„èµ‹å€¼æ“ä½œåï¼Œæœ‰ä¸‰ä¸ªå…³é”®çš„æ“ä½œã€‚</p>

<ol>
<li>err = pc.bw.Flush()</li>
<li>wr.ch &lt;- err         // to the roundTrip function</li>
<li>pc.writeErrCh &lt;- err</li>
</ol>

<p>ç¬¬ä¸€ä¸ªæ“ä½œæ˜¯è°ƒç”¨äº†bwçš„Flushæ–¹æ³•ï¼Œè·³è½¬bwæˆå‘˜çš„å®šä¹‰ï¼Œå¯ä»¥çœ‹åˆ°å®ƒå°±æ˜¯ä¸ºäº†å‘é“¾æ¥ä»¥åŠé“¾æ¥å¦ä¸€è¾¹é“¾æ¥çš„æœåŠ¡ç«¯å†™æ•°æ®ç”¨çš„ï¼Œä»–æ˜¯ä¸€ä¸ªbufio.Writerç±»å‹çš„å¯¹è±¡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ç»è¿‡å‰æœŸçš„ä¸€äº›å¤„ç†ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥é’ˆå¯¹ä½¿ç”¨çš„é“¾æ¥å†™å…¥æ•°æ®ã€‚å†™å…¥æ•°æ®ä¹‹åï¼Œæ— è®ºå†™å…¥çš„æœ‰æ²¡æœ‰é—®é¢˜ï¼Œéƒ½ä¼šæŠŠç»“æœé€šè¿‡writechå†…çš„chæˆå‘˜ä¼ é€’ç»™å¤–å±‚çš„roundTripï¼Œä¹Ÿä¼šä¼ ç»™writeErrChè¿™ä¸ªchannelã€‚</p>

<p>æ—¢ç„¶writech.chè¿™ä¸ªæˆå‘˜æ˜¯ä¸ºäº†é€šçŸ¥å¤–éƒ¨çš„roundTripæ–¹æ³•çš„ï¼Œé‚£ä¹ˆwriteErrChè¿™ä¸ªchannelåˆæ˜¯ç”¨æ¥åšä»€ä¹ˆçš„å‘¢ï¼Ÿé¦–å…ˆï¼Œåœ¨çœ‹channelä½œç”¨çš„æ—¶å€™ï¼Œè¿˜æ˜¯è¦éµå®ˆä¸€ä¸ªåŸåˆ™ï¼Œchannelè‚¯å®šæ˜¯è¿æ¥äº†ä¸¤ä¸ªgoroutineã€‚é‚£ä¹ˆè¿™ä¸¤ä¸ªgoroutineæ˜¯å“ªä¸¤ä¸ªå‘¢ï¼ŸæŸ¥çœ‹è¿™ä¸ªchannelçš„å¼•ç”¨æˆ‘ä»¬å°±å¯ä»¥çœ‹åˆ°ï¼Œåœ¨readLoopä¸­ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨ä¸€ä¸ªwroteRequestçš„æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å†…ä¼šæ¥å—writeErrchè¿™ä¸ªchannelæ‰€å‘é€è¿‡æ¥çš„æ¶ˆæ¯ã€‚ä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªchannelæ˜¯è´Ÿè´£é“¾æ¥writeloopå’Œreadloopè¿™ä¸¤ä¸ªgorountineçš„ã€‚</p>

<p>å…¶æ¬¡ï¼Œæˆ‘ä»¬è¦çœ‹ä¸‹è¿™ä¸ªchannelçš„å®šä¹‰ï¼Œå®ƒè¿æ¥è¯»å†™å¾ªç¯çš„gorountineå…·ä½“èµ·äº†ä»€ä¹ˆä½œç”¨ã€‚</p>

<pre><code>	// writeErrCh passes the request write error (usually nil)
	// from the writeLoop goroutine to the readLoop which passes
	// it off to the res.Body reader, which then uses it to decide
	// whether or not a connection can be reused. Issue 7569.
</code></pre>

<p>æºç ä¸­çš„æ³¨é‡Šè¯´ï¼ŒwriteErrChè¿™ä¸ªchannelï¼Œæ˜¯ä¸ºäº†èƒ½å°†è¯·æ±‚å†™å…¥çš„é”™è¯¯ä»å†™å¾ªç¯çš„goroutineä¸­ä¼ é€’åˆ°è¯»å¾ªç¯çš„goroutineä¸­ï¼Œä»¥æ­¤æ¥åˆ¤å®šç›®å‰çš„è¿™æ¡è¿æ¥æ˜¯å¦å¯ç”¨ï¼Œå¦‚æœåœ¨è¿™æ¡è¿æ¥ä¸Šå†™å…¥æ•°æ®çš„æ—¶å€™éƒ½å‡ºé”™äº†ï¼Œé‚£ä¹ˆæƒ³åœ¨è¿™æ¡è¿æ¥è¯»æ•°æ®ä¹Ÿä¼šæœ‰é—®é¢˜ã€‚
çœ‹å®Œäº†å†™å¾ªç¯ä¸­çš„å‡ ä¸ªå…³é”®æ“ä½œï¼Œé‚£ä¹ˆæ˜¯æ—¶å€™å…ˆè·Ÿç€wr.chçš„è„šæ­¥ï¼Œå›åˆ°å¤–å±‚çš„roundTripä¸­äº†ã€‚</p>

<p>roundTripä¸­çš„ååŠéƒ¨åˆ†ï¼Œèµ·äº†ä¸€ä¸ªæ­»å¾ªç¯å¤–åŠ ä¸€ä¸ªselectï¼Œç”¨æ¥ç›‘æ§è¿™æ¡è¿æ¥ä¸Šçš„è¯·æ±‚å’Œå“åº”çš„æƒ…å†µã€‚å¯ä»¥çœ‹å‡ºåœ¨ç›‘æ§writeErrChè¿™ä¸ªchannelçš„caseä¸Šï¼Œæ¡†æ¶å…ˆæ£€æŸ¥åœ¨è¿æ¥ä¸Šå†™å…¥æ•°æ®æœ‰è¯¯é”™è¯¯ï¼Œå¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆå°±è¦è®¾ç½®å®šæ—¶å™¨ï¼Œåé¢åº”è¯¥ä¼šç­‰å¾…å“åº”çš„ä¼ è¾“ã€‚
åŸºæœ¬ä¸Šwriteloopæ‰€åšçš„äº‹æƒ…å°±æ˜¯è¿™æ ·ã€‚ä¸‹é¢è®©æˆ‘ä»¬æ¥çœ‹ä¸‹readloopã€‚</p>

<p>åœ¨çœ‹readLoopçš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥æ¢ä¸€ä¸ªæ€è·¯ï¼Œè¿™æ¬¡å…ˆçœ‹roundTripæ–¹æ³•å¯¹è¯»å¾ªç¯channelçš„ç›‘æ§æƒ…å†µã€‚roundTripåœ¨selectä¸­ç›‘æ§äº†ä¼ é€’ç»™readloopçš„pc.reqchè¿™ä¸ªå˜é‡é‡Œé¢çš„chæˆå‘˜ï¼Œä¹Ÿå°±æ˜¯rescè¿™ä¸ªchannelã€‚å¯ä»¥çœ‹å‡ºï¼Œåœ¨æˆåŠŸæ¥æ”¶äº†è¿™ä¸ªchannelè¿”å›å›æ¥çš„responseä¹‹åï¼ŒroundTripçš„ä»»åŠ¡å°±å®Œæˆäº†ï¼Œå¦‚æœæœŸé—´æ²¡æœ‰å‘ç”Ÿä»»ä½•é”™è¯¯çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªresponseå°±ä¼šè¿”å›ç»™è¿™ä¸ªå®¢æˆ·ç«¯çš„è°ƒç”¨è€…ã€‚</p>

<pre><code>	for alive {
		pc.readLimit = pc.maxHeaderResponseSize()
		_, err := pc.br.Peek(1)

		pc.mu.Lock()
		if pc.numExpectedResponses == 0 {
			pc.readLoopPeekFailLocked(err)
			pc.mu.Unlock()
			return
		}
		pc.mu.Unlock()

		rc := &lt;-pc.reqch
		trace := httptrace.ContextClientTrace(rc.req.Context())

		var resp *Response
		if err == nil {
			resp, err = pc.readResponse(rc, trace)
		} else {
			err = transportReadFromServerError{err}
			closeErr = err
		}
	...
}
</code></pre>

<p>è¯»å¾ªç¯ä¸­çš„å…³é”®é€»è¾‘å¦‚ä¸Šï¼Œåœ¨readLoopä¸­èµ·äº†å¾ªç¯ï¼Œèµ·å¾ªç¯çš„å‰ææ¡ä»¶æ˜¯é€šä¿¡çš„è¿™æ¡è¿æ¥çš„æ˜¯æ´»è·ƒçš„ã€‚ä¹Ÿå°±æ˜¯é€šè¿‡aliveæ¥åˆ¤æ–­çš„ã€‚è¿è¡Œåˆ°rc := &lt;- pc.reqchè¿™ä¸€å¥çš„æ—¶å€™ï¼Œå¦‚æœpc.reqchè¿™ä¸ªchannelå¦‚æœè¿˜æ²¡æœ‰æ¥å—åˆ°æ•°æ®çš„æ—¶å€™ï¼Œä¼šåœ¨è¿™é‡Œå¡ä½ã€‚å½“å¤–å±‚çš„roundTripæ–¹æ³•å‘è¿™ä¸ªchannelå‘é€æ•°æ®çš„æ—¶å€™ï¼Œrcæ¥æ”¶åˆ°æ•°æ®ï¼Œå¼€å§‹è¿›å…¥pc.readResponseçš„é€»è¾‘ï¼Œè¿™ä¸ªé€»è¾‘å°±æ˜¯ä»è¿æ¥ä¸­è¯»å–å“åº”æ•°æ®çš„å…³é”®ã€‚</p>

<p>åœ¨pc.readResponseè¿™ä¸ªæ–¹æ³•é‡Œï¼Œä¼šè°ƒç”¨ä¸€ä¸ªåŒåçš„å¤§å†™æ–¹æ³•resp, err = ReadResponse(pc.br, rc.req)ã€‚è¿™ä¸ªæ–¹æ³•å°†ä¼šä»pc.brè¿™ä¸ª*bufio.Readerç±»å‹çš„å¯¹è±¡å†…ï¼Œä¸æ–­çš„è¯»å–responseçš„å†…å®¹ã€‚å…ˆé€è¡Œçš„å°†Httpå“åº”çš„å¤´éƒ¨çš„åŸºæœ¬ä¿¡æ¯éƒ½è§£æå‡ºæ¥ï¼Œæœ€åé€šè¿‡readTransferå‡½æ•°å°†bodyä»¥åŠå…¶ä»–çš„å“åº”ä¿¡æ¯éƒ½è§£æå‡ºæ¥ã€‚</p>

<p>è§£æå®ŒæœåŠ¡ç«¯å‘å›æ¥çš„å“åº”ä¹‹åï¼Œ</p>

<pre><code>	if resp.StatusCode == 100 {
		pc.readLimit = pc.maxHeaderResponseSize() // reset the limit
		resp, err = ReadResponse(pc.br, rc.req)
		if err != nil {
			return
		}
	}
</code></pre>

<p>goè¿˜ä¼šæ£€æŸ¥ä¸€ä¸‹æœåŠ¡ç«¯åå‡ºæ¥çš„statusCodeæ˜¯å¦æ˜¯100ï¼Œå¦‚æœæ˜¯100å°±è¦ç»§ç»­å»è¯»å–çœŸæ­£çš„å“åº”ï¼Œå¹¶ä¸”æŠŠè¯»å–æ•°æ®çš„é•¿åº¦é™åˆ¶é‡ç½®ã€‚è¿™é‡Œè¦è¯·æ±‚ä¸€ç‚¹çš„æ—¶å€™ï¼Œä¸ºä»€ä¹ˆæ¥æ”¶åˆ°100çš„çŠ¶æ€ç ä¹‹åï¼Œå®¢æˆ·ç«¯ä»…ä»…åªæ˜¯ç»§ç»­å»è¯»æ¥ä¸‹æ¥çš„å“åº”è€Œä¸æ˜¯å†å‘ä¸€æ¬¡è¯·æ±‚ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬çš„å†™å¾ªç¯å·²ç»ä¸€æ¬¡æ€§æŠŠè¯·æ±‚çš„å†…å®¹éƒ½ä¼ é€’ç»™æœåŠ¡ç«¯äº†ã€‚ä¸å­˜åœ¨å…ˆå‘é€100-continueçš„è¯·æ±‚æµ‹è¯•æœåŠ¡ç«¯ç„¶åå†å¤„ç†çš„æƒ…å†µã€‚</p>

<p>è·å–å¹¶è§£æå®Œbodyä¹‹åï¼ŒreadLoopä¸­ä¼šå‘åˆ†å‡ ç§æƒ…å†µæ¥å¤„ç†è¿™ä¸ªå“åº”ã€‚</p>

<ol>
<li>æ¥æ”¶è¿™ä¸ªå“åº”çš„æ—¶å€™æœ‰é”™è¯¯ï¼Œé‚£ä¹ˆç›´æ¥å°†é”™è¯¯è¿”å›ç»™å¤–å±‚çš„roundTrip</li>
<li>æ¥æ”¶çš„å“åº”æ²¡æœ‰Body,ç›´æ¥å°†è§£æå‡ºæ¥çš„responseè¿”å›</li>
<li>å¦‚æœæœ‰bodyï¼Œé‚£ä¹ˆå¯¹bodyè¦åšä¸€äº›å¤„ç†ã€‚æœ€ç»ˆè¿”å›ç»™å¤–éƒ¨ã€‚</li>
</ol>

<p>è‡³æ­¤ï¼ŒTransportç±»å‹ä¸­çš„RoundTripæ–¹æ³•å°±å·²ç»ä»‹ç»å®Œæ¯•äº†ã€‚å…¶ä¸­è¿˜æ˜¯æœ‰å¾ˆå¤šç»†èŠ‚æ²¡æœ‰å»æ¢ç©¶çš„ï¼Œä½†æ˜¯è¿™å¹¶ä¸å½±å“æˆ‘ä»¬é¢†ç•¥goè¯­è¨€è¿™å¥—httpæ¡†æ¶å®ç°çš„ç²¾å¦™ä¹‹å¤„ã€‚è¿™ä¹ˆä¸€è¾¹çœ‹ä¸‹æ¥ï¼Œæˆ‘è§‰å¾—å®ç°æ¯”è¾ƒå·§å¦™çš„å°±æ˜¯å¯¹å‡ ä¸ªchannelçš„è¿ç”¨ã€‚æˆ‘ç›®å‰è§‰å¾—ï¼Œèƒ½å¦æŠŠgoç”¨å¥½ï¼Œä¸€ä¸ªæ˜¯çœ‹channelçš„è¿ç”¨ï¼Œè¿˜æœ‰ä¸€ä¸ªå°±æ˜¯interfaceçš„ä½¿ç”¨ã€‚</p>
</main>

    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
      <hr/>
      Open-Source | <a href="https://github.com/goodroot/hugo-classic">Github</a> | <a href="https://twitter.com/thegoodroot">Twitter</a>
      
    </footer>
  </body>
</html>

