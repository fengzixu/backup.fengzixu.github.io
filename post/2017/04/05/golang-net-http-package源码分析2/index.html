<!DOCTYPE html>
<html lang="en-us" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>golang-net/http-package源码分析(2) - LittleDriver</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="xuran" />
  <meta name="description" content="Table of Contents generated with DocToc DetectContentType Error Handle ServeMux ServeMux.Handle Handler ServeMux.ServeHTTP HandleFunc ListenAndServe DetectContentType func DetectContentType(data []byte) string DetectContentType函数的功能是根据data字节数组的内容来判定它的Content-T" />







<meta name="generator" content="Hugo 0.51" />


<link rel="canonical" href="http://littledriver.net/post/2017/04/05/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/" />



<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.f384a7fa4673433bc34e238c5074bb1303d90e5d5a29a2ffbaf61226ef213c29.css" integrity="sha256-84Sn&#43;kZzQzvDTiOMUHS7EwPZDl1aKaL/uvYSJu8hPCk=" media="screen">





<meta property="og:title" content="golang-net/http-package源码分析(2)" />
<meta property="og:description" content="Table of Contents generated with DocToc DetectContentType Error Handle ServeMux ServeMux.Handle Handler ServeMux.ServeHTTP HandleFunc ListenAndServe DetectContentType func DetectContentType(data []byte) string DetectContentType函数的功能是根据data字节数组的内容来判定它的Content-T" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://littledriver.net/post/2017/04/05/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/" /><meta property="article:published_time" content="2017-04-05T19:58:31&#43;00:00"/>
<meta property="article:modified_time" content="2017-04-05T19:58:31&#43;00:00"/>

<meta itemprop="name" content="golang-net/http-package源码分析(2)">
<meta itemprop="description" content="Table of Contents generated with DocToc DetectContentType Error Handle ServeMux ServeMux.Handle Handler ServeMux.ServeHTTP HandleFunc ListenAndServe DetectContentType func DetectContentType(data []byte) string DetectContentType函数的功能是根据data字节数组的内容来判定它的Content-T">


<meta itemprop="datePublished" content="2017-04-05T19:58:31&#43;00:00" />
<meta itemprop="dateModified" content="2017-04-05T19:58:31&#43;00:00" />
<meta itemprop="wordCount" content="8358">



<meta itemprop="keywords" content="SourceCodeAnalyse," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="golang-net/http-package源码分析(2)"/>
<meta name="twitter:description" content="Table of Contents generated with DocToc DetectContentType Error Handle ServeMux ServeMux.Handle Handler ServeMux.ServeHTTP HandleFunc ListenAndServe DetectContentType func DetectContentType(data []byte) string DetectContentType函数的功能是根据data字节数组的内容来判定它的Content-T"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LittleDriver</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://littledriver.net/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://littledriver.net/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://littledriver.net/tags/">Tags</a>
          
        
      </li>
    
  </ul>
</nav>


  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      LittleDriver
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://littledriver.net/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://littledriver.net/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://littledriver.net/tags/">Tags</a>
          

        

      </li>
    
    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">golang-net/http-package源码分析(2)</h1>
      
      <div class="post-meta">
        <time datetime="2017-04-05" class="post-time">
          2017-04-05
        </time>
        <div class="post-category">
            <a href="http://littledriver.net/categories/%E5%B7%A5%E4%BD%9C%E4%BA%86%E4%B9%9F%E4%B8%8D%E8%83%BD%E6%94%BE%E6%9D%BE%E7%B3%BB%E5%88%97/"> 工作了也不能放松系列 </a>
            
          </div>
        

        
        

        
        
      </div>
    </header>

    
    

    
    <div class="post-content">
      <!-- START doctoc generated TOC please keep comment here to allow auto update -->

<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p>

<ul>
<li><a href="#detectcontenttype">DetectContentType</a></li>
<li><a href="#error">Error</a></li>
<li><a href="#handle">Handle</a></li>
<li><a href="#servemux">ServeMux</a></li>
<li><a href="#servemuxhandle">ServeMux.Handle</a></li>
<li><a href="#handler">Handler</a></li>
<li><a href="#servemuxservehttp">ServeMux.ServeHTTP</a></li>
<li><a href="#handlefunc">HandleFunc</a></li>
<li><a href="#listenandserve">ListenAndServe</a></li>
</ul>

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h1 id="detectcontenttype">DetectContentType</h1>

<pre><code>	func DetectContentType(data []byte) string
</code></pre>

<p>DetectContentType函数的功能是根据data字节数组的内容来判定它的Content-Type值。该函数最多取data数据的前512个字节来进行判断，函数内部会先过滤掉一些空白字符，然后就根据一定的匹配算法来进行匹配，如果没有匹配到任何已知的类型，就会返回一个 &ldquo;application/octet-stream&rdquo;。</p>

<h1 id="error">Error</h1>

<pre><code>	func Error(w ResponseWriter, error string, code int)
</code></pre>

<p>Error方法将会把用户指定的error和状态码写入ResponseWriter。但是调用这个函数的人需要确保没有进一步的信息写入到ResponseWriter。
实现代码是非常简单的，就是向response的header中写入数据：</p>

<pre><code>	func Error(w ResponseWriter, error string, code int) {
		w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;)
		w.Header().Set(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;)
		w.WriteHeader(code)
		fmt.Fprintln(w, error)
	}
</code></pre>

<h1 id="handle">Handle</h1>

<pre><code>	func Handle(pattern string, handler Handler)
</code></pre>

<p>Handle这个方法以及HandleFunc，ServeHttp，DefaultServeMux等都是golang实现的http框架中非常重要的元素，这篇文章接下来的篇幅我将和大家请一起学习它们，以了解一个http请求是如何通过golang实现的http框架来到服务后端处理并最终返回给客户端的。</p>

<p>简单来说，handle这个函数就是把请求的url和处理这个请求的方法绑定到一起。它的实现如下：</p>

<pre><code>// Handle registers the handler for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }
</code></pre>

<h1 id="servemux">ServeMux</h1>

<p>可以看出在Handle方法里面调用了DefaultServeMux的handle方法来实现pattern和handler的绑定操作。那么这个DefaultServeMux是什么呢？DefaultServeMux是ServeMux类型变量的一个指针，ServeMux类型的定义如下：</p>

<pre><code>// ServeMux is an HTTP request multiplexer.
// It matches the URL of each incoming request against a list of registered
// patterns and calls the handler for the pattern that
// most closely matches the URL.
//
// Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;,
// or rooted subtrees, like &quot;/images/&quot; (note the trailing slash).
// Longer patterns take precedence over shorter ones, so that
// if there are handlers registered for both &quot;/images/&quot;
// and &quot;/images/thumbnails/&quot;, the latter handler will be
// called for paths beginning &quot;/images/thumbnails/&quot; and the
// former will receive requests for any other paths in the
// &quot;/images/&quot; subtree.
//
// Note that since a pattern ending in a slash names a rooted subtree,
// the pattern &quot;/&quot; matches all paths not matched by other registered
// patterns, not just the URL with Path == &quot;/&quot;.
//
// If a subtree has been registered and a request is received naming the
// subtree root without its trailing slash, ServeMux redirects that
// request to the subtree root (adding the trailing slash). This behavior can
// be overridden with a separate registration for the path without
// the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux
// to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has
// been registered separately.
//
// Patterns may optionally begin with a host name, restricting matches to
// URLs on that host only. Host-specific patterns take precedence over
// general patterns, so that a handler might register for the two patterns
// &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over
// requests for &quot;http://www.google.com/&quot;.
//
// ServeMux also takes care of sanitizing the URL request path,
// redirecting any request containing . or .. elements or repeated slashes
// to an equivalent, cleaner URL.
type ServeMux struct {
	mu    sync.RWMutex
	m     map[string]muxEntry
	hosts bool // whether any patterns contain hostnames
}
</code></pre>

<p>其实只看第一段落，我们对一个请求在golang的http框架中流动的过程就有了一个大致的了解：
服务端首先将一些pattern和handler绑定在一起，形成了一个pattern和handler一一对应的列表。ServeMux作为服务端一个http请求路由的角色出现，它将对进来的请求和我们已经构造好的pattern列表进行匹配，找到一个最佳的匹配项，然后调用相应的handler处理请求，最终将结果返回给用户。http包中的Handle方法之所以会调用DefaultServeMux的Handle方法，就是要把一条pattern和handler绑定的列表项注册到ServerMux上。以便ServerMux在接受到外部过来的请求之后可以依此来进行请求的派发。</p>

<p>文档中既然说到会找到一个最佳的匹配项，那么ServeMux中就会按照一定的匹配规则去做：</p>

<ol>
<li>如果Pattern一个绝对路径指定的文件或者说是一个目录，那么此时，pattern长度越长与请求的匹配度越高。如一个请求[<a href="http://localhost:9090/abc/def/]()。假设我们注册了两个pattern和handler的表项。一个是/abc/另外一个是/abc/def/，这个时候ServeMux会优先匹配后者。并且需要注意的是，一个请求如果最后是以斜线结尾的，并且没有匹配到任何一个已经注册的Pattern-Handler表项，如果根目录/这个pattern已经被注册则会命中此条规则。">http://localhost:9090/abc/def/]()。假设我们注册了两个pattern和handler的表项。一个是/abc/另外一个是/abc/def/，这个时候ServeMux会优先匹配后者。并且需要注意的是，一个请求如果最后是以斜线结尾的，并且没有匹配到任何一个已经注册的Pattern-Handler表项，如果根目录/这个pattern已经被注册则会命中此条规则。</a></li>
<li>如果一个子目录的pattern已经注册好了，此时外部进来的一个请求其余的部分都命中这个pattern，但是唯独最后一个斜线不匹配，此时golang的http框架会将这个请求重定向到已经注册好的子目录的handler上。但是如果不带斜线的pattern已经被明确的注册过了，那么此时golang就不会再进行重定向操作。</li>
<li>如果hosts被置为TRUE，那么在进行匹配的时候就会对请求的path加上hostname作为pattern来进行匹配。</li>
</ol>

<p>了解了ServeMux是一个类似http路由的组件，那么接下来就看看ServeMux的Handle方法都做了些什么。</p>

<h1 id="servemux-handle">ServeMux.Handle</h1>

<pre><code>	
// Handle registers the handler for the given pattern.
// If a handler already exists for pattern, Handle panics.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
	mux.mu.Lock()
	defer mux.mu.Unlock()

	if pattern == &quot;&quot; {
		panic(&quot;http: invalid pattern &quot; + pattern)
	}
	if handler == nil {
		panic(&quot;http: nil handler&quot;)
	}
	if mux.m[pattern].explicit {
		panic(&quot;http: multiple registrations for &quot; + pattern)
	}

	if mux.m == nil {
		mux.m = make(map[string]muxEntry)
	}
	mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

	if pattern[0] != '/' {
		mux.hosts = true
	}

	// Helpful behavior:
	// If pattern is /tree/, insert an implicit permanent redirect for /tree.
	// It can be overridden by an explicit registration.
	n := len(pattern)
	if n &gt; 0 &amp;&amp; pattern[n-1] == '/' &amp;&amp; !mux.m[pattern[0:n-1]].explicit {
		// If pattern contains a host name, strip it and use remaining
		// path for redirect.
		path := pattern
		if pattern[0] != '/' {
			// In pattern, at least the last character is a '/', so
			// strings.Index can't be -1.
			path = pattern[strings.Index(pattern, &quot;/&quot;):]
		}
		url := &amp;url.URL{Path: path}
		mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
	}
}

</code></pre>

<p>因为Handle方法会修改ServeMux中的Map，为了实现线程安全的Handle方法，一进来就对Handle这个函数加上了写锁。紧接着就是一些参数的检查工作，比如注册的pattern是否为空，handler是否为nil以及该pattern是否已经注册过一次了，这些都是属于非法的注册行为。如果以上的检查都通过了，那么golang将会在ServeMux中的Map内增加一条注册记录。如果此时我们的pattern是以斜线结尾的，那么golang会检测不以斜线结尾的pattern是否已经注册过，如果没有注册过，它会为我们将不带斜线的pattern注册，并且handler重定向到带有斜线的pattern对应的handler。这里需要注意一点：</p>

<ol>
<li>通过重定向的方式来注册不带斜线的pattern的时候，explicit并没有置为true，这就说明如果我们以后要明确注册一个不以斜线结尾的pattern的时候，是可以实现覆盖的效果的，不会被前面的检查条件挡住。</li>
</ol>

<p>回忆一下我们现在都了解了哪些知识点：首先可以通过一个Http包的Handle方法将一个pattern和handler注册起来，然后发现注册的这个操作实际上是由ServeMux这个类型的对象来实现的，它相当于一个Http的路由，ServeMux在注册时候，会做出一些改变，如为不带斜线的pattern默认添加重定向的Handler等。那么处理一个和Pattern匹配的请求的Handler是个什么东西呢？</p>

<h1 id="handler">Handler</h1>

<pre><code>// A Handler responds to an HTTP request.
//
// ServeHTTP should write reply headers and data to the ResponseWriter
// and then return. Returning signals that the request is finished; it
// is not valid to use the ResponseWriter or read from the
// Request.Body after or concurrently with the completion of the
// ServeHTTP call.
//
// Depending on the HTTP client software, HTTP protocol version, and
// any intermediaries between the client and the Go server, it may not
// be possible to read from the Request.Body after writing to the
// ResponseWriter. Cautious handlers should read the Request.Body
// first, and then reply.
//
// Except for reading the body, handlers should not modify the
// provided Request.
//
// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes
// that the effect of the panic was isolated to the active request.
// It recovers the panic, logs a stack trace to the server error log,
// and hangs up the connection. To abort a handler so the client sees
// an interrupted response but the server doesn't log an error, panic
// with the value ErrAbortHandler.
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
</code></pre>

<p>Handler是一个接口，它里面包含了一个ServeHttp的方法，也就是说，任何一个实现了ServeHttp方法的对象，都可以被赋值给Handler对象。Handler正如我们前面所讲到的那样，它负责处理一个http的请求。实际的处理逻辑应该在ServeHttp方法中实现。这个方法接收两个参数，一个是ResponseWriter，一个是Request。ServeHttp方法要保证先读取request，处理完之后把返回的header和body部分写入到responsewriter中，这个处理的顺序不能够颠倒。并且在ServeHttp在将响应结果写入到responseWriter之后，就不应该在使用ResponseWriter和request这两个参数了。说白了，当ServeHttp写入结果到respinseWriter的那一刻，整个http请求的处理就结束了。并且，golang明确的提示我们，ServeHttp内部不应该去修改request的相关信息。当ServeHttp出现panic的时候，golang会recover住它，在服务的日志中输出堆栈信息且挂起这个链接。如果直接终止一个handler，那么服务不会输出错误，而是直接panic崩掉，同时客户端也会得到一个中断的响应。</p>

<h1 id="servemux-servehttp">ServeMux.ServeHTTP</h1>

<p>既然现在，pattern有了，handler有了，ServeMux的注册功能也有了，那么ServeMux作为一个路由是如何将一个http请求匹配到已经注册的pattern，并且交由这个pattern对应的handler处理的呢？这也就是ServeMux派发request的一个过程。ServeMux也实现了一个ServeHttp的方法，这证明它其实也可以算作是一个handler，那么在外部请求进入到服务的时候，ServeMux会作为一个前置的handler来处理这个请求，而ServeMux的处理方式就是去匹配pattern并且派发这个请求给具体处理逻辑。</p>

<pre><code>// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == &quot;*&quot; {
		if r.ProtoAtLeast(1, 1) {
			w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r)
	h.ServeHTTP(w, r)
}
</code></pre>

<p>可以看到ServeMux的ServeHttp方法在处理请求的时候，会先检查request中的url是否为*。然后他会检查请求的http协议版本至少要在1.1及以上才是合法的，否则就返回给客户端一个错误。然后，serveMux将会调用Handler方法，该方法中将会检查request中的信息并匹配到相应的pattern，返回给我们一个能够处理该请求的一个handler。最后调用该handler实现的ServeHttp方法处理这个请求。看起来ServeHttp这个方法的重点就在于这个Handler方法的实现了。</p>

<pre><code>// Handler returns the handler to use for the given request,
// consulting r.Method, r.Host, and r.URL.Path. It always returns
// a non-nil handler. If the path is not in its canonical form, the
// handler will be an internally-generated handler that redirects
// to the canonical path.
//
// Handler also returns the registered pattern that matches the
// request or, in the case of internally-generated redirects,
// the pattern that will match after following the redirect.
//
// If there is no registered handler that applies to the request,
// Handler returns a ``page not found'' handler and an empty pattern.
func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
	if r.Method != &quot;CONNECT&quot; {
		if p := cleanPath(r.URL.Path); p != r.URL.Path {
			_, pattern = mux.handler(r.Host, p)
			url := *r.URL
			url.Path = p
			return RedirectHandler(url.String(), StatusMovedPermanently), pattern
		}
	}

	return mux.handler(r.Host, r.URL.Path)
}
</code></pre>

<p>Handler这个方法是永远不会返回一个值为nil的handler，即使最后request没有匹配到任何的handler，函数也会返回一个“page not found”的handler。匹配之前，handler会先调用cleanPath来对请求的urlpath做一些清理工作，排除匹配时候的干扰。清理之后的path如果和request内的urlpath不一致的话，那就说明，request内的urlpath是不符合规范的，不是一个标准的形式，此时，golang将会返回一个用于重定向这个请求的Handler。如果确实发生了这种情况，那么ServeMux的ServeHttp方法将会调用RedirectHandler类型的ServeHttp方法来处理请求。通过观察RedirectHandler的ServeHttp方法的实现，我们知道，RedirectHandler在处理请求的时候最终是将重定向的状态码和location头部字段写入到Response的header中，其中location的内容就是根据我们规范过的path来确定的。</p>

<p>如果request传递进来的path就是一个标准的形式，那么将会调用mux.handler方法开始进行匹配工作.</p>

<pre><code>// handler is the main implementation of Handler.
// The path is known to be in canonical form, except for CONNECT methods.
func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
	mux.mu.RLock()
	defer mux.mu.RUnlock()

	// Host-specific pattern takes precedence over generic ones
	if mux.hosts {
		h, pattern = mux.match(host + path)
	}
	if h == nil {
		h, pattern = mux.match(path)
	}
	if h == nil {
		h, pattern = NotFoundHandler(), &quot;&quot;
	}
	return
}

</code></pre>

<p>handler一开始就用读锁锁住了整个函数，说明在这个函数中会读取ServeMux中的handler注册的map。之前在了解ServeMux成员结构的时候说过，如果ServeMux开启了强制带域名匹配，那么它是第一优先级的，待匹配的path也要加上host。如果强制带域名匹配没有匹配到，那么就会进行其他正常的匹配，否则认为没有匹配到，返回有一个NotFoundHanlder。NotFoundHanlder在处理请求的时候也是向response写入相应的错误信息，返回给客户端。ServeMux的math方法将会遍历注册了pattern和handler的map，对pattern和path进行匹配。在匹配的时候如果发现注册map当中的pattern与path有多个匹配情况，那么将会选取pattern最长的那个作为最佳的匹配项，这一点在介绍ServeMux类型的时候也是说过的。</p>

<p>其实讲到这里，一个请求从外部进来，到ServeMux,到handler，到ServeHttp，最终处理完成返回给客户端的一条线就已经是通的了。其中涉及到了一些细枝末节的东西，如path.Clean是如何清洗urlpath的，这些我们暂时都不做过多的了解。我们的重点要放在golang实现的http框架上面，了解它是如何进行运作的。</p>

<p>之前我们是从http包中的Handle说起的，那么紧接着我们就来看看HandleFunc这个函数都做了什么以及与Handle方法有何异同。</p>

<h1 id="handlefunc">HandleFunc</h1>

<pre><code>// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}
</code></pre>

<p>HandleFunc这个函数看起来和Handle没有什么区别，都是调用了DefaultServeMux的同名方法对pattern和处理与这个pattern匹配的请求的handler进行注册。只不过HandleFunc注册的handler并不是一个Handler类型的对象，而直接是一个函数，这个函数的原型和Handler类型中的ServeHttp方法是一样的。</p>

<pre><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}
</code></pre>

<p>ServeMux的HandleFunc方法内部调用的还是Handle方法，只不过对我们传递进来的函数方法通过HandlerFunc转换成一个Handler的对象。</p>

<pre><code>// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
</code></pre>

<p>在golang中我们知道，函数也是一种值，这种值的类型我暂且就把它称作是一个函数类型吧。既然是类型，那么在golang中就可以实现这个类型相应的成员方法，HandlerFunc就是这样。ServeMux的Handle方法第二个参数就是接受了一个Handler对象，只要实现了ServeHttp方法，都可以赋值给它。HandlerFunc也实现了一个，只不过在内部调用了自己。感觉是golang利用Interface的特性玩了一个小把戏，为我们提供了额外的一种方式来对pattern和handler进行注册。</p>

<h1 id="listenandserve">ListenAndServe</h1>

<p>listenAndServe这个方法应该是处理一个http请求的流程中最重要的一个方法了。从函数名上我们就可以看出，这个函数起到了监听和提供服务的作用。</p>

<pre><code>
// ListenAndServe listens on the TCP network address addr
// and then calls Serve with handler to handle requests
// on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
// Handler is typically nil, in which case the DefaultServeMux is
// used.
//
// A trivial example server is:
//
//	package main
//
//	import (
//		&quot;io&quot;
//		&quot;net/http&quot;
//		&quot;log&quot;
//	)
//
//	// hello world, the web server
//	func HelloServer(w http.ResponseWriter, req *http.Request) {
//		io.WriteString(w, &quot;hello, world!\n&quot;)
//	}
//
//	func main() {
//		http.HandleFunc(&quot;/hello&quot;, HelloServer)
//		log.Fatal(http.ListenAndServe(&quot;:12345&quot;, nil))
//	}
//
// ListenAndServe always returns a non-nil error.
func ListenAndServe(addr string, handler Handler) error {
	server := &amp;Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}

</code></pre>

<p>ListenAndServe通过监听一个tcp的网络地址来为通过某个tcp链接发来的请求提供服务。可以看到该函数的第二个参数就是一个Handler对象，ListenAndServe显然已经是golang服务框架中最外层的入口了，那么首先处理从外部进来请求的handler自然应该是ServeMux。当我们指定第二个参数为nil的时候，golang就会使用DefaultServeMux作为我们整个服务的路由handler。</p>

<pre><code>
// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
// If srv.Addr is blank, &quot;:http&quot; is used.
// ListenAndServe always returns a non-nil error.
func (srv *Server) ListenAndServe() error {
	addr := srv.Addr
	if addr == &quot;&quot; {
		addr = &quot;:http&quot;
	}
	ln, err := net.Listen(&quot;tcp&quot;, addr)
	if err != nil {
		return err
	}
	return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}
</code></pre>

<p>http包中的ListenAndServe方法在其内部通过定义了一个server对象，调用server的ListenAndServe方法。这个Server看起来就是整个golang的http服务框架的核心类型。它的ListenAndServe方法监听了本机的addr端口并调用Serve方法来开启整个服务。前面我们讲到了一个请求到了ServeMux之后是如何被派发并且处理的，那么接下来，我们就来研究一下一个请求是如何从客户端到达ServeMux的。</p>

<pre><code>	
// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
//
// For HTTP/2 support, srv.TLSConfig should be initialized to the
// provided listener's TLS Config before calling Serve. If
// srv.TLSConfig is non-nil and doesn't include the string &quot;h2&quot; in
// Config.NextProtos, HTTP/2 support is not enabled.
//
// Serve always returns a non-nil error. After Shutdown or Close, the
// returned error is ErrServerClosed.
func (srv *Server) Serve(l net.Listener) error {
	defer l.Close()
	if fn := testHookServerServe; fn != nil {
		fn(srv, l)
	}
	var tempDelay time.Duration // how long to sleep on accept failure

	if err := srv.setupHTTP2_Serve(); err != nil {
		return err
	}

	srv.trackListener(l, true)
	defer srv.trackListener(l, false)

	baseCtx := context.Background() // base is always background, per Issue 16220
	ctx := context.WithValue(baseCtx, ServerContextKey, srv)
	ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())
	for {
		rw, e := l.Accept()
		if e != nil {
			select {
			case &lt;-srv.getDoneChan():
				return ErrServerClosed
			default:
			}
			if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay &gt; max {
					tempDelay = max
				}
				srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return e
		}
		tempDelay = 0
		c := srv.newConn(rw)
		c.setState(c.rwc, StateNew) // before Serve can return
		go c.serve(ctx)
	}
}

</code></pre>

<p>server对象调用了Serve方法之后，可以看到，在其实现中有一个死循环，不断的接受从外部而来的网络连接，为每一个网络连接都开启一个goroutine调用Conn类型对象的serve方法来处理这条连接上发来的http请求。Serve函数大体的逻辑就是这样，一些实现的细节我们暂时先不追究，但是有一点需要注意的是，server调用了newConn创建了一个Conn类型的对象，这个对象内其中一个成员就是我们的server对象，也就是说，再创建这个Conn对象的时候把server自己也传递了进去。</p>

<p>了解了以上我们说的几点就可以继续向下研究了。</p>

<pre><code>func (c *conn) serve(ctx context.Context) {
	c.remoteAddr = c.rwc.RemoteAddr().String()
	defer func() {
		if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler {
			const size = 64 &lt;&lt; 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			c.server.logf(&quot;http: panic serving %v: %v\n%s&quot;, c.remoteAddr, err, buf)
		}
		if !c.hijacked() {
			c.close()
			c.setState(c.rwc, StateClosed)
		}
	}()

	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		if d := c.server.ReadTimeout; d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		}
		if d := c.server.WriteTimeout; d != 0 {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}
		if err := tlsConn.Handshake(); err != nil {
			c.server.logf(&quot;http: TLS handshake error from %s: %v&quot;, c.rwc.RemoteAddr(), err)
			return
		}
		c.tlsState = new(tls.ConnectionState)
		*c.tlsState = tlsConn.ConnectionState()
		if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
			if fn := c.server.TLSNextProto[proto]; fn != nil {
				h := initNPNRequest{tlsConn, serverHandler{c.server}}
				fn(c.server, tlsConn, h)
			}
			return
		}
	}

	// HTTP/1.x from here on.

	ctx, cancelCtx := context.WithCancel(ctx)
	c.cancelCtx = cancelCtx
	defer cancelCtx()

	c.r = &amp;connReader{conn: c}
	c.bufr = newBufioReader(c.r)
	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&lt;&lt;10)

	for {
		w, err := c.readRequest(ctx)
		if c.r.remain != c.server.initialReadLimitSize() {
			// If we read any bytes off the wire, we're active.
			c.setState(c.rwc, StateActive)
		}
		if err != nil {
			const errorHeaders = &quot;\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n&quot;

			if err == errTooLarge {
				// Their HTTP client may or may not be
				// able to read this if we're
				// responding to them and hanging up
				// while they're still writing their
				// request. Undefined behavior.
				const publicErr = &quot;431 Request Header Fields Too Large&quot;
				fmt.Fprintf(c.rwc, &quot;HTTP/1.1 &quot;+publicErr+errorHeaders+publicErr)
				c.closeWriteAndWait()
				return
			}
			if isCommonNetReadError(err) {
				return // don't reply
			}

			publicErr := &quot;400 Bad Request&quot;
			if v, ok := err.(badRequestError); ok {
				publicErr = publicErr + &quot;: &quot; + string(v)
			}

			fmt.Fprintf(c.rwc, &quot;HTTP/1.1 &quot;+publicErr+errorHeaders+publicErr)
			return
		}

		// Expect 100 Continue support
		req := w.req
		if req.expectsContinue() {
			if req.ProtoAtLeast(1, 1) &amp;&amp; req.ContentLength != 0 {
				// Wrap the Body reader with one that replies on the connection
				req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}
			}
		} else if req.Header.get(&quot;Expect&quot;) != &quot;&quot; {
			w.sendExpectationFailed()
			return
		}

		c.curReq.Store(w)

		if requestBodyRemains(req.Body) {
			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)
		} else {
			if w.conn.bufr.Buffered() &gt; 0 {
				w.conn.r.closeNotifyFromPipelinedRequest()
			}
			w.conn.r.startBackgroundRead()
		}

		// HTTP cannot have multiple simultaneous active requests.[*]
		// Until the server replies to this request, it can't read another,
		// so we might as well run the handler in this goroutine.
		// [*] Not strictly true: HTTP pipelining. We could let them all process
		// in parallel even if their responses need to be serialized.
		// But we're not going to implement HTTP pipelining because it
		// was never deployed in the wild and the answer is HTTP/2.
		serverHandler{c.server}.ServeHTTP(w, w.req)
		w.cancelCtx()
		if c.hijacked() {
			return
		}
		w.finishRequest()
		if !w.shouldReuseConnection() {
			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
				c.closeWriteAndWait()
			}
			return
		}
		c.setState(c.rwc, StateIdle)
		c.curReq.Store((*response)(nil))

		if !w.conn.server.doKeepAlives() {
			// We're in shutdown mode. We might've replied
			// to the user without &quot;Connection: close&quot; and
			// they might think they can send another
			// request, but such is life with HTTP/1.1.
			return
		}

		if d := c.server.idleTimeout(); d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
			if _, err := c.bufr.Peek(4); err != nil {
				return
			}
		}
		c.rwc.SetReadDeadline(time.Time{})
	}
}

</code></pre>

<p>在conn对象的serve方法中，最引人注目的代码不过有两行，而这两行也是最核心的：</p>

<ol>
<li>serve方法中开启了一个死循环，死循环中不断的调用readRequest(ctx)来处理从这条连接上发送过来的http请求。</li>
<li>serverHandler{c.server}.ServeHTTP(w, w.req)，其次便是这一行代码。</li>
</ol>

<p>我们之前说过，conn对象在创建的时候是把server对象也包含进来的，而server对象中有一个Handler成员，它在我们定义这个server对象的时候被赋值为了nil，如果我们要使用server对象中的这个Handler成员的话，就会默认使用golang为我们预定义的DefaultServerMux对象，也就是我们所说的服务的http路由。在conn对象的serve方法内，通过readRequest来读取请求中的内容，然后调用DefaultServerMux对象的ServeHttp方法进行请求的派发处理。至此，一个http请求就是通过这样的方式从服务的外部传输到服务的内部，最后调用了DefaultServerMux的ServeHttp方法开始处理它。并且在处理完这个request之后我们还会检查是否server开启了keepalives的特性，如果开启了，那么就会保持这个闲置的链接一段时间直到请求到达在进行处理，如果没有开启这个特性那么此链接最终就会被关闭。</p>
    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="http://littledriver.net/tags/sourcecodeanalyse/">SourceCodeAnalyse</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/2017/04/06/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">golang-net-http-package源码分析(3)</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/2017/04/04/learning-for-apue3-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/">
            <span class="next-text nav-default">Learning for APUE(3)--从操作系统的角度来看文件共享</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  

  <div class="disqus-comment">
  <div class="disqus-button" id="load_disqus" onclick="load_disqus()">
    Show Disqus Comments
  </div>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
      this.page.url = "http://littledriver.net/post/2017/04/05/golang-net-http-package%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/";
    };
    function load_disqus() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'fengzixu';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

      $('#load_disqus').remove();
    };
  </script>
  <noscript>Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  </div>
  
    



        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
  
    <a href="mailto:hnustphoenix@email.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/Haier0715" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://github.com/fengzixu" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="http://littledriver.net/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
       -
    2018
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        xuran
        
      </span></span>

  
  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ="></script>














  <script id="dsq-count-scr" src="//fengzixu.disqus.com/count.js" async></script>





</body>
</html>
