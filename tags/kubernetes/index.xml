<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes on LittleDriver</title>
    <link>http://littledriver.net/tags/kubernetes/</link>
    <description>Recent content in Kubernetes on LittleDriver</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Dec 2018 17:16:38 +0800</lastBuildDate>
    
	<atom:link href="http://littledriver.net/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Detect Source Code of Statefulset Controller</title>
      <link>http://littledriver.net/post/2018/12/05/detect-source-code-of-statefulset-controller/</link>
      <pubDate>Wed, 05 Dec 2018 17:16:38 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/12/05/detect-source-code-of-statefulset-controller/</guid>
      <description>因为 blog 贴过多的代码或者链接不太美观，也不易于阅读。所以，建议大家下载 Kubernetes 1.12 版本的源码再配合 blog 来看。blog 只能对各位了解 StatefulSet Controller 原理起到一个抛砖引</description>
    </item>
    
    <item>
      <title>Detect Source Code of Scheduler</title>
      <link>http://littledriver.net/post/2018/11/29/detect-source-code-of-scheduler/</link>
      <pubDate>Thu, 29 Nov 2018 14:36:58 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/29/detect-source-code-of-scheduler/</guid>
      <description>Detect the source code of Scheduler 本文基于 Kubernetes 1.12 版本 写在前面 在上一篇关于 Scheduler 的文章中，我们主要从宏观的层面上了解了 Kubernetes 中调度的大概流程。本篇 blog，我将从源码级别分析</description>
    </item>
    
    <item>
      <title>Detect the Mechanism of Scheduling in Kubernetes</title>
      <link>http://littledriver.net/post/2018/11/23/detect-the-mechanism-of-scheduling-in-kubernetes/</link>
      <pubDate>Fri, 23 Nov 2018 00:28:01 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/23/detect-the-mechanism-of-scheduling-in-kubernetes/</guid>
      <description>什么是 Kubernetes scheduling？ Kubernetes scheduling是 Kubernetes 集群中的调度机制，它负责将集群内部的资源按照一定的策略将其调度到不同的 Node 上运行。更准</description>
    </item>
    
    <item>
      <title>Detect the Source Code of List Watch Between API Server and Controller</title>
      <link>http://littledriver.net/post/2018/11/22/detect-the-source-code-of-list-watch-between-api-server-and-controller/</link>
      <pubDate>Thu, 22 Nov 2018 09:12:21 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/22/detect-the-source-code-of-list-watch-between-api-server-and-controller/</guid>
      <description>写在前面 在上一篇blog 中，我们从源码的角度来分析了 Kubernetes 中的List-Watch机制的部分内容。它更注重于 API Server 和 etcd 之间的交互。通过下面的这幅 Kubernetes</description>
    </item>
    
    <item>
      <title>Detect the Source Code of List Watch Between API Server and Etcd</title>
      <link>http://littledriver.net/post/2018/11/21/detect-the-source-code-of-list-watch-between-api-server-and-etcd/</link>
      <pubDate>Wed, 21 Nov 2018 13:13:45 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/21/detect-the-source-code-of-list-watch-between-api-server-and-etcd/</guid>
      <description>写在前面 在上一篇文章中，我们通过 Kubernetes 的架构图以及一个 Deployment 资源对象创建的过程大致了解了List-Watch机制在一个 Kubernetes 集群中所起的作用以及它所面临</description>
    </item>
    
    <item>
      <title>Detect the mechanism of list-watch in Kubernetes</title>
      <link>http://littledriver.net/post/2018/11/19/detect-the-mechanism-of-list-watch-in-kubernetes/</link>
      <pubDate>Mon, 19 Nov 2018 23:51:51 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/19/detect-the-mechanism-of-list-watch-in-kubernetes/</guid>
      <description>先来看一个小例子 一个 Kubernetes 的集群的架构通常如下图所示： 当一个用户通过kubectl命令行想要创建一个 Pod 数量为3的 Deployment 的资源对象的时候。此请求会先通</description>
    </item>
    
    <item>
      <title>K8s GC Design Principle</title>
      <link>http://littledriver.net/post/2018/11/15/k8s-gc-design-principle/</link>
      <pubDate>Thu, 15 Nov 2018 22:40:55 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/11/15/k8s-gc-design-principle/</guid>
      <description>Ref: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/garbage-collection.md#orphaning-the-descendants-with-orphan-finalizer Warning：设计文档的对应的 k8s 版本为1.7 Q: What is GC of Kuernetes ? A: GC 是 Garbage Collector 的简称。从功能层面上来说，它和编程语言当中的「GC」 基本上是一样的</description>
    </item>
    
    <item>
      <title>How to Deploy Jaeger Cluster</title>
      <link>http://littledriver.net/post/2018/09/26/how-to-deploy-jaeger-cluster/</link>
      <pubDate>Wed, 26 Sep 2018 17:58:57 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/09/26/how-to-deploy-jaeger-cluster/</guid>
      <description>Deploy Jaeger in Kubernetes Preparation 通过一张 Jaeger 的架构图，我们可以知道，要在我们的开发环境中部署一套Jaeger，需要部署以下几个组件 jaeger-agent jaeger-collector data-storage Elasticsearch Cassandra 由于我们想将 jaeger 部署到 k8s 集</description>
    </item>
    
    <item>
      <title>Head First of Tracing System</title>
      <link>http://littledriver.net/post/2018/09/26/head-first-of-tracing-system/</link>
      <pubDate>Wed, 26 Sep 2018 17:58:42 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/09/26/head-first-of-tracing-system/</guid>
      <description>什么是 Link Tracing？ 为什么我们需要 Tracing？ Link Tracing 字面意思就是链路追踪，它是一个抽象的概念。针对于一个分布式的系统来说，「链路」主要</description>
    </item>
    
    <item>
      <title>The brief of PV and PVC</title>
      <link>http://littledriver.net/post/2018/09/26/the-brief-of-pv-and-pvc/</link>
      <pubDate>Wed, 26 Sep 2018 17:58:12 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/09/26/the-brief-of-pv-and-pvc/</guid>
      <description>Overview 在 kubernetes 上部署服务，无论是「有状态」的，还是「无状态」的，可能大部分都有存储数据的需求。随之而来的就是对存储资源的需求。对于 k8s 来说，最底层的存</description>
    </item>
    
    <item>
      <title>Contrain Pod Scheduling</title>
      <link>http://littledriver.net/post/2018/09/11/contrain-pod-scheduling/</link>
      <pubDate>Tue, 11 Sep 2018 16:52:58 +0800</pubDate>
      
      <guid>http://littledriver.net/post/2018/09/11/contrain-pod-scheduling/</guid>
      <description>Overview 当我们创建一个 Pod 之后，Kubernetes 自身的一些调度规则将会根据集群节点的各项指标，为这个 Pod 选出一个合适的 Node 且将其调度上去。我们姑且可</description>
    </item>
    
    <item>
      <title>Kubernetes pod schedular strategy</title>
      <link>http://littledriver.net/post/2018/04/17/kubernetes-pod-schedular-strategy/</link>
      <pubDate>Tue, 17 Apr 2018 14:34:48 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2018/04/17/kubernetes-pod-schedular-strategy/</guid>
      <description>概述 在 k8s 中，调度 Pod 到 Node 上通常是不需要我们关心的。K8s 会自动的帮我们寻找具有合适资源的 Node，并且 Pod调度在上面。但是，有的时候，我们需</description>
    </item>
    
    <item>
      <title>k8s 之 StatefulSets</title>
      <link>http://littledriver.net/post/2018/02/24/k8s-%E4%B9%8B-statefulsets/</link>
      <pubDate>Sat, 24 Feb 2018 17:13:44 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2018/02/24/k8s-%E4%B9%8B-statefulsets/</guid>
      <description>Q： 什么是 StatefulSets？ A: StatefulSets 是一种 workload。k8s 中的一个 workload 通常由 CRD 和 controller 两部分构成，CRD 交由用户使用，创建资源实例，描</description>
    </item>
    
    <item>
      <title>Kubernetes 之 Operator(一)</title>
      <link>http://littledriver.net/post/2018/01/24/kubernetes-%E4%B9%8B-operator%E4%B8%80/</link>
      <pubDate>Wed, 24 Jan 2018 22:19:11 +0000</pubDate>
      
      <guid>http://littledriver.net/post/2018/01/24/kubernetes-%E4%B9%8B-operator%E4%B8%80/</guid>
      <description>Q: 什么是 Operator? A: Operator 在 k8s 系统中可以认为他是一个集 resource 和 controller 的结合体。他是对 resource 和 controller 的一个高度的抽象。通过扩展 Kubernetes API来达到这一效果。 Q: Operator 是如何工作的？ A:</description>
    </item>
    
  </channel>
</rss>